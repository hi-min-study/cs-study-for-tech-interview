# 📍 키워드
- 인덱스
    - 인덱스 개념
    - 인덱스 종류
    - Clustered index, Non-Clustered index
    - 인덱스 자료구조
    - 인덱스 고려사항

<br>

# 📍 예상 질문
<details>
<summary>인덱스에 대해서 설명해주세요.</summary>
<div markdown="1">

- 데이터베이스에서 인덱스는 책의 색인과 같은 역할을 하는 자료구조입니다. 특정한 값을 가진 행들을 빠르게 찾아낼 수 있도록 돕는 기능을 합니다.
- 인덱스는 특정 컬럼(들)에 대해 생성되며, 해당 컬럼의 값과 그 값이 위치한 행의 주소를 키-값 쌍으로 가지고 있습니다. 이렇게 되면 특정 값을 찾아내는 데 있어서 전체 행을 검색하는 풀 테이블 스캔 방식보다 훨씬 빠르게 데이터를 찾아낼 수 있습니다.
- MySQL에서는 B-Tree가 기본 인덱스 알고리즘으로 사용되며, 이 외에도 Full-text 인덱스, Hash 인덱스, R-Tree 인덱스 등 다양한 알고리즘이 있습니다.
- 그러나 인덱스는 항상 성능 향상을 가져오는 것만은 아닙니다. 인덱스가 많아지면 많아질수록 데이터를 삽입하거나 수정, 삭제하는 작업이 느려질 수 있습니다. 왜냐하면 데이터의 변경이 일어날 때마다 인덱스도 함께 업데이트되어야 하기 때문입니다. 따라서 인덱스는 신중하게 사용해야 합니다.

</div>
</details>
<details>
<summary>인덱스 생성 시 고려해야 할 사항은 무엇인가요?</summary>
<div markdown="1">

- 쿼리 성능 최적화: 어떤 컬럼에 인덱스를 생성할지 결정할 때, 해당 컬럼이 WHERE, JOIN, ORDER BY 등의 쿼리에서 자주 사용되는지 살펴보아야 합니다. 이러한 컬럼에 인덱스를 생성하면 해당 쿼리의 성능을 크게 향상시킬 수 있습니다.
- 카디널리티: 카디널리티가 높은 컬럼, 즉 고유값이 많은 컬럼에 인덱스를 생성하는 것이 좋습니다. 카디널리티가 낮은 컬럼, 즉 중복값이 많은 컬럼에 인덱스를 생성하면 인덱스의 효율이 떨어질 수 있습니다.
- 데이터 변경 빈도: 데이터 변경이 자주 일어나는 테이블에 인덱스를 너무 많이 생성하면, 데이터 변경 시마다 인덱스를 업데이트해야 하므로 성능이 저하될 수 있습니다. 따라서, 데이터 변경이 자주 일어나는 테이블에는 인덱스를 신중하게 생성해야 합니다.
- 인덱스 크기: 인덱스를 생성하는 컬럼의 데이터 타입이 클수록 인덱스의 크기도 커집니다. 인덱스의 크기가 클수록 디스크 공간을 많이 차지하고, 인덱스 관리에도 많은 시간이 소요됩니다. 따라서, 가능하다면 작은 데이터 타입을 가진 컬럼에 인덱스를 생성하는 것이 좋습니다.
- 복합 인덱스의 순서: 복합 인덱스를 생성할 때는 컬럼의 순서가 중요합니다. 가장 먼저 사용되는 컬럼이 선택도가 높은 컬럼이어야 인덱스의 효율이 높아집니다.

</div>
</details>
<details>
<summary>인덱스를 생성할 때 어떤 컬럼에 생성하는 것이 가장 효과적인가요?</summary>
<div markdown="1">

- 고유값이 많은 컬럼: 인덱스는 고유값이 많은 컬럼에 생성하는 것이 가장 효과적입니다. 이런 컬럼에 인덱스를 생성하면 검색 성능이 크게 향상됩니다. 반대로, 중복값이 많은 컬럼에 인덱스를 생성하면 인덱스의 효율이 떨어질 수 있습니다.
- 쿼리에서 자주 사용되는 컬럼: WHERE, JOIN, ORDER BY 등의 쿼리에서 자주 사용되는 컬럼에 인덱스를 생성하면 해당 쿼리의 성능을 크게 향상시킬 수 있습니다.
- 데이터 크기가 작은 컬럼: 인덱스는 데이터 크기에 따라 그 크기가 결정됩니다. 따라서 데이터 크기가 작은 컬럼에 인덱스를 생성하면 인덱스의 크기를 작게 유지할 수 있어, 디스크 공간을 효율적으로 사용할 수 있습니다.

</div>
</details>
<details>
<summary>인덱스를 데이터 변경이 자주 일어나는 테이블에선 사용하지 않기를 권합니다. 왜 그럴까요?</summary>
<div markdown="1">

- 인덱스 테이블은 "이진트리 검색"을 사용하기 때문에 기본적으로 정렬되어 있는 상태입니다.
- 그래서 만약 인덱스 테이블이 참조하는 테이블에서 "삽입", "삭제", "수정"이 자주 일어나게 된다면, 인덱스 테이블에서는 데이터를 재정렬하면서 삽입, 삭제, 수정이 이루어지기 때문에 전체적인 성능 저하를 초래할 수 있습니다.
- 인덱스는 수정 시, 기존 것을 수정하는 게아니라 기존 인덱스를 지우고 새로 인덱스를 생성한다고 합니다. 이는 시간이 오래 소요될 것입니다.

</div>
</details>
<details>
<summary>Clustered Index와 Non-Clustered Index의 성능 상 차이에 대해서 설명해주세요.</summary>
<div markdown="1">

- 클러스터링 인덱스: 클러스터링 인덱스는 데이터를 물리적으로 정렬된 상태로 유지합니다. 테이블의 클러스터링 인덱스는 주로 테이블의 프라이머리 키를 기반으로 생성됩니다. 따라서 데이터베이스에서 특정 테이블에 대한 클러스터링 인덱스를 가지고 있다면, 해당 테이블의 물리적인 데이터 저장 구조는 인덱스의 키 순서로 정렬됩니다. 이로 인해 특정 범위의 데이터에 대한 쿼리를 수행할 때 성능이 향상될 수 있습니다.
- 논클러스터링 인덱스: 논클러스터링 인덱스는 데이터의 논리적인 순서를 유지하지만, 물리적인 순서는 유지하지 않습니다. 이러한 인덱스는 테이블의 보조 인덱스로 생성되며, 프라이머리 키 이외의 열을 기반으로 합니다. 논클러스터링 인덱스를 사용하면 특정 열이나 열의 조합을 검색할 때 더 효율적인 성능을 제공할 수 있습니다.

</div>
</details>
<details>
<summary>Clustered Index와 Non-Clustered Index를 통해 데이터에 접근하는 과정에서의 차이를 설명해주세요.</summary>
<div markdown="1">

- Clustered Index에 대한 검색은 해당 인덱스 키를 통해 바로 레코드에 접근할 수 있습니다. 이는 Clustered Index가 테이블 데이터를 인덱스 키 순서에 따라 물리적으로 정렬하므로 가능한 것입니다. 즉, Clustered Index를 통해 데이터에 접근하는 것은 책의 목차를 통해 원하는 페이지에 바로 접근하는 것과 유사합니다. 따라서, 인덱스 키에 대한 검색 뿐만 아니라, 인덱스 키 범위에 대한 검색도 매우 효율적입니다.

- 반면에, Non-Clustered Index에 대한 검색은 두 단계를 거칩니다. 먼저, 인덱스 키를 통해 Non-Clustered Index를 검색하여 해당 레코드의 주소를 찾아내고, 그 다음 해당 주소를 통해 실제 레코드에 접근합니다. 이는 Non-Clustered Index가 인덱스 키와 레코드 주소를 매핑하는 별도의 자료구조를 유지하므로 필요한 과정입니다. 즉, Non-Clustered Index를 통해 데이터에 접근하는 것은 책의 찾아보기를 통해 특정 키워드의 페이지를 찾아내고, 그 페이지를 통해 실제 정보에 접근하는 것과 유사합니다. 따라서, 인덱스 키에 대한 검색은 효율적이지만, 인덱스 키 범위에 대한 검색은 Clustered Index에 비해 비효율적일 수 있습니다.

</div>
</details>
<details>
<summary>Index를 사용하는데 쓰이는 자료구조는 무엇인지 설명해주세요.</summary>
<div markdown="1">

- 가장 일반적으로 사용되는 자료구조는 B-Tree입니다.
- B-Tree는 가장 널리 사용되는 인덱스 자료구조입니다. B-Tree는 모든 리프 노드가 동일한 깊이를 가지며, 각 노드의 키는 정렬된 상태를 유지하는 특성을 가지고 있습니다. 이런 특성 덕분에 B-Tree는 데이터를 빠르게 찾아내고, 추가하거나 삭제하는 작업을 효율적으로 수행할 수 있습니다. 또한, B-Tree는 범위 검색이나 순차적인 접근에도 효과적입니다. MySQL에서 사용하는 InnoDB 스토리지 엔진은 B-Tree를 기본 인덱스 자료구조로 사용합니다.

</div>
</details>
<details>
<summary>왜 검색이 O(1)인 해시 자료구조가 아닌, B-tree를 사용하나요?</summary>
<div markdown="1">

- 해시 충돌: 서로 다른 키가 같은 해시 값을 가질 경우, 즉 해시 충돌이 발생하면 해당 해시 값에 여러 데이터가 매핑되어 검색 성능이 저하될 수 있습니다.
- 범위 검색의 한계: 해시 자료구조는 키의 해시 값에 따라 데이터를 저장하기 때문에, 특정 범위의 키를 가진 데이터를 검색하는 것이 비효율적입니다. 반면 B-Tree는 키를 기준으로 정렬된 상태를 유지하기 때문에 범위 검색에 더 효율적입니다.
- 순차 접근의 한계: 해시 자료구조는 데이터의 순서를 보장하지 않습니다. 이는 순차적인 데이터 접근이 필요한 경우, 예를 들어 ORDER BY 쿼리를 처리하는 경우에 비효율적입니다. 반면, B-Tree는 키의 순서를 유지하므로 이런 작업에 더 효율적입니다.

</div>
</details>
<details>
<summary>(A, B) 와 같은 방식으로 인덱스를 설정한 테이블에서, A 조건 없이 B 조건만 사용하여 쿼리를 요청했습니다. 해당 쿼리는 인덱스를 탈까요?</summary>
<div markdown="1">

- (A, B)와 같이 복합 인덱스가 설정된 경우, 인덱스의 첫 번째 필드인 A를 사용하지 않는 쿼리는 인덱스를 사용하지 않습니다.
- 복합 인덱스는 첫 번째 필드를 기준으로 정렬되며, 그 내부에서 두 번째 필드가 다시 정렬되는 구조를 가집니다. 따라서 첫 번째 필드를 사용하지 않는 쿼리는 이 정렬된 구조를 활용할 수 없어 인덱스를 사용하지 못하게 됩니다.
- 따라서, B 조건만 사용하는 쿼리를 자주 수행한다면, B에 대한 별도의 인덱스를 생성하거나, 인덱스의 순서를 변경하여 (B, A)와 같이 설정하는 것이 더 효율적일 수 있습니다.

</div>
</details>
<details>
<summary>항상 인덱스를 쓰면 성능이 좋아질까요?</summary>
<div markdown="1">

- 아닙니다.
- 인덱스 유지 비용: 인덱스는 데이터베이스에서 추가적인 공간을 차지하며 (보통 인덱스 하나당 데이터 저장 크기의 5~20% 가량의 저장공간을 사용), 데이터의 삽입, 업데이트, 삭제 작업 시에도 인덱스를 유지해야 합니다. 따라서 인덱스가 너무 많거나 업데이트가 빈번한 경우, 인덱스 유지 비용이 증가하여 전체적인 성능을 저하시킬 수 있습니다.
- 인덱스 선택 및 설계 오류: 적절한 인덱스 선택과 설계가 중요합니다. 잘못된 인덱스 설계는 쿼리 실행 계획을 방해하거나 인덱스를 효과적으로 활용하지 못하게 할 수 있습니다. 불필요한 인덱스, 중복된 인덱스, 인덱스의 순서 등의 오류를 피해야 합니다.
- 대규모 데이터에서는 오히려 Full Scan이 유리한 경우도 존재합니다.

</div>
</details>

<br>

# 📍 Reference
- https://github.com/VSFe/Tech-Interview/blob/main/04-DATABASE.md
- https://github.com/bombo-dev/CS-JAVA-Study/blob/main/Database/Index.mdㄴ