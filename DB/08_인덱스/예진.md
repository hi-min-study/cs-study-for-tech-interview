- 인덱스
    - 인덱스 개념
    - 인덱스 종류
    - Clustered index, Non-Clustered index
    - 인덱스 자료구조
    - 인덱스 고려사항

---

### 인덱스란 무엇인가요 ?

인덱스(index)는 추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블에 저장된 데이터의 검색 속도를 향상시키기 위한 자료구조이다.

### 인덱스의 장단점에 대해서 설명해주세요.

장점

- 검색 대상 레코드의 범위를 줄여 검색 속도를 빠르게 할 수 있다.
- 중복 데이터를 방지하거나 특정 컬럼의 유일성(Unique)을 보장할 수 있다.
- ORDER BY 절과 GROUP BY 절, WHERE 절 등이 사용되는 작업이 더욱 효율적으로 처리된다.

단점

- 인덱스 생성에 따른 추가적인 저장 공간이 필요하다. (인덱스 사용 시 해당 정보를 담은 MYI 파일 생성)
- CREATE(삽입), DELETE(삭제), UPDATE(수정) 작업 시에도 인덱스를 업데이트해야 하므로 성능 저하가 발생할 수 있다.
- 한 페이지를 동시에 수정할 수 있는 병행성이 줄어든다.
- 인덱스 생성 시간이 오래 걸릴 수 있다.

### 인덱스는 어떤 경우에 사용하나요 ?

- 대량의 데이터를 검색하는 경우
대량의 데이터를 검색해야 하는 경우에는 인덱스를 사용하여 검색 속도를 향상시킬 수 있다. 
대량의 데이터를 전체 스캔하는 것은 매우 느리고 부하가 발생하기 때문에 이 경우에 인덱스를 사용하여 검색하는 것이 효율적이다.
- 정렬된 결과를 출력하는 경우
인덱스를 사용하여 데이터를 정렬하면 매우 빠르게 정렬된 결과를 출력할 수 있다. 따라서 데이터를 정렬하는 경우에는 인덱스를 사용하는 것이 좋다.
- 조인 연산을 수행하는 경우
조인 연산을 수행하는 경우에는 인덱스를 사용하여 연산 속도를 향상시킬 수 있다. 
인덱스를 생성하여 조인 대상 테이블의 데이터를 빠르게 검색하는 것이 좋다.
- 유니크한 값을 가져오는 경우
인덱스는 유니크한 값을 가지고 있는 필드에 대해 중복되지 않는 값을 빠르게 검색할 수 있다. 
이러한 경우 인덱스를 사용하여 검색 속도를 빠르게 할 수 있다.
- 검색 빈도가 높은 경우
검색 빈도가 높은 필드에 대해서 인덱스를 생성하여 검색 속도를 향상시키는 것이 좋다.

### **다중 컬럼 인덱스가 안 걸리는 케이스에 대해서 설명해주세요.**

복수의 키에 대해서 order by를 사용한 경우

연속하지 않은 컬럼에 대해 order by를 실행한 경우

desc와 asc를 혼합하여 사용한 경우

group by와 order by의 컬럼이 다른 경우

order by 절에 다른 표현을 사용한 경우

### **distinct 와 group by의 차이점에 대해서 설명해주세요.**

Distinct는 중복된 결과를 제거하여 유일한 결과만 반환한다.

반면에 group by는 데이터를 그룹화하고 그룹화 된 결과를 반환한다.

일반적으로 집계 함수와 함께 사용되어 데이터를 합계, 평균, 최대값 또는 최소값 등으로 계산한다.

### 인덱스의 자료구조에 대해서 설명해주세요.

### Hash Table

- Key와 Value로 데이터를 저장하는 자료구조
- 빠른 데이터 검색이 필요할 때 유용
- 시간복잡도: O(1)
- Key값을 이용해 고유한 Index를 생성하여 그 Index에 저장된 값을 꺼내오는 구조
- 등호(=) 연산에만 특화되어 있기 때문에 부등호 연산(>, <)이 자주 사용되는 데이터베이스 검색을 위해서는 적절하지 않음
- key-value 기반의 DB인 Redis에는 적절

### B+ Tree

- DB의 인덱스를 위해 자식 노드가 2개 이상인 Binary Tree를 개선시킨 자료구조
- Leaf 노드(데이터 노드)만 인덱스와 함께 데이터(Value)를 가지고 있고, 나머지 노드(인덱스 노드)들은 데이터를 위한 인덱스(key)만을 가짐, Leaf 노드들은 LinkedList로 연결
- B+Tree의 리프노드들은 LinkedList로 연결하여 순차검색을 용이하게 하는 등 인덱스에 맞게 최적화

### RDBMS에서 자주쓰이는 자료구조는 무엇이고, 해당 자료구조가 왜 자주 사용되는지 설명해주세요.

**RDBMS에서는 B+ Tree를 사용한다.**

B-tree는 브랜치 노드에 key와 data를 담지만 **B+ tree는 key만 담아두고, 리프 노드에만 key와 data를 저장**한다. 리프 노드끼리는 linked list를 사용한다. 따라서 **메모리를 더 확보**함으로써 cache hit을 높일 수 있고, B+ Tree는 리프노드에 모든 데이터가 있으므로 **한 번의 선형 탐색**만 하면 된다.

### 인덱스의 종류에는 어떤것이 있나요?

Clustered index와 Non-Clustered index가 있습니다.

### Clustedred index에 대해서 설명해주세요

Clustered Index는 **테이블의 레코드를 지정된 컬럼에 대해 물리적으로 재배열**한다. Clustered Index는 **테이블 당 한 개**만 존재할 수 있고, **primary key 제약조건을 지정하는 컬럼**에 대해 자동으로 Clustered Index를 생성한다. 이렇기 때문에 우리가 일반적으로 테이블을 생성할 때 특정 컬럼에 primary key 제약조건을 지정했다면, 데이터가 자동으로 정렬되는 것이다.

Clustered Index를 생성한 컬럼을 기준으로 테이블의 데이터가 정렬되어 있기 때문에 **속도면에서 우수한 성능**을 보인다. 하지만 데이터의 추가/수정/삭제 시 매번 레코드를 정렬해야 하기 때문에 **추가/수정/삭제의 성능이 저하**된다.

### Non-clustered index에 대해서 설명해주세요.

Non-clustered Index는 **물리적으로 레코드를 정렬하지 않은 상태**로 **데이터 페이지가 구성**된다. 즉, 테이블의 레코드는 그대로두고 **지정된 컬럼에 대해 정렬된 인덱스**를 만든다. 물리적으로 레코드를 정렬하지 않기 때문에 **Clustered Index보다 속도면에서 성능이 떨어지지만, 추가/수정/삭제의 성능은 더 뛰어나다.**

Non-clustered Index는 **unique 제약 조건을 설정한 컬럼**에 대해 자동으로 Non-clustered Index를 생성한다. 따라서 **테이블 당 여러개 존재 가능**하다. 하지만 함부로 남용하면 오히려 시스템 성능이 저하될 수 있다.

### 카디널리티와 선택도에 대해서 설명해주세요.

카디널리티(Cardinality)는 특정 데이터 집합의 유니크(Unique)한 값의 개수이다.

선택도는 데이터 집합에서 특정 값을 얼마나 잘 골라낼 수 있는지에 대한 지표이다. 선택도가 1이라는 뜻은 모든 값이 유니크하다는 의미다.

선택도는 데이터베이스에서 인덱스를 생성할 컬럼을 고를 때 자주 사용한다. 선택도가 높은 컬럼에 인덱스를 걸면 인덱스가 특정 레코드를 잘 골라내어 인덱스 효율이 높아진다. 반대로 선택도가 낮은 컬럼에 인덱스를 걸게 되면 인덱스 효율이 낮아지게 되고, 결국 풀 테이블 스캔으로 플랜이 풀리게 될 수 있다.

### 여러컬럼을 인덱스로 생성할때 컬럼을 어떻게 구성하는게 좋을까요?

여러 컬럼을 인덱스로 생성할 경우, 카디널리티가 높은 순에서 낮은 순으로 구성하는 것이 좋다.   
예) CREATE INDEX인덱스명 ON테이블명(주민번호, 계좌번호, 학년, 성별); 
카디널리티가 높은 순으로 필터링하여 조회하기 때문이다.

### 인덱스의 선택도를 높이는 방법에 대해서 설명해주세요.

두 개 이상의 컬럼을 조합해서 인덱스를 걸어주면, 조합된 인덱스 키의 카디널리티가 증가하고 결국 선택도도 증가하여 효율이 좋은 인덱스가 된다. (대신 인덱스 키를 많이 사용하여 공간 효율이 낮아지게 된다.)

### 옵티마이저가 인덱스 스캔이 아닌 테이블 풀 스캔을 선택하는 경우는 언제인가요 ?

- 적용 가능한 인덱스가 없을 때
- 넓은 범위의 데이터 액세스
    - 적용 가능한 인덱스가 존재하더라도 처리 범위가 넓어 테이블 풀 스캔이 더 적은 비용이 든다면 테이블 풀 스캔을 적용할 수 있음
- 병렬처리 액세스
    - 병렬처리는 테이블 풀 스캔을 더욱 효과적으로 수행하기 때문에 병렬처리로 수행되는 실행 계획을 수립할 때는 항상 테이블 풀 스캔을 선택함
- 'FULL' 힌트를 적용했을 때
    - FULL 힌트가 적절하지 않다면 옵티마이저가 이를 무시할 수 있음


인덱스의 기본 개념 : https://ittrue.tistory.com/331

Clustered, Non-Clustered :  https://choiblack.tistory.com/53 

인덱스 - 카디널리티 : https://moonsiri.tistory.com/57

카디널리티와 선택도 : https://soft.plusblog.co.kr/87

데이터베이스 스캔 : https://choiblack.tistory.com/55 

테이블 풀 스캔 : https://hoon93.tistory.com/53

인덱스 면접 질문 리스트 : 
 https://kkoon9.tistory.com/509

https://land-turtler.tistory.com/120
