## 내용 정리
### Transaction

### 트랜잭션이란?

> 데이터베이스의 상태를 변화시키기 해서 수행하는 작업의 논리적 단위
>
>
> 작업단위는 많은 질의어 명령문들을 사람이 정하는 기준에 따라 정하는 것을 의미한다.
>

### ACID

원자성(Atomicity) : 트랜잭션의 연산은 모든 연산이 완벽히 수행되어야 하며, 한 연산이라도 실패하면 트랜잭션 내의 모든 연산은 실패해야 합니다.

Consistency(일관성):

일관성은 데이터베이스의 상태가 일관되어야 한다는 성질이다.

일관성은 하나의 트랜잭션 이전과 이후, 데이터베이스의 상태는 이전과 같이 유효해야 한다.

다시 말해, 트랜잭션이 일어난 이후의 데이터베이스는 데이터베이스의 제약이나 규칙을 만족해야 한다는 뜻이다.

**예를 들어 ‘모든 고객은 반드시 이름을 가지고 있어야 한다’는 데이터베이스의 제약이 있다고 가정한다.다음과 같은 트랜잭션은 Consistency(일관성)를 위반한다.
1. 이름 없는 새로운 고객을 추가하는 쿼리
2. 기존 고객의 이름을 삭제하는 쿼리데이터베이스의 유효한 상태는 다를수 있지만, 데이터의 상태에 대한 일관성은 변하지 않아야 한다.이 예시는 ‘이름이 있어야 한다’ 라는 제약을 위반한다.따라서 예시 트랜잭션이 일어난 이후의 데이터베이스는 일관되지 않는 상태를 가지게 된다.**

Isolation(독립성): 트랜잭션은 동시에 실행될 경우 어떤 하나의 트랜잭션이라도, 다른 트랜잭션의 연산에 끼어들 수 없다는 점을 가리킨다. 하나의 특정 트랜잭션이 완료될때까지, 다른 트랜잭션이 특정 트랜잭션의 결과를 참조할 수 없다.

Durability(내구성): 트랜잭션이 커밋된 이후에는 시스템 오류가 발생하더라도 커밋된 상태로 유지되는 것을 보장해야 합니다. (일반적으로 비휘발성 메모리에 데이터가 저장되는 것을 의미)

### Commit, Rollback

둘다 TCL이다.

- COMMIT : 올바르게 적용된 데이터를 데이터베이스에 반영시키는 것
- ROLLBACK : 작업 중 문제가 발생했을 때, 트랜잭션의 처리 과정에서 발생한 변경 사항을 취소하고, 트랜잭션 과정을 종료시킨다. 트랜잭션 시작 이전의 상태로 되돌리는 것
- SAVEPOINT : ROLLBACK할 때 현시점에서 SAVEPOINT까지 트랜잭션의 일부를 롤백할 수 있다.

### 트랜잭션 격리수준

# 트랜잭션 격리 수준(Transaction Isolation Level)

<aside>
💡 **격리 수준(isolation level)이란? : 트랜잭션끼리 얼마나 서로 고립되어 있는지를 나타내는 수준.**

</aside>

- 레벨이 높아질 수록 트랜잭션간 고립정도가 높아진다!
- 그에 따라 성능도 저하된다(트랜잭션 고립이 많이 일어날 수록, 나머지 트랜잭션은 대기상태에 놓여있어야 하기 때문일 듯).

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e442f0cb-4d44-4c85-a8fa-c37cc5af8db0/Untitled.png)

## 용어 설명

- Dirty Read : 아직 커밋되지 않은 다른 트랜잭션의 데이터를 읽는 것.
- Non-Repeatable Read : 다른 트랜잭션이 커밋(Commit)한 데이터를 읽을 수 있는 것.

  즉, 한 트랜잭션에서 같은 쿼리로 2번이상 조회했을 때 **그 결과가 상이한 상황**.

  보통 `데이터의 수정/삭제`가 발생했을 경우 발생합니다.

- Phantom Read : 한 트랜잭션 내에서 같은 쿼리를 두번 수행시, 첫 번째에는 없던 레코드(유령 레코드)가 두번째 쿼리에서 생기는 현상.

### 들어가기에 앞서

표의 처음부터 끝으로 갈 수록, 격리 수준(Isolation level)이 올라가며, 제약사항이 많아진다.

대신 데이터의 신뢰성이 높아진다.

## 격리 수준들

### Read Uncommited(Isolation Level 0)

어떤 트랜잭션의 내용이 **커밋(Commit)이나 롤백(Rollback)과 상관없이** 다른 트랜잭션에서 조회가 가능하다. 정합성(consistency)의 문제가 많은 격리 수준이기 때문에 RDBMS 표준에서는 격리수준으로 인정하지 않는다.

`Select문`이 실행되는 동안 해당 Data에 Shared Lock이 걸리지 않는다.

이런 이유로 `Dirty Read`가 발생한다.

### **Read Committed (Isolation Level 1)**

한 트랜잭션의 변경내용이 **커밋(Commit)되어야만** 다른 트랜잭션에서 조회가 가능하다. 대부분의 RDBMS에서 기본적으로 사용하는 격리수준.

`Select문`이 실행되는 동안 Shared Lock이 걸린다. 조회시에는 실제 테이블 값이 아니라 Undo 영역에 **백업된** 레코드 값을 가져옵니다.

하지만 하나의 트랜잭션에서 똑같은 SELECT 쿼리를 실행했을 때는 항상 같은 결과를 가져와야 하는 `REPEATABLE READ`의 정합성에 어긋난다. 즉, `Non-repeatable Read`이 발생한다.

### ⭐ **Repeatable Read (Isolation Level 2)**

트랜잭션이 시작되기 전에 커밋된 내용에 대해서만 조회가 가능하다. MySQL에서 기본으로 사용하며, 이 격리수준에서는 `Non-repeatable Read`이 발생하지 않는다.

트랜잭션이 완료될 때까지 Select문이 사용하는 모든 데이터에 Shared Lack이 걸린다. 따라서 트랜잭션이 범위 내에서 조회한 데이터의 내용이 항상 동일함을 보장한다.

트랜잭션이 시작 시점 데이터의 일관성을 보장해야 하기 때문에 트랜잭션의 실행시간이 길어질수록 계속 **멀티 버전을 관리**해야 하는 단점이 발생한니다.

하지만 `Phantom Read`가 발생할 수 있습니다.

### **Serializable (Isolation Level 3)**

가장 단순하면서 엄격한 격리 수준.

성능 측면에서는 동시 처리성능이 가장 낮다. `SERIALIZABLE`에서는 `PHANTOM READ`가 발생하지 않는다.

트랜잭션들이 동시에 일어나지 않고, 순차적으로 실행되는 것처럼 동작한다.

하지만, 성능상의 이유 때문에 거의 사용되지 않는다.

### DB Lock

**트랜잭션 처리의 순차성을 보장하기 위해 잠금을 거는 방법**

### 공유(Shared) Lock

**공유 Lock은 데이터를 읽을 때 사용되어지는 Lock**입니다. 이런 **공유 Lock은 공유 Lock 끼리는 동시에 접근이 가능**합니다. 즉, 하나의 데이터를 읽는 것은 여러 사용자가 동시에 할 수 있다라는 것입니다. 하지만 공유 Lock이 설정된 데이터에 베타 Lock을 사용할 수는 없습니다.

### 베타(Exclusive) Lock

**베타 Lock은 데이터를 변경하고자 할 때 사용**되며, 트랜잭션이 완료될 때까지 유지됩니다. **베타락은 Lock이 해제될 때까지 다른 트랜잭션(읽기 포함)은 해당 리소스에 접근할 수 없습니다.** 또한 해당 Lock은 다른 트랜잭션이 수행되고 있는 데이터에 대해서는 접근하여 함께 Lock을 설정할 수 없습니다.

## Lock의 설정 범위(Level)

Lock의 설정 범위(Level)에 대해서 알아보도록 하겠습니다.

- **데이터베이스**
    - 데이터베이스 범위의 lock은 전체 데이터베이스를 기준으로 lock 하는 것입니다. 즉, 1개의 세션만이 DB의 데이터에 접근이 가능합니다. 해당 기능은 일반적으로는 사용하지 않습니다. **사용하는 때가 있다면 DB의 소프트웨어 버전을 올린다던지 주요한 DB의 업데이트에 사용합니다.**
- 파일
    - 데이터베이스 파일을 기준으로 lock을 설정합니다. 파일 이란 테이블, row 등과 같은 실제 데이터가 쓰여지는 물리적인 저장소 입니다. 해당 범위의 Lock은 잘 사용되지는 않습니다.
- **테이블**
    - 테이블 수준의 Lock은 테이블을 기준으로 Lock을 설정합니다. 이는 테이블의 모든 행을 업데이트 하는 등의 전체 테이블에 영향을 주는 변경을 수행할 때 유용합니다. 즉, **DDL(create, alter, drop 등) 구문과 함께 사용되며 DDL Lock이라고도 합니다.**
- 페이지와 블럭
    - **파일의 일부인 페이지와 블록을 기준으로 Lock을 설정**합니다. 잘 사용되지는 않습니다.
- 컬럼
    - 컬럼 기준의 Lock은 컬럼을 기준으로 Lock을 설정할 수 있습니다. 하지만 이 형식은 Lock 설정 및 해제의 리소스가 많이 들기 때문에 일반적으로 사용되지는 않습니다. 지원하는 DBMS도 많지 않습니다.
- **행(Row)**
    - **행 수준의 Lock은 1개의 행(Row)를 기준으로 Lock 설정을 합니다. DML에 대한 Lock으로 가장 일반적으로 사용하는 Lock입니다.**

### **Lock에서 발생할 수 있는 문제**

### **1. 블로킹(blocking)**

보통 DB 작업을 수행할 때 데이터의 무결성과 정합성을 보장하기 위해 트랜잭션을 사용합니다.

따라서 Lock도 하나의 트랜잭션 안에서 걸리고, 해제되게 됩니다.

블로킹은 **Lock 간의 경합이 발생해서 특정 트랜잭션이 작업을 진행하지 못하고 대기하는 상태**를 의미합니다.

위의 공유 Lock, 배타 Lock 설명에서 블로킹 상태를 다음과 같이 언급했었습니다.

- 특정 데이터에 공유 Lock이 설정된 상태에서 해당 데이터에 배타 Lock을 설정하려고 할 때
- 특정 데이터에 배타 Lock이 설정된 상태에서 해당 데이터에 공유 Lock을 설정하려고 할 때
- 특정 데이터에 배타 Lock이 설정된 상태에서 해당 데이터에 공유 Lock을 설정하려고 할 때

블로킹 상태의 이후에 Lock을 설정하는 트랜잭션의 작업이 정상적으로 수행되기 위해서는

Lock의 Timeout 시간 이전에 기존 Lock을 설정한 트랜잭션이 commit되거나 rollback 되는 방법밖에 없습니다.

!https://blog.kakaocdn.net/dn/Dl2BG/btrOQfhZf7N/33FStQ78uxpcHh82eWl5ek/img.png

**트랜잭션A가 먼저 데이터 YKH에 업데이트를 하며 배타락을 걸었다. 그 뒤에 트랜잭션 B가 YKH 데이터를 읽어서, 배타락과 공유락이 경합하게 되었다. 그래서 트랜잭션B의 작동이 멈춰선 Blocking 상태가 발생했다. Blocking 상태를 해결하려면 먼저 시작된 트랜잭션A가 완료(Commit)되어야 한다.**

### 블로킹 해결

> 트랜잭션 작업 단위를 최대한 적게 구성하기
>
- 트랜잭션의 작업 단위를 적게 구성하면 그만큼 빠르게 트랜잭션이 종료되기 때문에 블로킹 상태 해결이 빠를 것입니다.
- JPA 사용 시 생명주기가 다른 객체간의 직접 참조를 간접 참조로 끊는 방법도 트랜잭션 작업 단위를 적게 구성하여 블로킹 상태를 빠르게 해결하는 예시로 들 수 있을 것 같습니다.

> 동일한 데이터를 동시에 변경하는 작업을 하지 않도록 설계하기
>
- 이런 부분은 동시성을 해결하는 비관적 락, 낙관적 락을 사용하여 해결할 수 있을 것 같습니다.

> 트랜잭션이 활발한 주간에는 대용량 데이터 작업 수행을 지양하기
>
- 서비스의 피크 타임에 서버의 스케쥴링을 수행하면 블로킹 상태가 길어져 사용자의 불편을 초래할 수 있을 것 같습니다.
- 만약 피크 타임에 어쩔 수 없이 대용량 데이터 작업을 수행해야 한다면, 작업 단위를 쪼개서 실행하는 것이 좋을 것 같습니다.

### **2. 교착상태(DeadLock)**

**데드락은 두 트랜잭션이 각자 다른 데이터에 배타락을 설정해둔 후에, 서로 상대방의 데이터에 락을 설정하려고 할 때 발생한다. 두 트랜잭션 모두 동작이 멈추었기 때문에, 두 트랜잭션 영원히 멈춘 상태를 교착 상태 데드락이라고 한다. 예시를 통해서 데드락 발생을 알아보자.**

!https://blog.kakaocdn.net/dn/bODwRo/btrOQfbd3kc/WWOpxl8EXwkwl0TV7d3IBK/img.png

**트랜잭션 A는 game_master 2번 데이터에 배타락을 걸었다. 그 때 트랜잭션 B는 gmae_detail 2번 데이터에 배타락을 설정했다. 그 이후 트랜잭션 A는 game_detail 2번 데이터에 접근하기 위해 락을 걸어서 멈춰버렸고, 트랜잭셔 B는 game_master 2번 데이터에 접근하기 위해 락을 걸어서 멈춰버렸다. 두 트랜잭션 모두 완료(Commit)할 수 없어서, 두 트랜잭션이 영원히 멈춘 교착 상태에 빠지데 된다.(블로킹 에서는 다른 먼저 시작된 트랜잭션이 완료되면, 블로킹이 해제된다.)**

**교착상태 발생을 줄이려면, 데이터 접근 순서를 세우는 것이 중요하다. 위 예제라면, game_master를 업데이트 한 후 game_detail을 업데이트 한다와 같은 규칙을 정해 테이블 접근의 교차가 일어나지 않도록 하는 것이다.**

### 데드락 해결 방법

DB(데이버베이스)에서 교착상태(Dead Lock)을 해결하기 위한 방법은 아래와 같다.

- 예방 기법
- 회피 기법
- 낙관적 병행 제어 기법
- 빈도 줄이기 기법

### 예방 기법

대표적인 예방 기법은 아래와 같다.

- 각 트랜잭션이 실행되기 전에 필요한 모든 자원을 Lock(잠금)한다.
    - 필요한 모든 데이터를 Lock(잠금)해야 하므로 병행성이 떨어진다.
- SET LOCK_TIMEOUT문을 통해 일정 시간이 지나면 쿼리를 취소한다.
    - 기존의 교착상태인 데이터가 있다면, 그 데이터에 접근하는 쿼리만 취소한다.
    - 즉, 근본적인 해결책이 될 수 없다.

### 회피 기법

**회피 기법은 자원을 할당할 때 시간 스탬프(Time Stamp)를 활용해서 교착상태가 일어나지 않도록 회피하는 방법**이다. 예방 기법의 단점 때문에 실제로는 회피 기법이 많이 사용된다.

회피 기법의 종류는 크게 2가지가 있다.

- Wait-Die 방식
    - 트랜잭션 A가 트랜잭션 B에 의해 잠금된 데이터를 요청할 때 트랜잭션 A이 먼저 들어온 트랜잭션이라면 대기(Wait)한다.
    - 트랜잭션 A가 나중에 들어온 트랜잭션이라면, 포기(Die)하고 나중에 다시 요청한다.
- Wound-Wait 방식
    - 트랜잭션 A가 트랜잭션 B보다 먼저 들어온 트랜잭션이라면, 데이터를 선점(Wound)한다.
    - 반면, 트랜잭션A가 트랜잭션 B보다 나중에 들어온 트랜잭션이라면 대기(Wait)한다.

### 낙관적 병행 제어 기법

낙관적 병행 제어 기법은 트랜잭션이 실행되는 동안에는 검사를 수행하지 않고, 트랜잭션이 커밋된 후에 데이터에 문제가 있다면 롤백(Rollback)하는 방법이다.

즉, 낙관적 병행 제어 기법은 **판독->확인->기록** 단계를 따른다. **확인 단계**를 성공적으로 거친 트랜잭션만  **기록 단계**를 수행할 수 있다.

### 빈도 줄이기

교착상태의 빈도를 낮추는 방법은 아래와 같다.

- 트랜잭션을 자주 커밋한다.
- 정해진 순서로 테이블에 접근한다. (위에서는 트랜잭션 1은 B->A 순, 트랜잭션 2는 A->B순으로 접근했다.)
- 읽기 잠금 (SELECT ~ FOR UPDATE)의 사용을 피한다.
- 테이블 단위의 Lock(잠금)을 획득해 갱신을 직렬화한다. (테이블의 복수행을 복수의 연결에서 순서 없이 갱신하면 교착상태가 자주 발생하기 때문)
- Index 설계 (Update시 Index를 타지 않으면 테이블 전체에 Lock이 걸릴 수 있다.)
- Isolation level(고립 수준)을 낮춘다. (서비스 검토 필요)

### MySQL Lock

**MySql에서는 공유락과 배타락을 사용한다. 또한 Lock 레벨로는 행 단위의 레코드 락을 사용한다.**

### **Record Lock**

**primary key 또는 unique index (multi-column unique index 포함)로 조회해서 하나의 인덱스 레코드(=row=행)에만 lock을 거는 것을 의미한다.**

**예) SELECT id FROM t WHERE id = 10 LOCK IN SHARE MODE**

**위 쿼리를 실행하면 id=10 인 레코드에 대해 공유락이 걸린다.**

**예) SELECT id FROM t WHERE id = 10 FOR UPDATE**

**위 쿼리를 실행하면 id=10 인 레코드에 대해 배타락이 걸린다.**

### **MySql Repeatable Read 격리 수준과 Lock**

**MySql의 격리 수준은 REPEATABLE READ 레벨이다. REPEATABLE READ 레벨에서는 한 트랜잭션안에 여러 업데이트 가 발생하면, 해당 트랜잭션이 완료 되었을 때, 업데이트에 사용한 여러 배타락을 한번에 해제한다.**

**한 단계 낮은 READ COMMITTED 레벨에서는 트랜잭션 내에 한 row가 update 되고 다음 row로 넘어갈 때 update된 row의 배타락을 풀어준다.**

### **MySql 데드락 처리**

**MysSql의 엔진인 InnoDB는 데드락 감지 기능을 가지고 있다. 그래서 데드락이 감지되면, 2개의 트랜잭션 중 데이터 변화가 적은 것을 rollback시켜서 데드락을 해소한다. 하지만, 데드락 감지 기능은 속도 저하의 원인이 될 수 있다. 그래서 MySql은 innodb_lock_wait_timeout을 사용하는 것을 권장한다.innodb_lock_wait_timeout은 row lock을 걸고 특정 시간 이상 걸리면 자동으로 lock을 해제 하는 매커니즘이다.**

### 트랜잭션 전파옵션

트랜잭션에 속해있는 메소드 안에서, @Transactional이 붙은 다른 메소드를 호출했을 때

어떻게 처리할지 정해준다. 옵션은 다음과 같다.

- REQUIRED (default)
    - 실행중인 트랜잭션이 존재한다면 실행중인 트랜잭션으로 합류한다.
    - 실행중인 트랜잭션이 없다면 새로운 트랜잭션을 생성한다.
- REQUIRES_NEW
    - 실행중인 트랜잭션이 있다면, 중단하고 새 트랜잭션을 만든다.
- MANDATORY
    - 실행중인 트랜잭션이 있다면, 그것을 사용하고 없다면 예외를 던진다.
- NESTED
    - 실행중인 트랜잭션이 있다면, save point를 남긴다.
        - 이후에 예외가 생긴다면, 해당 save point로 롤백한다.
    - 실행중인 트랜잭션이 없다면, REQUIRED와 같이 동작한다.
- NEVER
    - 트랜잭션을 생성하지 않는다. 실행중인 트랜잭션이 있다면, 예외를 던진다.
- SUPPORTS
    - 실행중인 트랜잭션이 있다면, 그것을 사용하고, 없으면 트랜잭션을 사용하지 않는다.
- NOT_SUPPORTED
    - 실행중인 트랜잭션이 있다면, 그것을 중단한 이후에 트랜잭션이 없이 로직을 수행한다.

### ref

- commit, rollback : [https://siloam72761.tistory.com/entry/DB-트랜잭션의-개념-4가지-특성-COMMIT-ROLLBACK](https://siloam72761.tistory.com/entry/DB-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EC%9D%98-%EA%B0%9C%EB%85%90-4%EA%B0%80%EC%A7%80-%ED%8A%B9%EC%84%B1-COMMIT-ROLLBACK)
- Lock : [https://coding-business.tistory.com/32#lock의-종류](https://coding-business.tistory.com/32#lock%EC%9D%98-%EC%A2%85%EB%A5%98)
- 데드락 해결 : https://jaehoney.tistory.com/162
- [https://ksh-coding.tistory.com/121#2. 블로킹 (Blocking)-1](https://ksh-coding.tistory.com/121#2.%20%EB%B8%94%EB%A1%9C%ED%82%B9%20(Blocking)-1)

## 질문 정리
### 트랜잭션이란 무엇인지 설명해 주시고, ACID에 대해서도 설명해 주세요.

트랜잭션이란, 데이터베이스의 상태를 변화시키기 해서 수행하는 작업의 논리적 단위이며,

작업단위는 많은 질의어 명령문들을 사람이 정하는 기준에 따라 정하는 것을 의미합니다.

Atomicity(원자성) : 트랜잭션의 연산은 모든 연산이 완벽히 수행되어야 하며, 한 연산이라도 실패하면 트랜잭션 내의 모든 연산은 실패해야 합니다.

Consistency(일관성):

일관성은 데이터베이스의 상태가 일관되어야 한다는 성질이다.

일관성은 하나의 트랜잭션 이전과 이후, 데이터베이스의 상태는 이전과 같이 유효해야 한다.

다시 말해, 트랜잭션이 일어난 이후의 데이터베이스는 데이터베이스의 제약이나 규칙을 만족해야 한다는 뜻이다.

Isolation(독립성): 트랜잭션은 동시에 실행될 경우 어떤 하나의 트랜잭션이라도, 다른 트랜잭션의 연산에 끼어들 수 없다는 점을 가리킨다. 하나의 특정 트랜잭션이 완료될때까지, 다른 트랜잭션이 특정 트랜잭션의 결과를 참조할 수 없다.

Durability(내구성): 트랜잭션이 커밋된 이후에는 시스템 오류가 발생하더라도 커밋된 상태로 유지되는 것을 보장해야 합니다. (일반적으로 비휘발성 메모리에 데이터가 저장되는 것을 의미)

### 트랜잭션 커밋과 롤백에 대해 설명해 주세요.

- COMMIT : 올바르게 적용된 데이터를 데이터베이스에 반영시키는 것
- ROLLBACK : 작업 중 문제가 발생했을 때, 트랜잭션의 처리 과정에서 발생한 변경 사항을 취소하고, 트랜잭션 과정을 종료시킨다. 트랜잭션 시작 이전의 상태로 되돌리는 것

### 트랜잭션 격리 수준 4가지에 대해 설명해 주세요.

### Read Uncommited(Isolation Level 0)

어떤 트랜잭션의 내용이 **커밋(Commit)이나 롤백(Rollback)과 상관없이** 다른 트랜잭션에서 조회가 가능하다. 정합성(consistency)의 문제가 많은 격리 수준이기 때문에 RDBMS 표준에서는 격리수준으로 인정하지 않는다.

`Select문`이 실행되는 동안 해당 Data에 Shared Lock이 걸리지 않는다.

이런 이유로 `Dirty Read`가 발생한다.

### **Read Committed (Isolation Level 1)**

한 트랜잭션의 변경내용이 **커밋(Commit)되어야만** 다른 트랜잭션에서 조회가 가능하다. 대부분의 RDBMS에서 기본적으로 사용하는 격리수준.

`Select문`이 실행되는 동안 Shared Lock이 걸린다. 조회시에는 실제 테이블 값이 아니라 Undo 영역에 **백업된** 레코드 값을 가져옵니다.

하지만 하나의 트랜잭션에서 똑같은 SELECT 쿼리를 실행했을 때는 항상 같은 결과를 가져와야 하는 `REPEATABLE READ`의 정합성에 어긋난다. 즉, `Non-repeatable Read`이 발생한다.

### ⭐ **Repeatable Read (Isolation Level 2)**

트랜잭션이 시작되기 전에 커밋된 내용에 대해서만 조회가 가능하다. MySQL에서 기본으로 사용하며, 이 격리수준에서는 `Non-repeatable Read`이 발생하지 않는다.

트랜잭션이 완료될 때까지 Select문이 사용하는 모든 데이터에 Shared Lack이 걸린다. 따라서 트랜잭션이 범위 내에서 조회한 데이터의 내용이 항상 동일함을 보장한다.

트랜잭션이 시작 시점 데이터의 일관성을 보장해야 하기 때문에 트랜잭션의 실행시간이 길어질수록 계속 **멀티 버전을 관리**해야 하는 단점이 발생한니다.

하지만 `Phantom Read`가 발생할 수 있습니다.

### **Serializable (Isolation Level 3)**

가장 단순하면서 엄격한 격리 수준.

성능 측면에서는 동시 처리성능이 가장 낮다. `SERIALIZABLE`에서는 `PHANTOM READ`가 발생하지 않는다.

트랜잭션들이 동시에 일어나지 않고, 순차적으로 실행되는 것처럼 동작한다.

하지만, 성능상의 이유 때문에 거의 사용되지 않는다.

### 데이터베이스 Lock이란 무엇인지, 그중 공유락과 배타락에 대해서도 설명해 주세요.

**트랜잭션 처리의 순차성을 보장하기 위해 잠금을 거는 방법**

### 공유(Shared) Lock

**공유 Lock은 데이터를 읽을 때 사용되어지는 Lock**입니다. 이런 **공유 Lock은 공유 Lock 끼리는 동시에 접근이 가능**합니다. 즉, 하나의 데이터를 읽는 것은 여러 사용자가 동시에 할 수 있다라는 것입니다. 하지만 공유 Lock이 설정된 데이터에 베타 Lock을 사용할 수는 없습니다.

### 베타(Exclusive) Lock

**베타 Lock은 데이터를 변경하고자 할 때 사용**되며, 트랜잭션이 완료될 때까지 유지됩니다. **베타락은 Lock이 해제될 때까지 다른 트랜잭션(읽기 포함)은 해당 리소스에 접근할 수 없습니다.** 또한 해당 Lock은 다른 트랜잭션이 수행되고 있는 데이터에 대해서는 접근하여 함께 Lock을 설정할 수 없습니다.

### Lock으로 인해 생기는 문제점 중 블로킹에 대해 설명해 주시고, 블로킹의 해결방법에 대해서 설명해 주세요.

보통 DB 작업을 수행할 때 데이터의 무결성과 정합성을 보장하기 위해 트랜잭션을 사용합니다.

따라서 Lock도 하나의 트랜잭션 안에서 걸리고, 해제되게 됩니다.

블로킹은 **Lock 간의 경합이 발생해서 특정 트랜잭션이 작업을 진행하지 못하고 대기하는 상태**를 의미합니다.

위의 공유 Lock, 배타 Lock 설명에서 블로킹 상태를 다음과 같이 언급했었습니다.

- 특정 데이터에 공유 Lock이 설정된 상태에서 해당 데이터에 배타 Lock을 설정하려고 할 때
- 특정 데이터에 배타 Lock이 설정된 상태에서 해당 데이터에 공유 Lock을 설정하려고 할 때
- 특정 데이터에 배타 Lock이 설정된 상태에서 해당 데이터에 공유 Lock을 설정하려고 할 때

블로킹 상태의 이후에 Lock을 설정하는 트랜잭션의 작업이 정상적으로 수행되기 위해서는

Lock의 Timeout 시간 이전에 기존 Lock을 설정한 트랜잭션이 commit되거나 rollback 되는 방법밖에 없습니다.

### 블로킹 해결 방법

> 트랜잭션 작업 단위를 최대한 적게 구성하기
>
- 트랜잭션의 작업 단위를 적게 구성하면 그만큼 빠르게 트랜잭션이 종료되기 때문에 블로킹 상태 해결이 빠를 것입니다.
- JPA 사용 시 생명주기가 다른 객체간의 직접 참조를 간접 참조로 끊는 방법도 트랜잭션 작업 단위를 적게 구성하여 블로킹 상태를 빠르게 해결하는 예시로 들 수 있을 것 같습니다.

> 동일한 데이터를 동시에 변경하는 작업을 하지 않도록 설계하기
>
- 이런 부분은 동시성을 해결하는 비관적 락, 낙관적 락을 사용하여 해결할 수 있을 것 같습니다.

> 트랜잭션이 활발한 주간에는 대용량 데이터 작업 수행을 지양하기
>
- 서비스의 피크 타임에 서버의 스케쥴링을 수행하면 블로킹 상태가 길어져 사용자의 불편을 초래할 수 있을 것 같습니다.
- 만약 피크 타임에 어쩔 수 없이 대용량 데이터 작업을 수행해야 한다면, 작업 단위를 쪼개서 실행하는 것이 좋을 것 같습니다.

### Lock으로 인해 생기는 문제점 중 데드락에 대해 설명해 주시고, 데드락의 해결방법에 대해서 설명해 주세요.

**데드락은 두 트랜잭션이 각자 다른 데이터에 배타락을 설정해둔 후에, 서로 상대방의 데이터에 락을 설정하려고 할 때 발생한다. 두 트랜잭션 모두 동작이 멈추었기 때문에, 두 트랜잭션 영원히 멈춘 상태를 교착 상태 데드락이라고 한다.**

### 예방 기법

대표적인 예방 기법은 아래와 같다.

- 각 트랜잭션이 실행되기 전에 필요한 모든 자원을 Lock(잠금)한다.
    - 필요한 모든 데이터를 Lock(잠금)해야 하므로 병행성이 떨어진다.
- SET LOCK_TIMEOUT문을 통해 일정 시간이 지나면 쿼리를 취소한다.
    - 기존의 교착상태인 데이터가 있다면, 그 데이터에 접근하는 쿼리만 취소한다.
    - 즉, 근본적인 해결책이 될 수 없다.

### 회피 기법

**회피 기법은 자원을 할당할 때 시간 스탬프(Time Stamp)를 활용해서 교착상태가 일어나지 않도록 회피하는 방법**이다. 예방 기법의 단점 때문에 실제로는 회피 기법이 많이 사용된다.

회피 기법의 종류는 크게 2가지가 있다.

- Wait-Die 방식
    - 트랜잭션 A가 트랜잭션 B에 의해 잠금된 데이터를 요청할 때 트랜잭션 A이 먼저 들어온 트랜잭션이라면 대기(Wait)한다.
    - 트랜잭션 A가 나중에 들어온 트랜잭션이라면, 포기(Die)하고 나중에 다시 요청한다.
- Wound-Wait 방식
    - 트랜잭션 A가 트랜잭션 B보다 먼저 들어온 트랜잭션이라면, 데이터를 선점(Wound)한다.
    - 반면, 트랜잭션A가 트랜잭션 B보다 나중에 들어온 트랜잭션이라면 대기(Wait)한다.

### 낙관적 병행 제어 기법

낙관적 병행 제어 기법은 트랜잭션이 실행되는 동안에는 검사를 수행하지 않고, 트랜잭션이 커밋된 후에 데이터에 문제가 있다면 롤백(Rollback)하는 방법이다.

즉, 낙관적 병행 제어 기법은 **판독->확인->기록** 단계를 따른다. **확인 단계**를 성공적으로 거친 트랜잭션만  **기록 단계**를 수행할 수 있다.

### 빈도 줄이기

교착상태의 빈도를 낮추는 방법은 아래와 같다.

- 트랜잭션을 자주 커밋한다.
- 정해진 순서로 테이블에 접근한다. (위에서는 트랜잭션 1은 B->A 순, 트랜잭션 2는 A->B순으로 접근했다.)
- 읽기 잠금 (SELECT ~ FOR UPDATE)의 사용을 피한다.
- 테이블 단위의 Lock(잠금)을 획득해 갱신을 직렬화한다. (테이블의 복수행을 복수의 연결에서 순서 없이 갱신하면 교착상태가 자주 발생하기 때문)
- Index 설계 (Update시 Index를 타지 않으면 테이블 전체에 Lock이 걸릴 수 있다.)
- Isolation level(고립 수준)을 낮춘다. (서비스 검토 필요)

### 트랜잭션 전파 옵션의 종류들에 대해서 설명해 주세요.

- REQUIRED (default)
    - 실행중인 트랜잭션이 존재한다면 실행중인 트랜잭션으로 합류한다.
    - 실행중인 트랜잭션이 없다면 새로운 트랜잭션을 생성한다.
- REQUIRES_NEW
    - 실행중인 트랜잭션이 있다면, 중단하고 새 트랜잭션을 만든다.
- MANDATORY
    - 실행중인 트랜잭션이 있다면, 그것을 사용하고 없다면 예외를 던진다.
- NESTED
    - 실행중인 트랜잭션이 있다면, save point를 남긴다.
        - 이후에 예외가 생긴다면, 해당 save point로 롤백한다.
    - 실행중인 트랜잭션이 없다면, REQUIRED와 같이 동작한다.
- NEVER
    - 트랜잭션을 생성하지 않는다. 실행중인 트랜잭션이 있다면, 예외를 던진다.
- SUPPORTS
    - 실행중인 트랜잭션이 있다면, 그것을 사용하고, 없으면 트랜잭션을 사용하지 않는다.
- NOT_SUPPORTED
    - 실행중인 트랜잭션이 있다면, 그것을 중단한 이후에 트랜잭션이 없이 로직을 수행한다.

### 프로젝트에서 트랜잭션 전파 옵션은 무엇을 사용해 보셨나요? 왜 그것을 사용하셨나요?

- REQUIRED
    - REQUIRED는 트랜잭션의 기본 옵션으로써 하나의 트랜잭션의 ACID를 보장하기 위해서 해당 옵션을 사용하였습니다.
- REQUIRES_NEW
    - 비동기 이벤트를 발행하여, 자식 트랜잭션의 성공 여부와 관계 없이 부모 트랜잭션을 성공적으로 커밋시키기 위해 REQUIRES_NEW옵션을 이용하여 새로운 트랜잭션을 열어 주었습니다.
