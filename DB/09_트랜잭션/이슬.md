# 📍 키워드
- 트랜잭션
    - 트랜잭션 개념
    - ACID
    - Commit, Rollback
    - 트랜잭션 격리수준
    - LOCK, 교착상태, 동시성
    - 트랜잭션 전파옵션

<br>

# 📍 예상 질문
<details>
<summary>트랜잭션이란 무엇인가요? 그리고 왜 중요한가요?</summary>
<div markdown="1">

- 트랜잭션은 데이터베이스에서 일련의 연산을 수행하는 단위를 말합니다. 이 일련의 연산은 모두 성공하거나, 아니면 모두 실패해야 합니다. 이런 특성을 '원자성'이라고 부르죠.
- 트랜잭션은 데이터의 일관성을 보장하는 매우 중요한 역할을 합니다. 예를 들어, 은행에서 두 계좌 간의 이체를 생각해보면, 한 계좌에서 돈을 빼고 다른 계좌에 돈을 넣는 두 개의 연산이 하나의 트랜잭션을 이룹니다. 만약 이 두 연산 중 하나라도 실패하면, 돈이 사라지거나 두 번 증가하는 등의 문제가 발생할 수 있습니다. 따라서 트랜잭션을 통해 이런 연산들이 모두 성공하거나 모두 실패하도록 보장해야 합니다.
- 또한, 트랜잭션은 여러 사용자나 애플리케이션이 동시에 같은 데이터에 접근할 때 발생할 수 있는 문제를 해결하는 데도 중요한 역할을 합니다. 이를 '동시성 제어'라고 부르며, 이를 통해 데이터의 무결성을 보장합니다.
- 따라서 트랜잭션은 데이터의 일관성과 무결성을 보장하며, 여러 사용자나 애플리케이션간의 동시 접근 문제를 해결하는데 중요한 역할을 합니다.

</div>
</details>
<details>
<summary>ACID 속성에 대해 설명해주세요.</summary>
<div markdown="1">

- 트랜잭션이 제대로 수행되기 위해 지켜야 하는 4가지 속성이 있는데, 그것이 바로 ACID입니다. ACID는 Atomicity(원자성), Consistency(일관성), Isolation(독립성), Durability(영속성)의 약자입니다.
1. Atomicity(원자성): 트랜잭션의 모든 연산은 한꺼번에 수행되거나 전혀 수행되지 않아야 한다는 것을 의미합니다. 즉, 트랜잭션 내의 연산들이 부분적으로 실행되는 것을 허용하지 않습니다.
2. Consistency(일관성): 트랜잭션의 수행이 데이터의 일관성을 보장해야 한다는 것을 의미합니다. 즉, 트랜잭션이 성공적으로 완료되면 항상 일관성 있는 상태로 유지되어야 합니다.
3. Isolation(독립성): 동시에 실행되는 트랜잭션들이 서로 영향을 미치지 않도록 보장해야 한다는 것을 의미합니다. 즉, 하나의 트랜잭션 실행이 완료될 때까지 다른 트랜잭션에서는 그 결과를 볼 수 없습니다.
4. Durability(영속성): 트랜잭션이 성공적으로 완료되면 그 결과는 영구적으로 반영되어야 한다는 것을 의미합니다. 즉, 시스템이 실패하더라도 완료된 트랜잭션의 결과는 그대로 유지되어야 합니다.
- 이 4가지 속성을 통해 트랜잭션은 데이터의 정확성과 안정성을 보장하며, 데이터베이스 시스템의 핵심 기능을 수행합니다.

</div>
</details>
<details>
<summary>ACID 원칙 중, Durability를 DBMS는 어떻게 보장하나요?</summary>
<div markdown="1">

- Durability, 즉 영속성은 한번 수행된 트랜잭션의 결과가 영구적으로 반영되어야 한다는 원칙입니다. 이 원칙은 DBMS에서 주로 로그 기반의 복구 기법과 디스크에 데이터를 안전하게 저장하는 방법을 통해 보장됩니다.
- 먼저, DBMS에서는 트랜잭션의 모든 변경사항을 로그 형태로 저장합니다. 이 로그에는 어떤 데이터가 어떻게 변경되었는지에 대한 정보가 담겨 있습니다. 그래서 시스템이 실패했을 때 이 로그를 사용해 마지막으로 커밋된 트랜잭션 상태로 데이터를 복구할 수 있습니다.
- 또한, 트랜잭션이 성공적으로 커밋되면 그 결과는 디스크와 같은 비휘발성 저장소에 즉시 기록됩니다. 이렇게 하면 시스템이 다운되거나 전원이 꺼져도 데이터는 안전하게 보호됩니다.
- 이 두 가지 방법을 통해 DBMS는 트랜잭션의 영속성을 보장합니다. 따라서 사용자는 데이터가 안전하게 보호되고 있음을 확신하고, 트랜잭션을 활용할 수 있습니다.

</div>
</details>
<details>
<summary>Commit과 Rollback에 대해 설명해주세요.</summary>
<div markdown="1">

- Commit과 Rollback은 트랜잭션의 실행 결과를 확정짓거나 취소하는 데 사용되는 연산입니다.
1. Commit: 트랜잭션의 모든 변경사항을 데이터베이스에 영구적으로 적용하는 연산을 말합니다. 트랜잭션이 성공적으로 완료되면 커밋을 통해 모든 변경사항이 데이터베이스에 반영되고, 이러한 상태는 영속적으로 유지됩니다. 즉, 커밋이 실행되면 트랜잭션의 결과는 데이터베이스에 안전하게 저장되며, 이후에 시스템이 실패하더라도 복구 가능합니다.
2. Rollback: 트랜잭션의 모든 변경사항을 취소하고 트랜잭션 실행 이전의 상태로 되돌리는 연산을 말합니다. 트랜잭션 실행 중에 오류가 발생하거나 사용자의 요청에 의해 트랜잭션을 중단해야 할 때, 롤백을 통해 데이터베이스를 트랜잭션 실행 이전의 상태로 복원합니다. 즉, 롤백이 실행되면 트랜잭션이 마치 실행되지 않은 것처럼 데이터베이스가 원래의 상태로 돌아갑니다.
- 이 두 연산은 트랜잭션의 원자성을 보장하는데 핵심적인 역할을 합니다. 트랜잭션의 모든 연산이 성공적으로 완료되면 커밋을 실행하고, 그렇지 않으면 롤백을 실행함으로써 트랜잭션의 모든 연산은 한꺼번에 수행되거나 전혀 수행되지 않는 원자성을 보장합니다.

</div>
</details>
<details>
<summary>트랜잭션의 격리 수준이란 무엇이고, 왜 필요한가요? 각 격리 수준에 대해 설명해주세요.</summary>
<div markdown="1">

- 트랜잭션의 격리 수준(Isolation Level)은 동시에 여러 트랜잭션이 실행될 때 트랜잭션들이 서로 얼마나 고립되어야 하는지를 정의하는 것을 말합니다. 이는 동시성 제어를 위한 중요한 개념으로, 격리 수준에 따라 발생할 수 있는 문제와 성능 간의 트레이드오프를 관리합니다.
- SQL 표준에서는 4가지 격리 수준을 정의하고 있습니다.
1. Read Uncommitted: 가장 낮은 수준의 격리를 제공합니다. 트랜잭션에서 변경 중인 데이터를 다른 트랜잭션에서 읽을 수 있습니다. 이 수준에서는 Dirty Read, Non-Repeatable Read, Phantom Read가 모두 발생할 수 있습니다.
2. Read Committed: 대부분의 DBMS에서 기본으로 설정하는 격리 수준입니다. 트랜잭션이 커밋한 데이터만 다른 트랜잭션에서 읽을 수 있습니다. 이 수준에서는 Dirty Read는 방지하지만, Non-Repeatable Read와 Phantom Read는 여전히 발생할 수 있습니다.
3. Repeatable Read: 같은 트랜잭션에서 여러 번 데이터를 읽을 때 항상 같은 결과를 보장합니다. 이 수준에서는 Dirty Read와 Non-Repeatable Read는 방지하지만, Phantom Read는 여전히 발생할 수 있습니다.
4. Serializable: 가장 높은 수준의 격리를 제공합니다. 모든 트랜잭션을 순차적으로 실행하여 동시성 문제를 완전히 방지합니다. 하지만 이 방법은 동시에 많은 트랜잭션을 처리할 수 없으므로 성능 저하를 일으킬 수 있습니다.
- 이렇게 다양한 격리 수준을 제공하는 이유는 성능과 데이터 일관성 간의 적절한 균형을 찾기 위해서입니다. 격리 수준을 높이면 데이터의 일관성은 높아지지만, 동시에 처리할 수 있는 트랜잭션의 수는 줄어들어 성능이 저하될 수 있습니다. 따라서 애플리케이션의 요구사항과 환경에 따라 적절한 격리 수준을 선택하는 것이 중요합니다.

</div>
</details>
<details>
<summary>트랜잭션의 격리 수준에서 발생할 수 있는 문제들에 대해서 설명해주세요.</summary>
<div markdown="1">

1. Dirty Read: 한 트랜잭션에서 아직 커밋되지 않은 변경 사항을 다른 트랜잭션이 읽는 현상입니다. 이 경우, 만약 첫 번째 트랜잭션이 롤백되면, 두 번째 트랜잭션은 존재하지 않는 데이터를 읽게 됩니다.
2. Non-Repeatable Read: 한 트랜잭션 안에서 같은 쿼리를 두 번 수행했을 때, 결과가 다르게 나오는 현상입니다. 첫 번째 쿼리 이후 다른 트랜잭션이 값을 변경하거나 삭제함으로써 발생합니다.
3. Phantom Read: 한 트랜잭션 안에서 같은 쿼리를 두 번 수행했을 때, 첫 번째 쿼리에서는 없던 행이 두 번째 쿼리에서 나타나는 현상입니다. 이는 첫 번째 쿼리 이후에 다른 트랜잭션이 새로운 행을 삽입함으로써 발생합니다.

</div>
</details>
<details>
<summary>MySQL에서도 Phantom Read가 발생하나요?</summary>
<div markdown="1">

- MySQL의 InnoDB 스토리지 엔진에서는 Repeatable Read 격리 수준을 기본으로 사용합니다. 이 격리 수준에서는 일반적으로 Phantom Read 현상이 발생할 수 있지만, MySQL의 InnoDB는 이를 방지하기 위한 방법을 제공합니다.
- InnoDB는 일관된 읽기(Consistent Read)를 지원하는데, 이는 SELECT 쿼리를 실행할 때마다 해당 시점의 스냅샷을 만들어 일관된 데이터를 제공하는 기능입니다. 즉, 트랜잭션이 시작된 이후에 다른 트랜잭션에서 삽입, 수정, 삭제한 데이터는 현재 트랜잭션에 영향을 주지 않습니다. 이를 통해 MySQL의 InnoDB에서는 Repeatable Read 격리 수준에서도 Phantom Read 현상을 방지합니다.
- 하지만, 이 기능은 SELECT 쿼리에만 적용되며, SELECT FOR UPDATE나 LOCK IN SHARE MODE와 같은 명령어는 스냅샷을 사용하지 않습니다. 따라서 이러한 명령어를 사용하는 경우에는 Phantom Read 현상이 발생할 수 있습니다. 이러한 경우를 방지하려면 Serializable 격리 수준을 사용해야 합니다.

</div>
</details>
<details>
<summary>🤔 트랜잭션 동시성 제어에 대해 설명해주세요.</summary>
<div markdown="1">

- 트랜잭션 동시성 제어는 여러 트랜잭션이 동시에 실행될 때 데이터의 일관성을 유지하고, 동시성 문제를 방지하기 위한 기법입니다.
- 다수의 트랜잭션을 동시에 처리하는 것은 자원의 효율적인 활용, 시스템의 처리량 증가 등의 이점을 제공하지만, 동시에 여러 문제점을 야기할 수 있습니다. 예를 들어, 한 트랜잭션이 처리 중인 데이터를 다른 트랜잭션이 동시에 접근하거나 변경하면, 데이터의 일관성이 깨질 수 있습니다. 이와 같은 문제를 해결하기 위해 동시성 제어 기법이 필요합니다.
- 동시성 제어 기법에는 락킹(Locking), 타임스탬프 기반(Timestamp-based), 낙관적 동시성 제어(Optimistic Concurrency Control), 다중 버전 동시성 제어(Multiversion Concurrency Control) 등이 있습니다.
1. 락킹: 특정 데이터에 대한 접근을 제어하는 방법으로, 트랜잭션이 데이터를 읽거나 쓰기 전에 락을 획득해야 합니다. 락은 공유 락(Read Lock)과 배타적 락(Write Lock)이 있습니다.
2. 타임스탬프 기반: 트랜잭션에게 고유한 타임스탬프를 부여하여, 타임스탬프 순서에 따라 트랜잭션을 실행하는 방법입니다.
3. 낙관적 동시성 제어: 트랜잭션이 실행되는 동안은 다른 트랜잭션의 영향을 받지 않다가, 커밋 시점에 검증을 수행하는 방법입니다.
4. 다중 버전 동시성 제어: 각 트랜잭션에게 데이터의 특정 버전을 제공하여 동시성을 제어하는 방법입니다.

</div>
</details>
<details>
<summary>🤔 교착 상태란 무엇이며, 어떻게 해결해야 하나요?</summary>
<div markdown="1">

- 교착 상태(Deadlock)란 두 개 이상의 트랜잭션이 서로의 작업이 끝나기를 무한히 기다리는 상황을 말합니다. 이런 상황은 각 트랜잭션이 다른 트랜잭션에 의해 잠긴 리소스를 요청하면서 발생합니다. 교착 상태가 발생하면 트랜잭션은 진행이 중단되며, 이를 해결하지 않으면 시스템 전체의 성능 저하나 데이터베이스 시스템의 정지 등의 심각한 문제를 야기할 수 있습니다.
- 교착 상태를 해결하기 위한 방법은 크게 세 가지로 나눌 수 있습니다.
1. 예방(Deadlock Prevention): 교착 상태가 발생하지 않도록 시스템을 설계하는 것입니다. 예를 들어, 트랜잭션에서 모든 필요한 락을 한 번에 획득하도록 요구하거나, 락을 획득하는 순서를 정해놓는 등의 방법이 있습니다.
2. 회피(Deadlock Avoidance): 시스템이 교착 상태를 야기할 수 있는 상황을 인지하고 이를 피하는 방법입니다. 이를 위해서는 시스템의 상태를 지속적으로 모니터링하고, 리소스 요청이 교착 상태를 야기할 수 있는 상황이면 해당 요청을 보류하는 등의 방법을 사용합니다.
3. 탐지 및 복구(Deadlock Detection and Recovery): 교착 상태가 발생하면 이를 탐지하고 복구하는 방법입니다. 일정 시간마다 교착 상태를 체크하고, 교착 상태에 있는 트랜잭션을 중단하거나 롤백하여 교착 상태를 해결합니다.
- 이 중 어떤 방법을 선택할지는 시스템의 특성과 요구사항에 따라 달라집니다. 예를 들어, 트랜잭션의 수가 많고, 리소스 요청이 빈번하다면 교착 상태 발생 확률이 높으므로 탐지 및 복구 방법을 사용하는 것이 효과적일 수 있습니다. 반면에, 트랜잭션의 수가 적고 리소스 요청이 드물다면 예방 방법을 사용하는 것이 더 효율적일 수 있습니다.

</div>
</details>
<details>
<summary>Lock에 대해 설명하고, 어떤 종류가 있는지 말씀해주세요.</summary>
<div markdown="1">

- 데이터베이스에서 락(Lock)은 특정 데이터에 대한 동시 접근을 제어하는 기능을 말합니다. 락을 이용하면 여러 트랜잭션이 동시에 같은 데이터를 변경하는 것을 방지하고, 따라서 데이터의 일관성을 보장할 수 있습니다.
- 데이터베이스에서 주로 사용되는 락의 종류에는 공유 락(Shared Lock)과 배타적 락(Exclusive Lock)이 있습니다.
1. 공유 락(Shared Lock): 읽기 작업을 위한 락으로, 이 락이 설정된 데이터는 다른 트랜잭션에서 읽을 수 있지만 변경할 수는 없습니다. 즉, 여러 트랜잭션이 동시에 같은 데이터를 읽을 수 있습니다.
2. 배타적 락(Exclusive Lock): 쓰기 작업을 위한 락으로, 이 락이 설정된 데이터는 다른 트랜잭션에서 읽거나 쓰는 것을 모두 막습니다. 즉, 한 트랜잭션에서 배타적 락을 획득하면, 그 트랜잭션이 락을 해제할 때까지 다른 트랜잭션은 해당 데이터에 접근할 수 없습니다.
- 데이터베이스 시스템은 이러한 락을 활용하여 트랜잭션의 ACID 속성을 보장합니다. 트랜잭션에서 데이터를 읽거나 쓸 때 적절한 락을 설정하고, 작업이 완료되면 락을 해제함으로써 데이터의 동시 접근을 제어합니다.

</div>
</details>
<details>
<summary>Optimistic Lock과 Pessimistic Lock에 대해 설명해 주세요.</summary>
<div markdown="1">

- Optimistic Lock과 Pessimistic Lock은 락을 사용하는 방식에 따라 구분되는 두 가지 전략입니다.
1. Optimistic Lock(낙관적 락): 이는 데이터의 충돌이 그리 자주 발생하지 않을 것이라는 '낙관적' 가정 하에 충돌이 발생할 때 어떻게 해결할지에 초점을 맞춥니다. 낙관적 락은 실제로 락을 사용하지 않고, 데이터를 읽을 때는 아무런 제한 없이 읽습니다. 그리고 데이터를 변경하려고 할 때, 데이터가 원래 읽었던 시점부터 변경되지 않았다는 것을 확인하고 변경을 진행합니다. 만약 데이터가 변경되었다면 충돌이 발생한 것으로 판단하고 충돌 해결 전략(재시도, 에러 반환 등)을 적용합니다.
2. Pessimistic Lock(비관적 락): 이는 데이터의 충돌이 자주 발생할 것이라는 '비관적' 가정 하에 미리 락을 걸어 충돌을 예방하는 방식입니다. 비관적 락은 데이터를 읽을 때 공유 락을, 변경할 때 배타적 락을 걸어 다른 트랜잭션으로부터 데이터를 보호합니다. 이 방식은 데이터 충돌을 미연에 방지하지만, 락 때문에 동시성이 떨어질 수 있습니다.
- 이 두 가지 방식은 각각의 상황에 따라 적합하게 사용됩니다. 충돌이 자주 발생하지 않는 환경이거나 동시성이 중요한 경우에는 낙관적 락을, 반면에 충돌이 자주 발생하거나 데이터의 일관성이 중요한 경우에는 비관적 락을 사용합니다.

</div>
</details>
<details>
<summary>🤔 트랜잭션의 전파 옵션에 대해 설명해주세요. 각 옵션이 어떤 경우에 사용되는지 예를 들어주세요.</summary>
<div markdown="1">

- 트랜잭션의 전파 옵션(Propagation Option)은 이미 진행 중인 트랜잭션의 범위에서 새로운 트랜잭션을 시작할 때 어떻게 처리할지를 결정하는 옵션입니다. 이 옵션은 일반적으로 스프링 프레임워크와 같은 애플리케이션 프레임워크에서 제공하며, 주로 다음과 같은 여섯 가지 옵션을 제공합니다.
1. REQUIRED: 기본 옵션으로, 이미 진행 중인 트랜잭션이 있으면 그 트랜잭션에 참여하고, 없으면 새로운 트랜잭션을 시작합니다. 예를 들어, 주문 처리 로직에서 결제와 배송이라는 두 가지 작업을 하나의 트랜잭션으로 처리하려면 이 옵션을 사용할 수 있습니다.
2. SUPPORTS: 진행 중인 트랜잭션이 있으면 그 트랜잭션에 참여하고, 없으면 트랜잭션 없이 진행합니다. 예를 들어, 읽기 전용 쿼리와 같이 트랜잭션이 필수적이지 않은 경우에 이 옵션을 사용할 수 있습니다.
3. MANDATORY: 반드시 진행 중인 트랜잭션이 있어야 하며, 없으면 예외를 발생시킵니다. 예를 들어, 기존 트랜잭션의 일부로만 동작해야 하는 로직에서 이 옵션을 사용할 수 있습니다.
4. REQUIRES_NEW: 항상 새로운 트랜잭션을 시작하며, 진행 중인 트랜잭션이 있으면 잠시 보류합니다. 예를 들어, 로그 작성과 같이 다른 트랜잭션과 독립적으로 동작해야 하는 경우에 이 옵션을 사용할 수 있습니다.
5. NOT_SUPPORTED: 트랜잭션 없이 동작하며, 진행 중인 트랜잭션이 있으면 잠시 보류합니다. 예를 들어, 메일 보내기와 같이 트랜잭션이 필요하지 않은 경우에 이 옵션을 사용할 수 있습니다.
6. NEVER: 트랜잭션 없이 동작하며, 진행 중인 트랜잭션이 있으면 예외를 발생시킵니다. 예를 들어, 트랜잭션과 관련 없는 검증 로직 등에서 이 옵션을 사용할 수 있습니다.

</div>
</details>
<details>
<summary>트랜잭션 전파 옵션을 설정할 때 고려해야 할 사항은 무엇인가요?</summary>
<div markdown="1">

1. 트랜잭션 범위: 트랜잭션이 필요한 작업의 범위를 파악해야 합니다. 예를 들어, 여러 개의 데이터 변경 작업이 하나의 논리적 단위를 이룬다면, 이들 작업을 하나의 트랜잭션으로 묶어야 합니다.
2. 동시성과 격리 수준: 트랜잭션을 너무 크게 잡으면 동시성이 떨어질 수 있습니다. 반면에, 트랜잭션을 너무 작게 잡으면 데이터의 일관성을 보장하기 어려울 수 있습니다. 따라서 동시성과 격리 수준 사이의 균형을 잘 맞춰야 합니다.
3. 성능: 트랜잭션은 데이터베이스의 성능에 영향을 줍니다. 트랜잭션이 길어질수록 락이 오래 걸려 동시성이 떨어지고, 이는 시스템의 전반적인 성능 저하로 이어질 수 있습니다. 따라서 트랜잭션의 범위를 적절히 설정하여 성능 저하를 최소화해야 합니다.
4. 복구: 트랜잭션 내에서 오류가 발생했을 때, 원상태로 복구할 수 있는지를 고려해야 합니다. 예를 들어, 너무 많은 작업을 하나의 트랜잭션으로 묶으면, 하나의 작업에서 오류가 발생했을 때 모든 작업을 롤백해야 할 수 있습니다.

</div>
</details>
<details>
<summary>읽기에는 트랜잭션을 걸지 않아도 될까요?</summary>
<div markdown="1">

- 읽기 작업에 대해서도 트랜잭션을 걸어주는 것이 좋습니다. 이유는 다음과 같습니다.
1. 일관성 보장: 읽기 작업 도중에 다른 트랜잭션에서 해당 데이터를 변경하면, 읽기 작업을 수행하는 도중에 데이터가 바뀔 수 있습니다. 이는 데이터의 일관성을 해칠 수 있습니다. 트랜잭션을 걸어주면, 해당 트랜잭션 동안은 일관된 데이터를 보장받을 수 있습니다.
2. 지연 로딩(Lazy Loading) 지원: JPA에서는 연관된 엔티티를 나중에 필요할 때 로딩하는 지연 로딩 전략을 자주 사용합니다. 트랜잭션이 끝난 후에 지연 로딩을 하려고 하면, 'LazyInitializationException'이 발생합니다. 트랜잭션 범위 내에서 지연 로딩을 수행하려면 읽기에도 트랜잭션을 걸어주어야 합니다.
3. 따라서 Spring에서는 읽기 작업에 대해서도 @Transactional 애노테이션을 사용합니다. 이때, readOnly=true 옵션을 주면, 데이터를 변경하지 않는 읽기 전용 트랜잭션으로 설정할 수 있습니다. 이렇게 하면 데이터베이스는 필요한 최적화를 수행할 수 있어 성능을 향상시킬 수 있습니다.

</div>
</details>
<details>
<summary>readOnly=true 옵션을 주면 구체적으로 어떤 점이 좋나요?</summary>
<div markdown="1">

- readOnly=true 옵션을 사용하면, 해당 트랜잭션은 데이터를 변경하는 쓰기 작업이 없다는 것을 명시적으로 선언합니다. 이로 인해 데이터베이스는 일부 최적화 작업을 수행할 수 있어, 성능 향상을 기대할 수 있습니다. 구체적인 이점은 다음과 같습니다.
1. 불필요한 락 회피: 읽기 전용 트랜잭션에서는 데이터를 변경하지 않으므로, 데이터에 대한 락을 획득할 필요가 없습니다. 따라서, 락 경합으로 인한 성능 저하를 피할 수 있습니다.
2. 더티 체킹(Dirty Checking) 최소화: JPA 등의 ORM 프레임워크는 트랜잭션이 종료될 때 엔티티의 변경을 감지하고, 변경된 엔티티에 대한 데이터베이스 업데이트를 수행하는 더티 체킹을 수행합니다. 읽기 전용 트랜잭션에서는 더티 체킹을 최소화할 수 있습니다.
3. 쿼리 힌트(Query Hint) 제공: 일부 데이터베이스는 읽기 전용 트랜잭션에 대해 특별한 처리를 수행하기도 합니다. 예를 들어, MySQL의 InnoDB 엔진에서는 읽기 전용 트랜잭션에 대해 스냅샷을 제공하여 일관된 읽기를 보장하고, 동시에 락 없이 데이터를 읽을 수 있도록 합니다.
- 따라서, 읽기 작업만 수행하는 트랜잭션에서는 readOnly=true 옵션을 사용하여 이러한 이점을 활용하는 것이 좋습니다.

</div>
</details>
<details>
<summary>실제로 개발하면서 트랜잭션을 어떻게 사용했나요?</summary>
<div markdown="1">


</div>
</details>
<details>
<summary>실제 프로젝트에서 트랜잭션의 전파 옵션을 어떻게 설정하였고, 그 이유는 무엇인가요?</summary>
<div markdown="1">



</div>
</details>
<details>
<summary>트랜잭션을 사용함으로써 얻은 이점과 동시에 겪은 어려움에 대해 이야기해주세요.</summary>
<div markdown="1">



</div>
</details>


<br>

# 📍 Reference
- https://github.com/VSFe/Tech-Interview/blob/main/04-DATABASE.md
- https://github.com/dev-team-study/cs-study/tree/main/%5B1%ED%9A%8C%EC%B0%A8%5D1.database/03_%EC%A0%95%EA%B7%9C%ED%99%94_%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98