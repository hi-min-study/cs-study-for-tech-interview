# 📍 키워드
- RDB
    - DBMS와 파일시스템의 차이
        - https://velog.io/@seo78200/Database-File-system-vs.-DBMS
        - https://ssungkang.tistory.com/entry/DATABASE-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-VS-%ED%8C%8C%EC%9D%BC%EC%B2%98%EB%A6%AC-%EC%8B%9C%EC%8A%A4%ED%85%9C
        - https://velog.io/@hsshin0602/CS-%EC%A7%80%EC%8B%9D-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%8B%9C%EC%8A%A4%ED%85%9C-VS-%ED%8C%8C%EC%9D%BC-%EC%B2%98%EB%A6%AC-%EC%8B%9C%EC%8A%A4%ED%85%9C
    - RDB의 개념과 장단점
        - https://www.whatap.io/ko/blog/173/
        - 수평적 확장이 어려운 이유
            - https://okky.kr/questions/1458410
    - DDL, DML, DCL, TCL
        - https://velog.io/@alicesykim95/DB-DDL-DML-DCL-TCL%EC%9D%B4%EB%9E%80
        - https://kkkdh.tistory.com/entry/DB-DDL-DML-DCL-TCL-%EC%9D%B4%EB%9E%80
    - Key
        - https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Database/%5BDB%5D%20Key.md
        - https://adjh54.tistory.com/245
        - 무결성 제약조건
            - https://iingang.github.io/posts/DB-Integrity-constraint/
            - https://inpa.tistory.com/entry/DB-%F0%9F%93%9A-%EB%AC%B4%EA%B2%B0%EC%84%B1-%EC%A0%9C%EC%95%BD-%EC%A1%B0%EA%B1%B4-%F0%9F%95%B5%EF%B8%8F-%EC%A0%95%EB%A6%AC
        - PK와 Unique Key의 차이
            - https://www.geeksforgeeks.org/difference-between-primary-key-and-unique-key/

<br>

# 📍 예상 질문
- DB와 DBMS의 차이가 무엇일까요?
    - DB(DataBase)는 관련된 데이터의 집합을 의미합니다. 이 데이터는 구조화되어 있어서 쉽게 접근하고 관리할 수 있습니다.
    - DBMS(DataBase Management System)는 이러한 데이터베이스를 생성하고, 관리하고, 조작하는 소프트웨어 도구입니다. DBMS는 데이터의 일관성, 보안성, 및 효율성을 유지하며, 사용자가 데이터베이스와 상호작용할 수 있도록 합니다. MySQL, Oracle, SQL Server 등이 DBMS의 예시입니다.
    - 따라서, DB는 데이터의 집합이며, DBMS는 그 데이터를 관리하는 시스템이라고 할 수 있습니다.

- 데이터베이스가 파일시스템에 비해 갖는 장점은 무엇일까요?
    - 일관성: 데이터베이스는 트랜잭션을 통해 데이터의 일관성을 보장합니다. 트랜잭션은 일련의 작업들을 하나의 논리적 단위로 묶는 것으로, 모든 작업이 성공적으로 완료되거나 아니면 전혀 실행되지 않은 상태를 보장합니다.
    - 동시성 제어: 여러 사용자가 동시에 데이터베이스에 접근할 때, 데이터베이스는 동시성 제어를 통해 데이터의 일관성과 정확성을 유지합니다.
    - 보안: 데이터베이스는 사용자별로 접근 권한을 설정할 수 있어, 데이터의 보안을 보장합니다.
    - 복구 기능: 데이터베이스는 시스템 장애 시 복구 기능을 제공하여 데이터의 손실을 방지합니다.
    - 중복 제거: 데이터베이스는 데이터의 중복성을 제거하고, 데이터의 무결성을 유지합니다.
    - 데이터 추상화: 데이터베이스는 물리적인 데이터 저장 방법을 숨기고, 사용자에게 논리적인 인터페이스만을 제공하여 사용의 편의성을 제공합니다.
    - 이와 같이, 데이터베이스는 파일 시스템에 비해 보다 효과적인 데이터 관리를 가능하게 합니다.

- 관계형 데이터베이스의 단점은 무엇일까요? 
    - 확장성의 한계: 관계형 데이터베이스는 대량의 데이터를 처리하는 데 있어 한계를 가질 수 있습니다. 특히, 데이터의 양이 급격히 증가하는 빅 데이터 환경에서는 확장성이 제한적일 수 있습니다.
    - 복잡한 구조: 관계형 데이터베이스는 테이블 간의 관계를 정의하고 유지하는 데 있어 복잡성이 존재합니다. 이로 인해 데이터베이스 설계와 관리가 어려울 수 있습니다.
    - 유연성 부족: 관계형 데이터베이스는 고정된 스키마를 가지고 있어, 데이터의 구조가 변경될 경우 스키마 수정이 필요하며 이는 비용이 발생합니다.
    - 비용: 대규모 관계형 데이터베이스 시스템은 종종 비싼 라이선스 비용이 발생하고, 이에 대한 지속적인 유지 보수 비용도 필요합니다.

- 관계형 데이터베이스가 대량의 데이터를 처리하는데 있어서 어떤 한계를 가지는 걸까요? 왜 수평적 확장이 어려운 것 일까요?
    - 관계형 데이터베이스(RDBMS)는 기본적으로 수직 확장(Vertical Scaling)에 기반을 두고 설계되었습니다. 수직 확장이란 하드웨어의 성능을 향상시키는 것으로, 예를 들면 더 빠른 CPU, 더 많은 RAM, 더 큰 디스크 등을 추가하는 것을 말합니다. 이 방식은 성능 향상을 위해 비용을 많이 투자해야 하며, 물리적인 한계가 있습니다.
    - 반면에 수평 확장(Horizontal Scaling)은 시스템 용량을 늘리기 위해 서버를 추가하는 방식입니다. 이 방식은 데이터를 여러 노드에 분산시켜 처리하므로, 더 큰 데이터 세트를 더 빠르게 처리할 수 있습니다.
    - 그러나 RDBMS는 데이터의 무결성을 보장하기 위해 테이블 간의 복잡한 관계를 유지합니다. 이로 인해 데이터를 여러 노드에 분산시키는 것이 어렵습니다. 예를 들어, 데이터를 분산시킬 때 특정 트랜잭션이 여러 노드를 걸쳐 이루어져야 하는 경우, 이를 관리하고 일관성을 유지하는 것이 매우 복잡해집니다.
    - 이러한 이유로, RDBMS는 대량의 데이터를 처리하고, 데이터를 여러 노드에 분산시키는 데 있어 한계를 가지며, 수평적 확장이 어렵습니다. 이런 문제를 해결하기 위해 NoSQL 데이터베이스가 등장하였고, 일부 경우에는 더 적합한 선택이 될 수 있습니다.

- DDL, DML, DCL ,TCL에 대해 설명해주세요.
    - DDL(Data Definition Language): 데이터 정의 언어는 테이블과 같은 데이터 구조를 생성, 변경, 삭제하는데 사용됩니다. 주로 사용되는 명령어로는 CREATE(생성), ALTER(변경), DROP(삭제), TRUNCATE(테이블의 데이터를 삭제) 등이 있습니다.
    - DML(Data Manipulation Language): 데이터 조작 언어는 데이터를 실질적으로 조작하는데 사용됩니다. SELECT(조회), INSERT(삽입), UPDATE(수정), DELETE(삭제) 등이 주요 명령어입니다.
    - DCL(Data Control Language): 데이터 제어 언어는 데이터베이스에 접근하고 객체들을 사용하도록 권한을 부여하거나 회수하는데 사용됩니다. 주로 사용되는 명령어로는 GRANT(권한 부여), REVOKE(권한 회수) 가 있습니다.
    - TCL(Transaction Control Language): 트랜잭션 제어 언어는 트랜잭션을 관리하는 데 사용됩니다. COMMIT(트랜잭션 확정), ROLLBACK(트랜잭션 취소), SAVEPOINT(트랜잭션 내의 특정 지점 설정) 등이 주요 명령어입니다.

- 관계형 데이터베이스의 key 개념들에 대해 설명 부탁드립니다.
    - 기본 키(Primary Key): 각 테이블의 각 행을 고유하게 식별하는 데 사용되는 키입니다. 기본 키는 NULL 값을 허용하지 않으며, 중복되는 값이 없어야 합니다. 각 테이블은 하나의 기본 키만 가질 수 있습니다.
    - 후보 키(Candidate Key): 기본 키가 될 수 있는 후보로 선정된 키입니다.
    - 대체 키(Alternate Key): 기본 키로 선택되지 않은 후보 키를 대체 키라고 합니다. 
    - 슈퍼 키(Super Key): 테이블의 행을 고유하게 식별할 수 있는 하나 이상의 컬럼의 집합을 말합니다. 기본 키, 후보 키, 대체 키들의 조합이 슈퍼 키가 됩니다. 따라서 기본 키는 슈퍼 키의 일종이며, 가장 최소한의 속성으로 구성된 슈퍼 키가 기본 키가 됩니다.
    - 외래 키(Foreign Key): 한 테이블의 필드가 다른 테이블의 기본 키를 참조할 때, 이를 외래 키라고 합니다. 외래 키를 통해 관계형 데이터베이스의 '관계'가 형성됩니다.
    - 복합 키(Composite Key): 두 개 이상의 필드를 결합하여 고유한 값을 생성하는 키입니다. 이는 각 필드 자체로는 고유성을 보장할 수 없지만, 결합하면 고유성이 보장될 때 사용됩니다.
    - 유니크 키(Unique Key): 중복된 값을 가질 수 없는 키입니다. 기본 키와 달리 테이블 내에 여러 개의 유니크 키가 존재할 수 있습니다.

- 기본키로 의미적인 컬럼보다, auto-increament가 선호되는 이유가 무엇일까요?
    - 유일성 보장: Auto-increment 필드는 새로운 레코드가 추가될 때마다 자동으로 증가하므로, 고유성을 항상 보장해줍니다. 반면, 의미 있는 필드를 기본 키로 사용하면 중복이 발생할 가능성이 있습니다.
    - 데이터의 안정성: 의미 있는 컬럼은 사용자의 요구나 비즈니스 로직에 따라 변경될 가능성이 있습니다. 기본 키는 고유 식별자로서의 역할을 하기 때문에, 일관성과 안정성을 위해 변경되지 않아야 합니다.
    - 성능 향상: 숫자형 auto-increment 키는 문자열 등의 다른 데이터 타입에 비해 인덱싱이 더 빠르고 효율적입니다. 이로 인해 데이터 조회 성능이 향상됩니다.
    - 데이터 무결성: 의미 있는 필드를 기본 키로 사용하면 해당 필드에 NULL 값이나 중복 값이 들어갈 수 없어, 데이터 입력에 제약이 따릅니다.

- 외래키 값은 NULL이 들어올 수 있나요?
    - 네, 외래 키의 값은 NULL이 될 수 있습니다. 외래 키는 다른 테이블의 기본 키를 참조하는 필드입니다. 이는 해당 필드가 참조하는 테이블의 행을 가리키는 것을 의미하며, NULL은 "아무 것도 가리키지 않음"을 의미합니다.
    - 따라서 외래 키의 값이 NULL인 경우, 그 필드는 다른 테이블의 어떤 행도 참조하지 않는다는 것을 의미합니다. 이는 특정 상황에서 유용하게 사용될 수 있습니다. 예를 들어, 특정 주문이 아직 배송되지 않아 '배송원' 필드(다른 테이블의 '배송원' 행을 참조하는 외래 키)가 아직 결정되지 않은 경우, 이 필드는 NULL이 될 수 있습니다.

- 외래 키의 참조 무결성 제약 조건에 대해 설명해주세요.
    - 삽입/수정 규칙: 외래 키 필드에 입력되는 값은 반드시 참조하는 테이블의 기본 키 값 중 하나이거나 NULL이어야 합니다. 즉, 참조하는 테이블에 없는 값은 외래 키 필드에 입력할 수 없습니다.
    - 삭제/수정 규칙: 기본 키가 외래 키로 참조되고 있는 경우, 그 기본 키 값을 삭제하거나 변경할 수 없습니다. 이를 위반하면 참조 무결성 오류가 발생합니다.
- (꼬리 질문) 삭제/수정을 할 수 있는 경우는 없나요?
    - 네, 참조 무결성 제약 조건을 지키면서도 기본 키를 삭제하거나 수정하는 것은 가능합니다. 그러나 이를 위해서는 외래 키가 참조하는 기본 키 값이 변경될 때 외래 키 값을 어떻게 처리할 지를 명시해야 합니다. 이를 위한 CASCADE, SET NULL, SET DEFAULT, NO ACTION 등의 옵션이 제공됩니다.
    - CASCADE: 기본 키 값이 변경(수정 또는 삭제)되면, 해당 기본 키를 참조하는 외래 키 값도 함께 변경됩니다. 예를 들어, 기본 키가 삭제되면 해당 기본 키를 참조하는 모든 외래 키를 가진 행도 삭제됩니다.
    - SET NULL: 기본 키 값이 변경되면, 해당 기본 키를 참조하는 외래 키 값은 NULL로 설정됩니다.
    - SET DEFAULT: 기본 키 값이 변경되면, 해당 기본 키를 참조하는 외래 키 값은 해당 필드의 기본 값으로 설정됩니다.
    - NO ACTION: 기본 키 값이 변경되는 것을 허용하지 않습니다. 즉, 해당 기본 키를 참조하는 외래 키가 있는 경우 기본 키 값을 변경할 수 없습니다.
    - 이렇게 데이터베이스는 참조 무결성을 유지하면서도 기본 키의 변경을 허용하는 여러 가지 방법을 제공합니다. 이를 적절히 활용하면 데이터의 일관성을 유지하면서도 유연한 데이터 관리가 가능합니다.

<br>

# 📍 Reference
- https://github.com/dev-team-study/cs-study/tree/main/%5B1%ED%9A%8C%EC%B0%A8%5D1.database/01_%EA%B4%80%EA%B3%84%ED%98%95_%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4
- https://github.com/VSFe/Tech-Interview/blob/main/04-DATABASE.md