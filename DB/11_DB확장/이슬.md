# 📍 키워드

- 수직적 확장과 수평적 분할
- Master/Slave
- Partitioning, Sharding
- CAP 이론

<br>

# 📍 예상 질문
<details>
<summary>트래픽이 높아질 때, DB는 어떻게 관리를 할 수 있을까요?</summary>
<div markdown="1">

1. 인덱싱: 쿼리 성능을 향상시키기 위해 인덱싱을 사용할 수 있습니다. 인덱스는 테이블의 데이터를 빠르게 검색할 수 있도록 도와주는 DBMS의 기능입니다.
2. 캐싱: 자주 사용되는 쿼리의 결과를 캐시에 저장하여, DB로의 요청을 줄일 수 있습니다. 이는 DB의 부하를 줄이고 응답 시간을 개선하는 데 도움이 됩니다.
3. 데이터베이스 분할: 대용량 데이터를 관리하기 위해 Partitioning이나 Sharding 같은 데이터베이스 분할 전략을 사용할 수 있습니다. Partitioning은 하나의 테이블을 여러 파티션으로 나누는 방법이고, Sharding은 데이터를 여러 DB로 분산시키는 방법입니다. 이는 데이터베이스의 처리 능력을 향상시키고, 데이터 관리를 용이하게 합니다.
4. 리플리케이션: 데이터베이스의 복제본을 만들어서 부하를 분산시키는 방법입니다. 주로 읽기 쿼리의 부하를 분산시키는 데 사용됩니다.
5. 스케일 업과 스케일 아웃: 더 강력한 하드웨어를 사용하거나(스케일 업), 여러 서버에 데이터베이스를 분산시켜서(스케일 아웃) 처리 능력을 향상시킬 수 있습니다.

</div>
</details>
<details>
<summary>수직적 확장과 수평적 확장의 차이점을 설명해주세요.</summary>
<div markdown="1">

- **수직적 확장(Vertical Scaling)**은 기본적으로 '스케일 업(Scale Up)'이라고도 불립니다. 이는 기존의 하드웨어의 성능을 향상시키는 방법을 말합니다. 예를 들어, 더 강력한 CPU, 더 많은 RAM, 더 큰 저장 공간을 갖는 서버로 기존 서버를 업그레이드하는 것을 말합니다.
- 반면에, **수평적 확장(Horizontal Scaling)**은 '스케일 아웃(Scale Out)'이라고도 불립니다. 이는 더 많은 서버를 추가하여 처리 능력을 향상시키는 방법을 말합니다. 즉, 여러 서버에 작업을 분산시킴으로써 부하를 줄이고 전체 시스템의 성능을 향상시키는 것입니다.
- 두 가지 방법 모두 장단점이 있습니다. 수직적 확장은 보통 구현이 쉽고 데이터 일관성 유지가 비교적 간단하지만, 하드웨어 업그레이드에는 한계가 있으며, 비용 효율성이 떨어질 수 있습니다. 반면, 수평적 확장은 거의 무한대로 확장이 가능하고 비용 효율성이 높지만, 데이터 관리가 복잡해지고, 분산 처리에 대한 고려가 필요합니다.

</div>
</details>
<details>
<summary>어떤 상황에서 수직적 확장을 선택해야 하고 어떤 상황에서 수평적 확장을 선택해야 할까요?</summary>
<div markdown="1">

- 수직적 확장과 수평적 확장은 각각 다른 상황에 적합합니다.
- 수직적 확장은 다음과 같은 상황에서 선택하는 것이 좋습니다:
1. 시스템의 복잡성을 최소화하고 싶을 때: 수직적 확장은 기존 서버의 하드웨어를 업그레이드하기 때문에, 시스템의 구성이나 관리가 상대적으로 간단합니다.
2. 데이터 일관성이 중요한 경우: 다수의 서버 간에 데이터를 동기화하는 것보다 단일 서버에서 데이터를 관리하는 것이 더 간단하며 일관성을 유지하는 데 유리합니다.
- 하지만, 하드웨어 업그레이드에는 한계가 있으므로, 트래픽이 계속 증가하는 경우 수직적 확장만으로는 부족할 수 있습니다.
- 수평적 확장은 다음과 같은 상황에서 선택하는 것이 좋습니다:
1. 높은 트래픽을 처리해야 할 때: 수평적 확장은 여러 서버에 부하를 분산시킴으로써 더 많은 트래픽을 처리할 수 있습니다.
2. 서비스의 가용성을 높이고 싶을 때: 한 서버가 다운되더라도 다른 서버들이 작업을 계속 처리할 수 있으므로, 서비스의 가용성을 높일 수 있습니다.

</div>
</details>
<details>
<summary>수평적 확장을 구현할 때 어떤 문제점이 발생할 수 있나요?</summary>
<div markdown="1">

- 수평적 확장, 즉 스케일 아웃을 구현할 때는 다음과 같은 문제점이 발생할 수 있습니다.
1. 데이터 일관성 유지: 여러 서버에 데이터를 분산시키게 되면, 데이터의 일관성을 유지하는 것이 중요한 문제가 됩니다. 하나의 서버에서 변경이 발생했을 때, 이 변경사항을 모든 서버에 동기화하는 것은 쉽지 않습니다.
2. 네트워크 지연과 병목: 여러 서버 간의 통신은 네트워크 지연을 초래할 수 있습니다. 이로 인해 전체 시스템의 성능이 떨어질 수 있습니다. 또한, 네트워크 병목 현상도 발생할 수 있습니다.
3. 복잡한 시스템 관리: 서버 수가 늘어나면, 시스템의 복잡성도 증가합니다. 각 서버의 상태를 모니터링하고, 문제가 발생했을 때 적절히 대응하는 것이 더 어려워집니다.
4. 데이터 분할의 어려움: 데이터를 어떻게 분할할지 결정하는 것은 쉽지 않은 작업입니다. 잘못된 데이터 분할 전략은 성능 저하를 초래하거나, 일부 서버에 과도한 부하를 주는 결과를 가져올 수 있습니다.
- 따라서, 수평적 확장을 구현할 때는 이러한 문제들을 고려하고 적절한 해결책을 마련해야 합니다.

</div>
</details>
<details>
<summary>이러한 분산 환경에선, 트랜잭션을 어떻게 관리할 수 있을까요?</summary>
<div markdown="1">

- 분산 환경에서 트랜잭션을 관리하는 것은 복잡한 문제입니다. 분산 트랜잭션은 여러 노드에 걸쳐 실행되는 트랜잭션으로, 모든 노드에서 트랜잭션이 성공적으로 완료되거나, 어느 하나라도 실패하면 모든 노드에서 롤백되어야 합니다. 이를 위해 다음과 같은 방법들이 사용됩니다.
1. 2단계 커밋(2-Phase Commit, 2PC): 분산 트랜잭션을 처리하는 가장 기본적인 방법으로, 모든 참여 노드에게 커밋할 준비가 되었는지 물어보고 모두 준비되었다면 커밋하라는 명령을 내리는 방식입니다. 하지만 이 방식은 한 노드가 실패하면 모든 트랜잭션이 블록될 수 있는 단점이 있습니다.
2. 3단계 커밋(3-Phase Commit, 3PC): 2PC의 단점을 개선한 방법으로, 시간 제한을 두어 한 노드가 실패하더라도 다른 노드의 트랜잭션 진행을 보장합니다.
3. 분산 타임스탬프(Distributed Timestamp): 각 트랜잭션에 타임스탬프를 부여하여, 타임스탬프 순서에 따라 트랜잭션을 처리하는 방법입니다.
4. 분산 잠금(Distributed Lock): 분산 환경에서 잠금을 관리하는 서비스를 사용하여 트랜잭션 동기화를 보장하는 방법입니다.
5. CAP 이론: 분산 환경에서 일관성(Consistency), 가용성(Availability), 분할 허용성(Partition tolerance) 중 두 가지만 동시에 보장할 수 있다는 이론입니다. 이를 통해 트랜잭션 처리 방식을 결정할 수 있습니다.
- 이러한 방법들을 적절히 조합하고 사용하면 분산 환경에서의 트랜잭션을 관리할 수 있습니다. 하지만 각 방법마다 장단점이 있으므로, 시스템의 요구사항에 따라 적절한 방법을 선택해야 합니다.

</div>
</details>
<details>
<summary>Master/Slave 구조는 어떤 경우에 사용되나요? 그리고 이 구조의 장단점은 무엇인가요?</summary>
<div markdown="1">

- Master/Slave 구조는 주로 분산 시스템에서 데이터의 일관성을 유지하거나, 부하 분산을 통해 시스템의 성능을 향상시키는 데 사용됩니다.
- 이 구조에서 Master는 데이터의 변경을 관리하고, Slave는 Master로부터 데이터를 복제받아 읽기 작업을 처리합니다. 이런 방식으로 읽기 요청에 대한 부하를 분산시킬 수 있습니다. 또한, Master가 다운되었을 때 Slave를 Master로 승격시켜 서비스의 중단 없이 운영을 계속할 수 있습니다.
- Master/Slave 구조의 장점은 다음과 같습니다:
1. 부하 분산: Slave 서버가 읽기 요청을 처리함으로써 Master 서버의 부하를 줄일 수 있습니다.
2. 데이터 복제를 통한 고가용성: Master 서버가 다운되었을 때, Slave 서버를 Master로 승격시켜 서비스를 계속 운영할 수 있습니다.
- 그러나, Master/Slave 구조의 단점도 있습니다:
1. 일관성 문제: Master와 Slave 사이의 데이터 동기화에 따른 일관성 문제가 발생할 수 있습니다. Master에서 발생한 변경사항이 Slave에 즉시 반영되지 않을 경우, 사용자는 잠시동안 이전의 데이터를 보게 될 수 있습니다.
2. Master 서버의 병목: 모든 쓰기 작업이 Master 서버를 통해 이루어지므로, 쓰기 요청이 많은 경우 Master 서버가 병목이 될 수 있습니다.
- 따라서, Master/Slave 구조를 선택할 때는 이러한 장단점을 고려하여 시스템의 요구사항에 맞게 적절히 사용해야 합니다.

</div>
</details>
<details>
<summary>Master/Slave 구조에서 마스터 서버가 다운되었을 때 어떻게 처리해야 하나요?</summary>
<div markdown="1">

- Master/Slave 구조에서 마스터 서버가 다운되었을 때, 일반적으로 다음과 같은 처리 방안을 고려합니다:
- Failover: 마스터 서버가 다운되면, 슬레이브 서버 중 하나를 새로운 마스터로 승격시키는 과정을 Failover라고 합니다. 이 과정은 자동화할 수도 있고, 수동으로 진행할 수도 있습니다.
1. 자동 Failover: 자동 Failover를 구현하기 위해서는 특정 감시 서비스가 필요합니다. 이 서비스는 마스터 서버의 상태를 지속적으로 모니터링하고, 문제가 발생하면 슬레이브 서버 중 하나를 새로운 마스터로 승격시킵니다.
2. 수동 Failover: 자동 Failover가 문제를 일으킬 수 있는 상황에서는 수동 Failover를 고려할 수 있습니다. 이 경우, 시스템 관리자가 상황을 직접 판단하고 적절한 서버를 마스터로 승격시킵니다.
- Failover 과정에서는 누락된 트랜잭션이 없도록 주의해야 합니다. 마스터 서버가 다운되기 전에 슬레이브 서버가 마지막으로 받아온 데이터 이후의 변경 내용을 복구해야 할 수 있습니다. 이를 위해 바이너리 로그 등의 기록을 활용할 수 있습니다.
- 그리고, Failover 이후에는 모든 클라이언트에게 새로운 마스터 서버의 정보를 알려야 합니다. 이 과정도 자동화하거나, DNS 업데이트 등의 방법으로 수동으로 처리할 수 있습니다.

</div>
</details>
<details>
<summary>Master/Slave 구조에서 데이터 동기화를 어떻게 처리하나요?</summary>
<div markdown="1">

- Master/Slave 구조에서 데이터 동기화는 주로 Master 서버에서 발생한 데이터 변경을 Slave 서버에 반영하는 과정으로 이루어집니다. 이는 다음과 같은 방법으로 처리할 수 있습니다:
1. 동기 복제(Synchronous Replication): 마스터 서버에서 데이터 변경이 일어날 때마다 이를 즉시 슬레이브 서버에 반영합니다. 이 방식은 데이터의 일관성을 높이지만, 모든 변경사항을 슬레이브 서버에 즉시 반영해야 하므로 네트워크 지연이나 슬레이브 서버의 처리 속도에 따라 성능에 영향을 줄 수 있습니다.
2. 비동기 복제(Asynchronous Replication): 마스터 서버에서 데이터 변경이 일어나면 이를 슬레이브 서버에 즉각적으로 반영하지 않고, 일정 시간 후에나 반영합니다. 이 방식은 성능에는 유리하지만, 일부 데이터가 복제되지 않은 상태에서 마스터 서버가 다운되면 데이터 손실이 발생할 수 있습니다.
3. 반-동기 복제(Semi-synchronous Replication): 동기와 비동기 복제의 중간 방식으로, 마스터 서버는 적어도 하나의 슬레이브 서버에 변경 사항이 반영되었음을 확인한 후에만 트랜잭션을 커밋합니다. 이 방식은 데이터의 일관성과 성능 사이에 균형을 맞추려는 시도입니다.
- 데이터 동기화 방식의 선택은 시스템의 요구사항에 따라 달라집니다. 데이터의 일관성이 중요한 시스템에서는 동기 복제를, 높은 성능이 필요한 시스템에서는 비동기 복제를 고려할 수 있습니다. 이외에도, 네트워크 환경, 하드웨어 성능, 데이터의 크기와 변경 빈도 등도 고려해야 합니다.

</div>
</details>
<details>
<summary>Master/Slave 데이터 동기화 전 까지의 데이터 정합성을 지키는 방법은 무엇이 있을까요?</summary>
<div markdown="1">

- Master/Slave 구조에서 데이터 동기화 전까지의 데이터 정합성을 지키는 방법은 여러 가지가 있습니다.
1. Write-Ahead Logging (WAL): 데이터를 DB에 쓰기 전에 로그에 먼저 기록하는 방식입니다. 이 방식을 사용하면, 시스템 장애가 발생했을 때 로그를 통해 마지막 상태로 복구할 수 있습니다.
2. Binary Log: MySQL 같은 DBMS에서는 Binary Log를 사용하여 모든 변경사항을 기록합니다. 이 로그는 Slave 서버가 동기화를 위해 사용할 뿐만 아니라, 데이터 손실이 발생했을 때 복구를 위한 수단으로도 사용됩니다.
3. 동기 복제(Synchronous Replication): Master에서 발생한 모든 변경을 즉시 Slave에 반영하는 방식입니다. 이를 통해 Master와 Slave 사이 데이터 불일치를 최소화할 수 있습니다.
4. Snapshot: 주기적으로 전체 데이터베이스의 스냅샷을 생성하고, 이를 기반으로 Slave 서버를 동기화하는 방법도 있습니다.
- 주의할 점은, 이러한 방법들도벽한 데이터 정합성을 보장하지는 못한다는 것입니다. 특히, 비동기 복제를 사용하는 경우, Master와 Slave 사이의 데이터 불일치가 일시적으로 발생할 수 있습니다. 따라서, 시스템의 요구사항에 따라 적절한 방법을 선택하고, 데이터 불일치를 최소화하는 전략을 적용해야 합니다.

</div>
</details>
<details>
<summary>Clustering과 Master-Slave Replication의 차이점은 무엇인가요?</summary>
<div markdown="1">

- 클러스터링(Clustering)과 마스터-슬레이브 복제(Master-Slave Replication)는 둘 다 분산 시스템 구조를 구성하는 방법이지만, 목표와 작동 방식에 차이가 있습니다.
- 마스터-슬레이브 복제는 주로 데이터의 일관성을 유지하고, 시스템의 가용성을 높이는 데 초점을 맞춥니다. 이 구조에서 마스터는 쓰기 작업을 처리하고, 슬레이브는 읽기 작업을 처리하거나 마스터의 백업 역할을 합니다. 마스터에서 발생한 데이터 변경사항은 슬레이브에 복제되어, 데이터의 일관성이 유지됩니다. 이 구조의 핵심은 한 서버(Master)에서 데이터 변경이 일어나고, 다른 서버(Slave)에서 이 변경사항이 반영되는 것입니다.
- 반면에, 클러스터링은 여러 노드가 하나의 단일 시스템처럼 동작하도록 하는 것을 목표로 합니다. 클러스터에 속한 모든 노드는 동일한 작업을 수행할 수 있으며, 요청은 클러스터 내의 모든 노드에 분산되어 처리됩니다. 이 구조의 핵심은 모든 노드가 동등한 역할을 하고, 작업을 공유하는 것입니다.
- 따라서, 마스터-슬레이브 복제는 데이터의 일관성과 가용성을 중요시하는 시스템에서 주로 사용되며, 클러스터링은 높은 성능과 확장성을 요구하는 시스템에서 주로 사용됩니다. 이 두 구조는 서로 배타적인 것이 아니라, 상황에 따라 적절히 조합하여 사용할 수 있습니다.

</div>
</details>
<details>
<summary>Partitioning과 Sharding의 차이점은 무엇인가요?</summary>
<div markdown="1">

- 파티셔닝(Partitioning)과 샤딩(Sharding)은 모두 대량의 데이터를 관리하고 처리 성능을 향상시키기 위한 데이터 분할 기법이지만, 사용되는 범위와 목적에 차이가 있습니다.
- 파티셔닝은 하나의 데이터베이스 내에서 테이블을 논리적으로나 물리적으로 분할하는 기법입니다. 대용량의 테이블을 작은 파티션으로 나눔으로써 쿼리 성능을 향상시키고, 데이터 관리를 용이하게 합니다. 파티셔닝은 주로 범위 파티셔닝(Range Partitioning), 리스트 파티셔닝(List Partitioning), 해시 파티셔닝(Hash Partitioning) 등의 방법이 있습니다.
- 반면에, 샤딩은 데이터베이스를 여러 개의 더 작은 데이터베이스, 즉 '샤드'로 분할하는 기법입니다. 각 샤드는 독립적인 데이터베이스로서, 자체적인 데이터와 트랜잭션을 관리하며, 독립적으로 동작합니다. 샤딩은 분산 환경에서 데이터를 효율적으로 관리하고, 시스템의 확장성을 높이는 데 유용합니다.
- 따라서, 파티셔닝은 주로 하나의 데이터베이스 내에서 데이터의 관리와 성능 향상을 위해 사용되며, 샤딩은 여러 데이터베이스 간의 데이터 분산과 시스템의 확장성 향상을 위해 사용됩니다.

</div>
</details>
<details>
<summary>Sharding의 장점과 단점은 무엇인가요?</summary>
<div markdown="1">

- 샤딩(Sharding)은 데이터베이스를 여러 개의 더 작은 데이터베이스, 즉 '샤드'로 분할하는 기법입니다. 샤딩의 장점과 단점은 다음과 같습니다.
- 장점:
    1. 확장성: 샤딩은 데이터를 여러 데이터베이스에 분산시킴으로써, 시스템의 확장성을 높입니다. 새로운 샤드를 추가함으로써 시스템의 용량을 쉽게 확장할 수 있습니다.
    2. 성능 향상: 각 샤드는 독립적으로 동작하므로, 데이터베이스의 부하를 분산시키고 성능을 향상시킬 수 있습니다.
    3. 고가용성: 샤드 하나가 실패하더라도, 다른 샤드에서는 계속해서 서비스를 제공할 수 있습니다. 이를 통해 시스템의 가용성을 높일 수 있습니다.
- 단점:
    1. 복잡성: 샤딩은 데이터베이스 구조를 복잡하게 만듭니다. 샤딩 전략을 정하고, 샤드를 관리하며, 샤드 간의 데이터 일관성을 유지하는 것은 쉽지 않은 작업입니다.
    2. 데이터 재분배의 어려움: 데이터의 불균형이 발생하거나, 시스템이 확장되어 데이터를 재분배해야 할 때, 이는 복잡하고 시간이 많이 소요될 수 있습니다.
    3. 트랜잭션 처리의 어려움: 샤드 간의 분산 트랜잭션을 처리하는 것은 복잡하며, 성능에 부정적인 영향을 줄 수 있습니다.
- 따라서, 샤딩을 사용할지 결정할 때는 이러한 장단점을 고려해야 하며, 시스템의 요구사항과 데이터의 특성에 따라 적절한 샤딩 전략을 선택해야 합니다.

</div>
</details>
<details>
<summary>CAP 이론에 대해 설명해주세요.</summary>
<div markdown="1">

- CAP 이론은 분산 컴퓨팅 시스템에서 세 가지 속성, 즉 일관성(Consistency), 가용성(Availability), 그리고 네트워크 분할 허용성(Partition tolerance) 간의 관계를 설명하는 이론입니다.
1. 일관성(Consistency): 모든 노드가 같은 시점에서 데이터의 같은 값을 보여주는 것을 의미합니다. 즉, 어떤 노드에서든 언제든지 최신의 데이터를 읽을 수 있어야 합니다.
2. 가용성(Availability): 모든 요청이 성공 혹은 실패 결과를 반환해야 하며, 시스템은 항상 응답해야 한다는 것을 의미합니다. 즉, 모든 사용자의 요청이 항상 처리되어야 합니다.
3. 네트워크 분할 허용성(Partition tolerance): 네트워크가 노드들 사이에 분할되더라도 시스템이 계속 동작해야 한다는 것을 의미합니다. 즉, 시스템은 네트워크 분할, 즉 일부 노드 간의 통신이 불가능한 상황을 허용해야 합니다.
- CAP 이론은 이 세 가지 속성 중에서 동시에 세 가지를 모두 만족시킬 수 없다고 주장합니다. 즉, 일관성, 가용성, 네트워크 분할 허용성 중에서 두 가지만 선택할 수 있다는 것입니다. 따라서 분산 시스템을 설계할 때는 이 세 가지 속성 중에서 어떤 것을 중요시할지를 결정해야 합니다.

</div>
</details>
<details>
<summary>CAP 이론에서 일관성(Consistency), 가용성(Availability), 분할 허용성(Partition tolerance) 세 가지 중 어떤 것을 선택하면 좋을까요? 그 이유는 무엇인가요?</summary>
<div markdown="1">

- CAP 이론에서 일관성(Consistency), 가용성(Availability), 분할 허용성(Partition tolerance) 중 어떤 것을 선택할지는 시스템의 요구사항과 특성에 따라 달라집니다.
1. CP (Consistency + Partition tolerance): CP 모델은 일관성과 분할 허용성을 중시합니다. 네트워크 분할이 발생하더라도 모든 클라이언트가 동일한 데이터를 볼 수 있어야 합니다. 이 모델은 뱅킹, 금융 시스템 등 데이터의 일관성이 매우 중요한 시스템에서 적합합니다.
2. AP (Availability + Partition tolerance): AP 모델은 가용성과 분할 허용성을 중시합니다. 일관성을 희생하더라도 모든 요청에 대해 항상 응답을 제공하고, 네트워크 분할에도 서비스를 지속해야 합니다. 이 모델은 소셜 네트워킹, 실시간 메시징 등 서비스의 지속성이 중요한 시스템에서 적합합니다.
3. CA (Consistency + Availability): CA 모델은 일관성과 가용성을 중시합니다. 하지만, 이 모델은 네트워크 분할이 발생하지 않는다는 가정 하에만 유효하므로, 실제 분산 시스템에서는 거의 사용되지 않습니다.
- 따라서, 어떤 모델을 선택할지는 시스템의 요구사항에 따라 결정해야 합니다. 일관성이 더 중요한지, 가용성이 더 중요한지, 네트워크 분할이 발생할 가능성이 있는지 등을 고려해야 합니다.

</div>
</details>
<details>
<summary>Eventual Consistency에 대해서 설명해주세요.</summary>
<div markdown="1">

- Eventual Consistency(최종 일관성)는 분산 데이터베이스 시스템에서 널리 사용되는 일관성 모델입니다. 이 모델은 시스템이 일정 시간 동안 추가적인 업데이트를 받지 않는다면, 결국 모든 노드가 같은 값을 볼 수 있게 될 것이라는 개념을 의미합니다.
- 분산 시스템에서 모든 노드가 동시에 업데이트되는 것은 어렵거나 불가능할 때가 많습니다. 따라서, 시스템의 가용성을 높이기 위해 일시적으로 일관성을 희생하는 전략을 취하기도 합니다. 이러한 전략이 바로 Eventual Consistency입니다.
- 예를 들어, 사용자가 소셜 미디어에 게시물을 올렸을 때, 모든 사용자가 동시에 그 게시물을 볼 수는 없을 수 있습니다. 어떤 사용자는 즉시 볼 수 있지만, 다른 사용자는 몇 초 후에나 볼 수 있을지도 모릅니다. 하지만, 어떤 지점에서는 결국 모든 사용자가 그 게시물을 볼 수 있게 될 것입니다. 이것이 바로 Eventual Consistency의 개념입니다.
- Eventual Consistency 모델에서는 시스템의 가용성을 높이고, 분할 허용성을 보장하는 것을 우선시하며, 이를 위해 일시적으로 일관성을 희생합니다. 따라서, 이 모델은 사용자의 요청에 빠르게 응답해야 하며, 네트워크 지연이나 장애에 대처해야 하는 분산 시스템에서 주로 사용됩니다.

</div>
</details>


<br>

# 📍 Reference
- https://github.com/VSFe/Tech-Interview/blob/main/04-DATABASE.md
- https://github.com/dev-team-study/cs-study/tree/main/%5B1%ED%9A%8C%EC%B0%A8%5D1.database/05_MasterSlave_Sharding_NoSQL
- https://github.com/ksundong/backend-interview-question