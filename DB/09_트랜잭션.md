# DB - 트랜잭션

- 트랜잭션
    - 트랜잭션 개념
    - ACID
    - Commit, Rollback
    - 트랜잭션 격리수준
    - LOCK, 교착상태, 동시성
    - 트랜잭션 전파옵션

---

# 면접 질문

### 트랜잭션이란 무엇인지 설명해주세요.

**데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산들을 의미한다.**

하나의 트랜잭션은 Commit(작업완료)되거나 Rollback(취소)됨


### (꼬리질문) Commit과 Rollback에 대해 설명해주세요.

commit 연산

- 한 개의 논리적인 단위(트랜잭션)에 대한 작업이 성공적으로 끝나 데이터베이스가 다시 일관된 상태에 있을 때, 이 트랜잭션이 행한 갱신 연산이 완료된 것을 트랜잭션 관리자에게 알려주는 연산이다

 rollback 연산

- 하나의 트랜잭션 처리가 비정상적으로 종료되어 데이터베이스의 일관성을 깨뜨렸을 때, 이 트랜잭션의 일부가 정상적으로 처리되었더라도 트랜잭션의 원자성을 구현하기 위해 이 트랜잭션이 행한 모든 연산을 취소(undo)
        하는 연산
- rollback 시에는 해당 트랜잭션을 재시작하거나 폐기한다

### 트랜잭션의 특성(ACID)에 대해 설명해주세요.

1. 원자성(Atomicity) 작업이 모두 반영되던지 아니면 전혀 반영되지 않아야 한다.

2. 일관성(Consistency) 실행이 완료되면 언제나 일관성 있는 상태를 유지해야 한다.

3. 독립성(Isolation) 둘 이상 트랜잭션이 동시에 실행될 경우 서로의 연산에 끼어들 수 없다.

4. 영속성(Durability) 완료된 결과는 영구적으로 반영되어야 한다.

### **Isolation Level 은 무엇인가요 ?**

격리수준(isolation level)이란 트랜잭션끼리 **얼마나 서로 고립되어 있는지를 나타내는 수준**

즉, 한 트랜잭션이 **다른 트랜잭션이 변경한 데이터**에 대한 접근 강도를 의미

레벨이 높아질수록 트랜잭션간 고립정도가 높아지며, 성능저하도 야기됨.

일반적인 온라인 서비스에서는 `READ COMMITTED`나 `REPEATABLE READ` 중 하나를 사용

### **Isolation Level 의 종류에 대해서 설명해주세요.**

1)Read Uncommitted (레벨0) 

- 커밋되지 않는 읽기
- 트랜잭션 A가 특정 컬럼 데이터를 변경하고 있을 때(커밋하지 않은 상태) 트랜잭션 B가 read하면 트랜잭션 A가 변경한 데이터를 읽어온다.
- 커밋되지 않는 읽기는 dirty read 문제가 있다. (트랜잭션 A가 특정 컬럼 데이터를 변경하고 롤백 했을 때 발생)
- 데이터의 일관성을 유지할 수 없다.

2)Read Committed (레벨1) 

- 커밋된 읽기
- 트랜잭션 A가 특정 컬럼 데이터를 변경하고 있을 때(커밋하지 않은 상태) 트랜잭션 B가 read하면 트랜잭션 A가 변경하기 전 데이터를 읽어온다. 만약 트랜잭션 A가 데이터 변경 후 커밋하게 되면 트랜잭션 B는 변경된 데이터를 읽어온다.

3) Repeatable Read (레벨2) 

- 반복 가능한 읽기
- 항상 일관성 있는 데이터 읽기를 보장하는 레벨
- 다른 트랜잭션에서 데이터를 조작하여도 영향을 받지 않는다.

4)Serializable (레벨3) 

- 직렬화 가능
- 가장 높은 격리 수준
- 트랜잭션이 완료될 때까지 SELECT 문장이 사용하는 모든 데이터에 Shared Lock이 걸리므로 다른 사용자는 그 영역에 해당되는 데이터에 수정 및 입력이 불가능하다.


### Isolation이 안될 때 나타나는 현상에 대해 설명해주세요.
1. `Dirty Read`
    
    아직 **커밋(Commit)되지 않은** 다른 트랜잭션의 데이터를 읽는 것을 의미합니다.
    
2. `Non-repeatable Read`
    
    다른 트랜잭션이 커밋(Commit)한 데이터를 읽을 수 있는 것을 의미합니다.
    
    즉, 한 트랜잭션에서 같은 쿼리로 2번이상 조회했을 때 **그 결과가 상이한 상황**을 말합니다.
    
    보통 `데이터의 수정/삭제`가 발생했을 경우 발생합니다.
    
3. `Phantom Read`
    
    다른 트랜잭션이 커밋(Commit)한 데이터가 있더라도 자신의 트랜잭션에서 읽었던 내용만 사용하는 것을 의미합니다.
    
    즉, 한 트랜잭션에서 같은 쿼리를 2번이상 **조회했을 때 없던 결과가 조회**되는 상황을 말합니다.
    
    보통 `데이터의 삽입`이 발생했을 경우 발생합니다.
    

### DB 락의 종류에 대해서 설명해주세요.

DB 락은 여러 개의 트랜잭션들이 하나의 데이터로 동시에 접근하려고 할 때 이를 제어해주는 도구이다.

공유락(LS, Shared Lock): 트랜잭션이 읽기를 할 때 사용하는 락, 데이터를 읽을 수 있지만 쓸 수 없음

베타락(LX, Exclusive Lock): 트랜잭션이 읽고 쓰기를 할 때 사용하는 락, 데이터를 읽고 쓸 수 있음

### 데드락(DeadLock) 은 무엇인가요 ?

두 개 이상의 트랜잭션이 동시에 진행될 때 락을 소유한 상태로 대기 상태에 빠져 더 이상 진행하지 못하는 상황

T1 : write(A) read(B)

T2 : wirte(B) read(A)

위의 상황과 같이 T1과 T2가 병행 처리될 때, T1은 A에 대한 락을 소유하고 T2는 B에 대한 락을 소유한 상태로 각각 B와 A를 기다리는 대기 상태가 되어 무한정 대기하는 상황이 발생

### **데드락의 해결 방법에 대해서 설명해주세요.**

- 예방 - 각 트랜잭션이 실행되기 전 필요한 데이터를 모두 로킹(Locking), 하지만 병행성 보장 못함
- 회피 - 타임스탬프를 사용해 시간에 따라 먼저 들어왔을 경우 Wait 하거나 Die, 혹은 Wound 하거나 Wait (Wait-Die, Wound-Wait) 하는 방식들을 사용
- 탐지 - Union-Find 알고리즘 사용하여 사이클 존재 여부 확인, 사이클 탐지 -> 데드락 발생
- 이외에도 트랜잭션 진행방향 설정, 로킹(Locking) 해제 시간 조절 (LOCK_TIMEOUT) 등

### 트랜잭션 전파옵션에 대해서 설명해주세요.

REQUIRED : 트랜잭션이 필요함(없으면 새로 만듬)

기존 트랜잭션 없음: 새로운 트랜잭션을 생성함

기존 트랜잭션이 있음: 기존 트랜잭션에 참여함

REQUIRED는 디폴트 속성으로써 모든 트랜잭션 매니저가 지원하는 속성이다. 별도의 설정이 없다면 REQUIRED로 트랜잭션이 진행된다.

SUPPORTS : 트랜잭션이 있으면 지원함(트랜잭션이 없어도 됨)

기존 트랜잭션 없음: 트랜잭션 없이 진행함

기존 트랜잭션이 있음: 기존 트랜잭션에 참여함

MANDATORY : 트랜잭션이 의무임(트랜잭션이 반드시 필요함)

기존 트랜잭션 없음: IllegalTransactionStateException 예외 발생

기존 트랜잭션이 있음: 기존 트랜잭션에 참여함

REQUIRES_NEW : 항상 새로운 트랜잭션이 필요함

기존 트랜잭션 없음: 새로운 트랜잭션을 생성함

기존 트랜잭션이 있음: 기존 트랜잭션을 보류시키고 새로운 트랜잭션을 생성함

NOT_SUPPORTED : 트랜잭션을 지원하지 않음(트랜잭션 없이 진행함)

기존 트랜잭션 없음: 트랜잭션 없이 진행함기존 

트랜잭션이 있음: 기존 트랜잭션을 보류시키고 트랜잭션 없이 진행함

NEVER : 트랜잭션을 사용하지 않음(기존 트랜잭션도 허용하지 않음)기존 트랜잭션 없음: 트랜잭션 없이 진행기존 트랜잭션이 있음: IllegalTransactionStateException 예외 발생

NESTED : 중첩(자식) 트랜잭션을 생성함

기존 트랜잭션 없음: 새로운 트랜잭션을 생성함

기존 트랜잭션이 있음: 중첩 트랜잭션을 만든다.

NESTED는 이미 진행중인 트랜잭션에 중첩(자식) 트랜잭션을 만드는 것으로, 독립적인 트랜잭션을 만드는 REQUIRES_NEW와 다르다. NESTED에 의한 중첩 트랜잭션은 부모 트랜잭션의 영향(커밋과 롤백)을 받지만, 중첩 트랜잭션이 외부에 영향을 주지는 않는다.즉, 중첩 트랜잭션이 롤백 되어도 외부 트랜잭션은 커밋이 가능하지만 외부 트랜잭션이 롤백되면 중첩 트랜잭션은 함께 롤백되는 것이다. NESTED는 JDBC의 savepoint 기능을 사용하는데, DB 드라이버가 이를 지원하는지 확인이 필요하며 JPA에서 사용이 불가능하다.

## Ref

트랜잭션 : https://dev-coco.tistory.com/158

트랜잭션 격리 수준 : 

https://theheydaze.tistory.com/582 ,

https://snow-line.tistory.com/145

https://akasai.space/db/about_isolation/

DB락 : 

https://mangkyu.tistory.com/93

[https://velog.io/@syleemk/면접-대비-데이터베이스#데이터베이스-동시성-제어-방법](https://velog.io/@syleemk/%EB%A9%B4%EC%A0%91-%EB%8C%80%EB%B9%84-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4#%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EB%8F%99%EC%8B%9C%EC%84%B1-%EC%A0%9C%EC%96%B4-%EB%B0%A9%EB%B2%95)

데드락 : https://wadekang.tistory.com/51

트랜잭션 전파옵션 : 

https://steady-coding.tistory.com/610  

https://snow-line.tistory.com/146 

https://mangkyu.tistory.com/269
