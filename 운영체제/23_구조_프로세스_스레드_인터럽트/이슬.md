# 📍 키워드
- 운영체제 구조
    - 커널
    - 시스템 호출
- 프로세스
    - 프로세스 개념
    - 프로세스 상태
    - 프로세스 제어 블록
    - 프로세스 문맥 교환
- 스레드
    - 스레드 개념
    - 멀티스레드의 구조
    - 멀티스레드의 장단점
    - 멀티 프로세스 VS 멀티 스레드
- 인터럽트
    - 인터럽트 개념
    - 동기적 인터럽트, 비동기적 인터럽트
    - 인터럽트 처리 과정
    - 인터럽트와 이중 모드
<br>

# 📍 예상 질문
<details>
<summary>운영체제의 구조에 대해 설명해주세요.</summary>
<div markdown="1">

- 운영체제는 컴퓨터 시스템의 자원을 관리하고, 사용자와 컴퓨터 하드웨어 간의 인터페이스 역할을 수행하는 소프트웨어입니다. 운영체제의 구조는 크게 커널, 시스템 호출, 사용자 모드와 커널 모드 등으로 나눌 수 있습니다.
1. 커널(Kernel): 커널은 운영체제의 핵심 부분으로, 시스템의 모든 중요한 부분을 관리합니다. 프로세스 관리, 메모리 관리, 파일 시스템 관리, 장치 관리 등의 기능을 담당합니다. 커널은 항상 메모리에 상주하며, 시스템의 안정성과 효율성을 보장하는 역할을 합니다.
2. 시스템 호출(System Calls): 사용자 프로그램이 커널의 기능을 이용하고자 할 때 사용하는 인터페이스입니다. 시스템 호출을 통해 프로그램은 파일을 생성하거나 네트워크 통신, 프로세스 생성과 같은 운영체제의 서비스를 요청할 수 있습니다. 예를 들어, read(), write(), open() 등이 시스템 호출의 예입니다.
3. 사용자 모드와 커널 모드: 운영체제는 보안과 안정성을 위해 두 가지 모드를 제공합니다. 사용자 모드에서는 제한된 접근 권한으로 실행되며, 커널 모드에서는 운영체제가 전체 시스템 자원에 접근할 수 있습니다. 프로그램이 시스템 호출을 사용하여 운영체제의 기능을 요청하면, 시스템은 사용자 모드에서 커널 모드로 전환하여 요청을 처리한 후 다시 사용자 모드로 돌아옵니다.

</div>
</details>
<details>
<summary>커널에 대해 설명해주세요.</summary>
<div markdown="1">

- 운영체제의 커널은 시스템의 핵심 부분으로, 하드웨어와 소프트웨어 간의 통신을 관리하고, 시스템 자원을 효율적으로 관리하는 역할을 합니다. 커널은 운영체제의 구성 요소 중 가장 중요한 부분이며, 다음과 같은 주요 역할을 수행합니다.
1. 프로세스 관리: 커널은 시스템에서 실행되는 모든 프로세스를 관리합니다. 이에는 프로세스의 생성과 종료, 스케줄링, 프로세스 간의 동기화 및 통신 등이 포함됩니다. 커널은 다양한 프로세스가 공정하게 CPU 시간을 할당받도록 관리합니다.
2. 메모리 관리: 커널은 시스템의 물리적 메모리를 관리하며, 각 프로세스에 메모리 공간을 할당하고 회수합니다. 가상 메모리 관리를 통해 실제 물리적 메모리보다 더 많은 메모리를 프로세스가 사용할 수 있도록 지원합니다.
3. 파일 시스템 관리: 커널은 파일 시스템을 통해 데이터의 저장과 검색을 관리합니다. 파일과 디렉토리의 생성, 삭제, 읽기, 쓰기 등의 기능을 제공하여, 사용자와 프로그램이 데이터를 쉽게 저장하고 접근할 수 있도록 합니다.
4. 장치 관리: 커널은 시스템의 모든 하드웨어 장치를 관리합니다. 장치 드라이버와의 통신을 통해 입력/출력 요청을 처리하고, 장치 간의 데이터 전송을 조정합니다.
5. 네트워크 관리: 커널은 네트워크 통신을 위한 프로토콜 스택을 제공하며, 데이터의 송수신을 관리합니다. 네트워크 장치 드라이버와 협력하여 네트워크 통신을 가능하게 합니다.

</div>
</details>
<details>
<summary>시스템 호출에 대해 설명해주세요.</summary>
<div markdown="1">

- 시스템 호출(System Call)은 응용 프로그램이 운영체제의 커널 기능을 이용할 수 있도록 하는 인터페이스입니다. 일반적으로, 응용 프로그램은 직접 하드웨어를 제어할 권한이 없기 때문에, 운영체제의 서비스를 요청하기 위해 시스템 호출을 사용합니다. 이를 통해 파일 시스템 관리, 프로세스 관리, 통신 등의 작업을 안전하고 효율적으로 수행할 수 있습니다.
- 시스템 호출의 주요 기능
    1. 프로세스 관리: 프로세스의 생성과 종료, 프로세스 간 통신, 프로세스 스케줄링 등을 관리합니다. 예를 들어, fork() 시스템 호출은 새로운 프로세스를 생성합니다.
    2. 파일 관리: 파일을 생성, 삭제, 읽기, 쓰기 등의 파일 시스템 관련 작업을 수행합니다. 예를 들어, open(), read(), write(), close() 등의 시스템 호출이 있습니다.
    3. 장치 관리: 하드웨어 장치에 대한 접근과 제어를 가능하게 합니다. 장치 드라이버와의 인터페이스 역할을 하며, 데이터의 입출력 작업을 관리합니다.
    4. 메모리 관리: 프로세스에 메모리 할당 및 해제를 관리합니다. 가상 메모리 시스템과 관련된 작업도 시스템 호출을 통해 수행됩니다.
    5. 통신: 네트워크 통신이나 프로세스 간 통신(IPC)을 위한 시스템 호출이 제공됩니다. 소켓 생성, 데이터 송수신 등의 작업을 포함합니다.

</div>
</details>
<details>
<summary>시스템 호출이 실행되는 과정을 설명해주세요.</summary>
<div markdown="1">

- 1단계: 시스템 호출 요청
    - 응용 프로그램은 특정 작업(예: 파일 열기, 프로세스 생성 등)을 수행하기 위해 운영체제에 서비스를 요청해야 할 때 시스템 호출을 사용합니다. 이는 대개 API 형태로 제공되며, 프로그램은 이 API를 호출함으로써 시스템 호출을 요청합니다.
- 2단계: 사용자 모드에서 커널 모드로의 전환
    - 시스템 호출이 요청되면, CPU는 사용자 모드(User Mode)에서 커널 모드(Kernel Mode)로 전환됩니다. 이는 운영체제가 제어권을 가지고 시스템 호출을 처리할 수 있도록 합니다. 커널 모드에서는 운영체제가 시스템의 모든 자원에 접근할 수 있으며, 보안과 안정성을 위해 제한된 접근만 허용됩니다.
- 3단계: 시스템 호출의 처리
    - 커널 모드로 전환된 후, 운영체제의 커널은 요청된 시스템 호출을 식별하고 처리합니다. 이 과정에서 커널은 필요한 매개변수를 검사하고, 요청된 작업을 수행하기 위해 하드웨어 리소스에 접근할 수 있습니다. 작업의 종류에 따라 파일 시스템 접근, 프로세스 관리, 메모리 할당 등 다양한 작업이 수행될 수 있습니다.
- 4단계: 결과 반환 및 커널 모드에서 사용자 모드로의 전환
    - 작업이 완료되면, 결과가 응용 프로그램에 반환됩니다. 성공, 실패, 또는 어떤 결과 데이터도 함께 반환될 수 있습니다. 이후, CPU는 다시 사용자 모드로 전환되어 응용 프로그램의 실행을 계속합니다.
- 5단계: 요청한 작업의 후속 처리
    - 응용 프로그램은 시스템 호출의 결과를 받고, 필요한 후속 처리를 수행합니다. 예를 들어, 파일 열기 요청이 성공했다면, 응용 프로그램은 반환된 파일 디스크립터를 사용하여 파일에 대한 읽기나 쓰기 작업을 수행할 수 있습니다.

</div>
</details>
<details>
<summary>시스템 호출의 유형에 대해 설명해주세요.</summary>
<div markdown="1">

1. 프로세스 제어(Process Control)
프로세스의 생성, 실행, 종료 및 속성 변경과 관련된 시스템 호출입니다. 예를 들어, 새로운 프로세스를 생성하기 위한 fork()나 exec(), 프로세스를 종료하기 위한 exit(), 실행을 일시 중지하고 재개하기 위한 wait() 등이 있습니다. 이 유형의 시스템 호출은 프로세스의 생명 주기와 직접적으로 관련되어 있습니다.

2. 파일 조작(File Manipulation)
파일 생성, 삭제, 열기, 닫기, 읽기, 쓰기 및 속성 변경 등 파일 시스템과 관련된 작업을 수행합니다. open(), read(), write(), close(), unlink() 등의 호출이 여기에 포함됩니다. 이 유형은 데이터의 저장과 검색을 위해 필수적입니다.

3. 장치 관리(Device Management)
시스템에 연결된 장치들(예: 하드 드라이브, 프린터, 디스플레이 등)을 효율적으로 관리하기 위한 시스템 호출입니다. 장치를 열고, 읽고, 쓰고, 제어하는 작업을 포함합니다. 장치 드라이버와의 상호작용을 위한 ioctl() 같은 호출이 이 범주에 속합니다.

4. 정보 유지(Information Maintenance)
시스템의 상태 정보나 시간, 프로세스 정보 등을 조회하거나 설정하는 시스템 호출입니다. 예를 들어, 시스템 시간을 가져오거나 설정하기 위한 time()과 stime(), 프로세스의 속성을 조회하기 위한 getpid()(현재 프로세스의 ID를 얻기 위한 호출) 등이 있습니다.

5. 통신(Communication)
프로세스 간 통신(IPC)이나 네트워크 통신을 위한 시스템 호출입니다. 메시지 전송, 신호(signal) 처리, 소켓 통신 등을 위한 send(), receive(), socket(), bind(), connect() 등의 호출이 포함됩니다. 이 유형은 데이터의 교환 및 동기화를 가능하게 합니다.

6. 보안(Security)
시스템의 보안과 관련된 작업을 수행합니다. 사용자 인증, 권한 설정 및 검사 등을 위한 시스템 호출이 여기에 속합니다. 예를 들어, 파일이나 다른 자원에 대한 접근 권한을 설정하거나 검사하기 위한 호출이 이 범주에 포함될 수 있습니다.

</div>
</details>
<details>
<summary>유저모드와 커널모드를 구분해야 하는 이유는 무엇인가요?</summary>
<div markdown="1">

- 유저 모드와 커널 모드로 나눈 이유는 유저 프로그램과 커널을 분리시키기 위해서 입니다.  유저 프로그램은 파일을 읽는다거나 프로세스가 생성되는 내부 동작을 신경쓸 필요 없기 때문입니다. 보안이 강화됩니다. 신뢰 할 수 없는 유저가 운영체제의 서비스를 쉽게 조작하는 걸 방지 할 수 있습니다.
- 보안
    - 제한된 접근: 유저모드에서 실행되는 응용 프로그램은 직접적으로 하드웨어에 접근할 수 없습니다. 이는 악의적인 소프트웨어가 시스템을 손상시키거나, 민감한 데이터를 무단으로 접근하는 것을 방지합니다.
    - 권한 분리: 필요한 경우에만 커널모드의 권한을 부여함으로써, 운영체제는 보안을 강화하고 잠재적인 위협으로부터 시스템을 보호할 수 있습니다.
- 안정성
    - 오류 격리: 유저모드에서 실행되는 프로그램이 실패하더라도, 시스템 전체에 영향을 미치지 않고 해당 프로그램만 종료됩니다. 이는 시스템의 전반적인 안정성을 보장합니다.
    - 자원 보호: 커널모드는 시스템 자원과 중요한 작업을 관리합니다. 유저모드와의 구분을 통해, 응용 프로그램이 시스템 자원을 무분별하게 사용하거나 변경하는 것을 방지합니다.

</div>
</details>
<details>
<summary>프로세스와 스레드의 차이점은 무엇인가요?</summary>
<div markdown="1">

- 프로세스(Process)
    - 프로세스는 운영 체제에서 실행 중인 프로그램의 인스턴스입니다. 각 프로세스는 독립된 메모리 주소 공간을 가지며, 최소 하나의 실행 흐름(스레드)을 포함합니다. 프로세스는 다음과 같은 특징을 가집니다:
    - 독립성: 프로세스는 서로 독립적인 메모리 주소 공간을 가지므로, 하나의 프로세스가 다른 프로세스의 자원에 직접 접근하는 것은 허용되지 않습니다.
    - 자원의 소유: 프로세스는 실행에 필요한 코드, 데이터, 시스템 자원 등을 소유합니다.
    - 통신과 동기화: 프로세스 간 통신(IPC)을 통해 데이터를 교환하고, 동기화를 수행할 수 있습니다.
- 스레드(Thread)
    - 스레드는 프로세스 내에서 실행되는 여러 실행 흐름 중 하나로, 프로세스의 자원을 공유하며 동작합니다. 스레드는 다음과 같은 특징을 가집니다:
    - 경량 프로세스: 스레드는 프로세스보다 생성, 종료, 문맥 교환(Context Switch) 비용이 더 적습니다.
    - 자원 공유: 같은 프로세스 내의 스레드들은 코드, 데이터, 힙 영역 등을 공유합니다. 그러나 각 스레드는 자신만의 스택(지역 변수, 실행 컨텍스트)과 레지스터 상태를 갖습니다.
    효율적인 통신과 동기화: 같은 프로세스 내의 스레드들은 메모리를 공유하기 때문에, IPC 없이도 데이터를 교환할 수 있으며, 동기화 메커니즘(예: 뮤텍스, 세마포어)을 통해 동기화를 수행할 수 있습니다.
- 프로세스와 스레드의 주요 차이점
    - 메모리 공간과 자원의 공유: 프로세스는 독립적인 메모리 공간을 가지고 자원을 소유하는 반면, 스레드는 같은 프로세스 내에서 메모리와 자원을 공유합니다.
    - 생성과 관리 비용: 스레드의 생성, 종료, 문맥 교환 비용이 프로세스보다 낮습니다.
    - 통신과 동기화: 프로세스 간 통신은 복잡하고 비용이 많이 드는 반면, 스레드 간 통신은 자원을 공유하기 때문에 더 효율적입니다.

</div>
</details>
<details>
<summary>프로세스의 상태는 어떻게 변화하나요?</summary>
<div markdown="1">

1. 생성(New): 프로세스가 생성되고 초기화되는 상태입니다. 이 상태의 프로세스는 실행을 위한 자원 할당 등의 준비 과정을 거칩니다.
2. 준비(Ready): 프로세스가 CPU에서 실행될 준비가 완료되었으나, 실제로 CPU를 할당받지는 못한 상태입니다. 준비 상태의 프로세스는 CPU 할당을 기다리는 준비 큐에 위치합니다.
3. 실행(Running): 프로세스가 CPU를 할당받아 명령어를 실행하는 상태입니다. 프로세스는 이 상태에서 실제 작업을 수행합니다.
4. 대기(Waiting) 또는 차단(Blocked): 프로세스가 입출력 작업과 같은 특정 이벤트의 완료를 기다리는 상태입니다. 이 상태의 프로세스는 CPU를 사용할 수 없으며, 대기 상태에서 준비 상태로 전환되기 위해서는 대기 중인 이벤트가 완료되어야 합니다.
5. 종료(Terminated) 또는 완료(Exit): 프로세스가 실행을 완료하고 시스템에서 제거된 상태입니다. 프로세스가 자원을 모두 반환하고, 운영 체제가 프로세스의 정보를 정리합니다.

- 프로세스 상태 변화 과정
    1. 생성 → 준비: 프로세스가 시스템에 의해 생성되어 실행을 위한 준비가 완료되면 준비 상태로 전환됩니다.
    2. 준비 → 실행: 프로세스 스케줄러가 준비 큐에서 프로세스를 선택하여 CPU를 할당하면 실행 상태로 전환됩니다.
    3. 실행 → 대기: 프로세스가 입출력 작업과 같은 대기가 필요한 이벤트를 만나면 대기 상태로 전환됩니다.
    4. 대기 → 준비: 대기 중인 이벤트가 완료되면 프로세스는 다시 CPU 할당을 위해 준비 상태로 전환됩니다.
    5. 실행 → 준비: 시간 할당량(타임 슬라이스)이 완료되거나 더 높은 우선순위의 프로세스가 준비되면, 현재 실행 중인 프로세스는 준비 상태로 전환될 수 있습니다.
    6. 실행 → 종료: 프로세스가 작업을 완료하고 종료하면, 시스템에서 프로세스를 종료 상태로 전환합니다.

</div>
</details>
<details>
<summary>프로세스 제어 블록(PCB)는 무엇이며, 어떤 정보가 담겨 있나요?</summary>
<div markdown="1">

- 프로세스 제어 블록(Process Control Block, PCB)은 운영 체제가 각 프로세스를 관리하기 위해 사용하는 중요한 데이터 구조입니다. PCB는 특정 프로세스에 대한 모든 중요 정보를 저장하며, 프로세스가 CPU를 할당받을 때 실행 상태로 전환되거나 실행을 멈출 때 필요한 정보를 제공합니다. 운영 체제는 프로세스의 생성 시점에 해당 프로세스의 PCB를 생성하고, 프로세스가 종료되면 PCB를 삭제합니다.

1. 프로세스 식별자(Process Identifier, PID): 프로세스의 고유 식별 번호입니다. 이 번호를 통해 각 프로세스를 구별합니다.
2. 프로세스 상태 정보: 현재 프로세스의 상태(준비, 실행, 대기 등)를 나타냅니다.
3. 프로그램 카운터(Program Counter, PC): 프로세스가 다음에 실행할 명령어의 주소를 가리킵니다.
4. CPU 레지스터 정보: 프로세스가 실행 중일 때 필요한 레지스터 세트의 복사본입니다. 이 정보는 문맥 교환(Context Switch) 시 저장되고 복원됩니다.
5. CPU 스케줄링 정보: 프로세스 우선순위, 스케줄링 큐에 대한 포인터, 기타 스케줄링 파라미터 등이 포함됩니다.
6. 메모리 관리 정보: 프로세스의 주소 공간, 페이지 테이블, 세그먼트 테이블 등 메모리 관리와 관련된 정보입니다.
7. 계정 정보: CPU 사용 시간, 실제 사용 시간, 프로세스 제한 시간 등 프로세스의 계정과 관련된 정보입니다.
8. 입출력 상태 정보: 프로세스에 할당된 입출력 장치, 열린 파일 목록 등 입출력 관련 정보입니다.

</div>
</details>
<details>
<summary>프로세스 문맥 교환(context switch)이란 무엇이며, 어떤 경우에 발생하나요?</summary>
<div markdown="1">

- 프로세스 문맥 교환(context switch)은 운영 체제가 한 프로세스의 실행을 중지하고 다른 프로세스를 실행하는 과정을 말합니다. 이 과정에서 운영 체제는 현재 실행 중인 프로세스의 상태(문맥)를 저장하고, 다음에 실행할 프로세스의 상태를 불러옵니다. 프로세스의 상태는 프로세스 제어 블록(PCB)에 저장되며, 이 정보에는 프로그램 카운터, 레지스터 값, 메모리 관리 정보 등이 포함됩니다.
- 문맥 교환은 CPU를 효율적으로 사용하고, 다중 프로그래밍 및 시분할 시스템을 가능하게 하는 핵심적인 운영 체제 기능입니다. 문맥 교환은 다음과 같은 경우에 발생할 수 있습니다:
1. 시간 할당량(타임 슬라이스) 만료
    - 대부분의 운영 체제에서 프로세스는 할당된 시간 동안만 CPU를 사용할 수 있습니다. 이 시간을 타임 슬라이스라고 하며, 타임 슬라이스가 만료되면 다음 프로세스로 전환합니다.
2. 입출력 요청 또는 입출력 완료
    - 프로세스가 입출력 작업을 요청하면, 입출력 작업이 완료될 때까지 CPU를 사용할 수 없으므로 다른 프로세스로 전환합니다. 입출력 작업이 완료되면, 해당 프로세스는 다시 CPU를 할당받을 수 있습니다.
3. 우선순위 변경
    - 운영 체제는 우선순위 기반 스케줄링을 사용할 수 있습니다. 실행 중인 프로세스보다 높은 우선순위를 가진 프로세스가 준비 상태가 되면, 운영 체제는 현재 프로세스를 중지하고 더 높은 우선순위의 프로세스로 전환할 수 있습니다.
4. 프로세스 종료 또는 대기 상태 전환
    - 프로세스가 종료되거나 대기 상태(예: 특정 이벤트 또는 데이터를 기다리는 상태)로 전환될 때, 운영 체제는 다른 프로세스로 전환합니다.

</div>
</details>
<details>
<summary>프로세스와 스레드는 컨텍스트 스위칭이 발생했을 때 어떤 차이가 있을까요?</summary>
<div markdown="1">

- 프로세스 컨텍스트 스위칭
    - 프로세스 간의 컨텍스트 스위칭은 상대적으로 비용이 많이 드는 작업입니다. 프로세스가 완전히 독립된 메모리 공간을 가지고 있기 때문에, 컨텍스트 스위칭 시 운영 체제는 현재 실행 중인 프로세스의 상태(레지스터 정보, 프로그램 카운터 등)를 저장하고, 다음에 실행할 프로세스의 상태를 메모리에서 불러와 CPU 레지스터에 로드해야 합니다. 또한, 메모리 관리 단위에서 페이지 테이블 등의 정보를 교체해야 하므로, 메모리 접근 패턴이 완전히 바뀌게 됩니다.
- 스레드 컨텍스트 스위칭
    - 스레드 간의 컨텍스트 스위칭은 프로세스 간 스위칭보다 덜 비용이 듭니다. 스레드는 같은 프로세스 내에서 실행되므로 메모리 공간(코드, 데이터, 힙 등)을 공유합니다. 따라서 스레드 간에 컨텍스트 스위칭을 할 때, 메모리 공간의 교체가 필요 없으며, 주로 CPU 레지스터와 스택, 프로그램 카운터 등의 변경이 이루어집니다. 스레드는 이미 메모리 공간을 공유하고 있기 때문에, 메모리 관련 정보를 새로 불러올 필요가 없어 프로세스 간 스위칭보다 훨씬 빠르게 수행됩니다.
- 요약
    - 프로세스 간 컨텍스트 스위칭은 메모리 공간 전체(페이지 테이블 등)를 교체해야 하므로 비용이 많이 듭니다.
    - 스레드 간 컨텍스트 스위칭은 같은 프로세스 내에서 이루어지므로 메모리 공간을 교체할 필요가 없고, 레지스터와 스택, 프로그램 카운터만 교체하면 되므로 상대적으로 비용이 적게 듭니다.

</div>
</details>
<details>
<summary>스레드란 무엇이며, 프로세스와 어떻게 다른가요?</summary>
<div markdown="1">

- 스레드는 프로세스 내의 실행 단위로, 프로세스의 자원을 사용하여 실행됩니다. 간단히 말해, 스레드는 프로세스 안에서 실제로 작업을 수행하는 주체입니다. 프로세스는 실행 중인 프로그램의 인스턴스로, 운영 체제로부터 자원을 할당받아 작동합니다. 이때, 프로세스는 최소 하나 이상의 스레드(주 스레드)를 가지며, 추가적으로 더 많은 스레드를 생성할 수 있습니다.
- 프로세스와 스레드의 주된 차이점은 다음과 같습니다:
    1. 자원 공유: 프로세스 간에는 각각 독립된 메모리 공간(코드, 데이터, 힙, 스택 등)이 있어서, 한 프로세스의 자원을 다른 프로세스가 직접 접근할 수 없습니다. 반면, 같은 프로세스에 속한 스레드들은 메모리 공간을 공유하며, 데이터 섹션, 코드 섹션, 열린 파일과 같은 자원을 서로 공유할 수 있습니다. 단, 각 스레드는 자신만의 스택 공간(로컬 변수와 함수 호출을 위한 공간)을 가집니다.
    2. 통신: 프로세스 간 통신(IPC)은 프로세스들이 서로 데이터를 주고받기 위해 사용하는 메커니즘으로, 파이프, 소켓, 공유 메모리 등을 포함합니다. 이런 통신 방법은 상대적으로 복잡하고 오버헤드가 큽니다. 반면, 스레드 간 통신은 같은 프로세스의 메모리 공간을 공유하기 때문에, 전역 변수를 통해 간단하게 데이터를 주고받을 수 있습니다.
    3. 생성과 관리 비용: 프로세스를 생성하고 관리하는 비용은 스레드를 생성하고 관리하는 비용보다 훨씬 큽니다. 프로세스는 완전히 독립된 메모리 공간을 할당받아야 하며, 운영 체제의 커널은 프로세스 관리를 위해 더 많은 작업을 수행해야 합니다. 반면, 스레드는 이미 존재하는 프로세스의 자원을 활용하기 때문에 생성과 관리가 더 경제적입니다.
    4. 성능: 멀티스레딩은 멀티프로세싱에 비해 메모리와 자원의 효율적인 사용으로 인해 성능 이점을 가질 수 있습니다. 스레드 간의 컨텍스트 스위칭은 프로세스 간 컨텍스트 스위칭보다 훨씬 빠르고 효율적입니다.
- 요약하자면, 스레드는 프로세스 내에서 실행되는 경량 프로세스로, 다른 스레드와 메모리 및 자원을 공유합니다. 이는 스레드가 효율적인 자원 사용과 빠른 통신을 가능하게 하지만, 동시성 관리를 위한 추가적인 주의가 필요합니다.

</div>
</details>
<details>
<summary>멀티스레드 프로그래밍에서의 스레드의 구조는 어떻게 되나요?</summary>
<div markdown="1">

- 스레드가 공유하는 부분
    1. 코드 섹션: 프로세스의 실행 가능한 코드. 모든 스레드는 같은 프로세스의 코드 섹션에 있는 함수나 명령어를 실행할 수 있습니다.
    2. 데이터 섹션: 전역 변수 같은 데이터를 포함합니다. 모든 스레드는 이러한 데이터에 접근하고 수정할 수 있습니다.
    3. 힙 섹션: 동적으로 할당된 메모리가 위치하는 곳입니다. 모든 스레드는 동적 할당된 객체나 변수를 공유할 수 있습니다.
- 스레드마다 독립적으로 가지는 부분
    1. 스레드 ID: 각 스레드를 식별하는 고유한 식별자입니다.
    2. 스택: 함수 호출 시 전달되는 매개변수, 반환 주소, 지역 변수 등을 저장하는 메모리 영역입니다. 각 스레드는 자신만의 스택을 가지며, 이는 스레드가 함수를 독립적으로 호출하고 실행할 수 있게 합니다.
    3. 프로그램 카운터(PC): 스레드가 현재 실행 중인 코드의 주소를 가리킵니다. 각 스레드는 다른 실행 포인트에서 작업을 수행할 수 있으므로, 각자의 프로그램 카운터를 가집니다.
    4. 레지스터 세트: CPU 레지스터의 상태를 가리키며, 스레드의 현재 작업 상태를 반영합니다. 각 스레드는 독립적인 레지스터 세트를 가지고 실행됩니다.
- 요약
    - 멀티스레드 프로그래밍에서 각 스레드는 독립적인 스택, 프로그램 카운터, 레지스터 세트를 가지며, 코드 섹션, 데이터 섹션, 힙 섹션을 같은 프로세스 내의 다른 스레드와 공유합니다. 이 구조는 스레드가 효율적으로 실행될 수 있도록 하면서도, 필요한 경우 서로 통신하고 데이터를 공유할 수 있는 유연성을 제공합니다. 그러나 공유 자원에 대한 접근은 동기화를 필요로 하며, 이는 멀티스레드 프로그래밍의 복잡성을 증가시킬 수 있습니다.

</div>
</details>
<details>
<summary>멀티스레드의 장점과 단점은 무엇인가요?</summary>
<div markdown="1">

- 멀티스레드의 장점
    1. 자원의 효율적 사용: 멀티스레드는 하나의 프로세스 내에서 자원(메모리, 데이터 등)을 공유하기 때문에, 여러 프로세스를 사용하는 것보다 시스템 자원을 더 효율적으로 사용할 수 있습니다.
    2. 응답성 향상: 멀티스레드를 사용하면, 하나의 스레드가 블로킹(예: 입출력 작업) 되어도 다른 스레드가 계속 작업을 수행할 수 있어 응용 프로그램의 응답성이 향상됩니다.
    3. 성능 개선: 멀티코어 또는 멀티프로세서 시스템에서 멀티스레드는 병렬 처리를 통해 애플리케이션의 성능을 크게 개선할 수 있습니다.
    4. 개발의 용이성: 프로그램을 여러 작업으로 나누어 동시에 실행하도록 설계함으로써, 복잡한 문제를 더 쉽게 관리하고 해결할 수 있습니다.
- 멀티스레드의 단점
    1. 동기화 문제: 공유 자원에 대한 접근을 관리하기 위해 동기화 메커니즘이 필요하며, 이는 프로그래밍을 복잡하게 만듭니다. 잘못된 동기화는 데이터의 불일치, 데드락 등의 문제를 일으킬 수 있습니다.
    2. 디버깅의 어려움: 스레드는 동시에 실행되기 때문에, 재현하기 어려운 버그가 발생할 수 있으며, 디버깅이 일반적인 순차적 프로그래밍보다 훨씬 어렵습니다.
    3. 자원 경쟁: 멀티스레드 프로그램은 스레드 간에 CPU 시간과 같은 자원을 경쟁하게 되며, 이로 인해 성능 저하가 발생할 수 있습니다.
    4. 오버헤드: 스레드의 생성, 컨텍스트 스위칭 및 동기화로 인한 오버헤드가 발생할 수 있으며, 이는 특히 스레드가 많을 때 눈에 띄게 됩니다.

</div>
</details>
<details>
<summary>멀티 프로세스와 멀티 스레드의 차이점은 무엇이며, 어떤 상황에서 각각을 사용하는 것이 더 적합한가요?</summary>
<div markdown="1">

- 멀티 프로세스
    - 멀티 프로세스는 여러 개의 독립된 프로세스가 동시에 실행되는 방식입니다. 각 프로세스는 독립된 메모리 공간을 가지며, 다른 프로세스의 자원에 직접 접근할 수 없습니다. 프로세스 간 통신(IPC)을 통해 데이터를 교환합니다.
    - 멀티 프로세스의 주요 특징:
        - 높은 안정성: 하나의 프로세스에 문제가 발생해도 다른 프로세스에는 영향을 미치지 않습니다.
        - 자원 사용량이 더 많음: 독립된 메모리 공간을 사용하기 때문에, 비슷한 작업을 처리할 때 멀티 스레드보다 더 많은 메모리와 CPU 자원을 소모합니다.
        - 프로세스 간 통신 비용이 높음: 프로세스 간 데이터를 교환하기 위한 IPC는 상대적으로 복잡하고 오버헤드가 큽니다.
    - 멀티 프로세스가 적합한 상황:
        - 각 작업이 서로 독립적이고, 하나의 작업 실패가 다른 작업에 영향을 미치지 않아야 할 때
        - 높은 안정성과 격리가 필요한 애플리케이션에서
- 멀티 스레드
    - 멀티 스레드는 하나의 프로세스 내에서 여러 스레드가 동시에 실행되는 방식입니다. 스레드들은 프로세스의 메모리 공간을 공유하며, 따라서 데이터 공유와 통신이 더 쉽고 빠릅니다.
    - 멀티 스레드의 주요 특징:
        - 공유 메모리: 스레드 간에 메모리 공간(데이터 섹션, 코드 섹션)을 공유하기 때문에 데이터 교환과 통신이 간편합니다.
        - 더 낮은 자원 사용량: 동일한 프로세스 내 스레드들이기 때문에, 프로세스를 여러 개 실행하는 것보다 메모리와 CPU 자원을 효율적으로 사용합니다.
        - 동기화 문제: 공유 자원에 대한 접근을 동기화해야 하므로, 복잡도가 증가하고 디버그가 어려울 수 있습니다.
    - 멀티 스레드가 적합한 상황:
        - 자원의 효율적 사용과 빠른 응답 시간이 필요한 경우
        - 여러 작업이 서로 정보를 공유하면서 동작해야 하는 경우
        - 응용 프로그램의 다양한 부분이 서로 긴밀하게 협력해야 할 때

</div>
</details>
<details>
<summary>스레드에서의 동시성과 병렬성에 대해 설명해주세요.</summary>
<div markdown="1">

- 동시성 : 논리적인 동시성 개념입니다. context switching이 빠르게 일어나면서 프로그램이 동시에 수행되는 것처럼 보이는 것입니다. (실제 동시 실행은 아닙니다.)
    - 하나의 CPU에서 멀티스레드로 작업을 수행하는 경우입니다.
- 병렬성 : 물리적 동시성 개념입니다. 실제로 동시에 여러 작업이 수행되는 현상입니다.
    - 여러개의 CPU에서 멀티스레드로 작업을 수행하는 경우입니다.

</div>
</details>
<details>
<summary>인터럽트란 무엇이며, 왜 필요한가요?</summary>
<div markdown="1">

- 인터럽트는 컴퓨터의 CPU가 현재 진행 중인 작업을 잠시 중단하고, 급하게 처리해야 할 다른 작업(인터럽트 요청이 발생한 작업)을 먼저 처리한 후 원래의 작업으로 돌아가는 메커니즘을 말합니다. 인터럽트는 하드웨어 인터럽트와 소프트웨어 인터럽트로 분류할 수 있습니다.
- 하드웨어 인터럽트
    - 하드웨어 인터럽트는 주변장치, 타이머, 네트워크 카드 등의 하드웨어 장치로부터 발생합니다. 예를 들어, 키보드를 누르거나 마우스를 클릭할 때, 데이터를 전송할 준비가 된 네트워크 장치 등이 이에 해당합니다. 하드웨어 인터럽트를 통해 CPU는 다른 중요한 작업을 빠르게 처리할 수 있으며, 이는 시스템 전반의 효율성을 높여줍니다.
- 소프트웨어 인터럽트
    - 소프트웨어 인터럽트(또는 예외)는 프로그램 코드에 의해 명시적으로 발생되며, 주로 운영체제의 서비스를 요청할 때 사용됩니다. 예를 들어, 파일을 읽거나 쓰기, 네트워크 통신 등의 시스템 호출이 소프트웨어 인터럽트의 예입니다.
- 인터럽트가 필요한 이유
    - 비효율적인 폴링 방지: 인터럽트가 없다면, CPU는 입출력 장치가 데이터를 전송할 준비가 되었는지를 지속적으로 확인(폴링)해야 합니다. 이는 CPU 자원의 낭비를 초래합니다. 인터럽트를 사용하면, 장치가 준비되었을 때 CPU에 알림을 보내 작업을 처리할 수 있어, 자원을 효율적으로 사용할 수 있습니다.
    - 멀티태스킹 구현: 현대 운영체제에서는 여러 프로그램이 동시에 실행되는 것처럼 보이는 멀티태스킹을 제공합니다. 이는 타이머 인터럽트를 통해 가능해지며, 일정 시간마다 현재 실행 중인 프로그램을 전환함으로써 다양한 작업을 동시에 처리할 수 있습니다.
    - 응답성 향상: 사용자의 입력이나 네트워크 요청과 같은 이벤트에 대해 신속하게 반응할 수 있게 합니다. 인터럽트를 통해 이벤트 발생 즉시 처리할 수 있으므로, 시스템의 응답성이 크게 향상됩니다.
    - 복잡한 하드웨어 제어: 인터럽트를 사용하면, 복잡한 하드웨어 장치를 보다 효과적으로 제어할 수 있습니다. 예를 들어, 디스크 입출력, 네트워크 통신 등의 작업을 인터럽트를 통해 효율적으로 관리할 수 있습니다.

</div>
</details>
<details>
<summary>동기적 인터럽트와 비동기적 인터럽트의 차이점은 무엇인가요?</summary>
<div markdown="1">

- 동기적 인터럽트(Synchronous Interrupt)
    - 동기적 인터럽트는 프로그램의 실행 명령에 의해 직접 발생하는 인터럽트입니다. 즉, 실행 중인 프로그램의 특정 동작이나 상태에 의해 예측 가능한 시점에 발생합니다. 이러한 인터럽트는 주로 프로그램 내부에서 발생하는 예외 상황을 처리하기 위해 사용되며, 소프트웨어 인터럽트라고도 불립니다. 예를 들어, 0으로 나누기, 잘못된 메모리 접근, 오버플로우 등이 동기적 인터럽트의 예입니다.
- 비동기적 인터럽트(Asynchronous Interrupt)
    - 비동기적 인터럽트는 프로그램의 실행과 독립적으로 외부의 이벤트나 장치로부터 발생하는 인터럽트입니다. 이는 프로그램의 실행 흐름과는 별개로 언제든지 발생할 수 있으며, 주로 하드웨어 이벤트에 의해 발생합니다. 예를 들어, 키보드 입력, 네트워크 패킷 도착, 타이머 만료 등과 같은 외부 요인에 의해 발생하는 인터럽트가 비동기적 인터럽트입니다.
- 차이점 요약
    - 발생 원인 및 시점: 동기적 인터럽트는 프로그램 코드의 실행으로 인해 예측 가능한 시점에 발생하는 반면, 비동기적 인터럽트는 외부 이벤트에 의해 언제든지 무작위로 발생할 수 있습니다.
    - 유형: 동기적 인터럽트는 주로 소프트웨어 인터럽트에 해당하며, 프로그램 내부의 예외 상황을 처리하기 위해 사용됩니다. 비동기적 인터럽트는 하드웨어 인터럽트에 해당하며, 외부 장치나 이벤트에 의해 발생합니다.
    - 처리 방식: 동기적 인터럽트는 프로그램의 흐름 내에서 예외 처리 등을 통해 관리될 수 있지만, 비동기적 인터럽트는 프로그램의 실행과 독립적으로 발생하므로 별도의 인터럽트 처리 루틴을 통해 관리되어야 합니다.

</div>
</details>
<details>
<summary>인터럽트 처리 과정을 설명해주세요.</summary>
<div markdown="1">

1. 인터럽트 발생
    - 하드웨어 인터럽트의 경우, 외부 장치(예: 키보드, 타이머, 네트워크 카드 등)에서 인터럽트 요청을 발생시킵니다.
    - 소프트웨어 인터럽트(또는 예외)의 경우, 프로그램 실행 중 발생하는 이벤트(예: 0으로 나누기, 잘못된 메모리 접근 등)에 의해 발생합니다.
2. 인터럽트 인식 및 응답
    - CPU는 현재 실행 중인 명령어를 완료한 후 인터럽트 요청을 인식합니다.
    - CPU는 현재의 상태(레지스터, 프로그램 카운터 등)를 저장하여 나중에 원래 작업으로 복귀할 수 있도록 합니다. 이 정보는 스택에 저장될 수 있습니다.
3. 인터럽트 벡터
    - 인터럽트 벡터(인터럽트와 관련된 주소를 담고 있는 테이블)를 사용하여 해당 인터럽트에 대한 인터럽트 서비스 루틴(ISR)의 주소를 찾습니다.
4. 인터럽트 서비스 루틴(ISR) 실행
    - 찾아낸 ISR의 주소로 점프하여 인터럽트를 처리합니다. ISR은 인터럽트의 원인이 된 작업을 처리합니다(예: 데이터 읽기, 기기 상태 변경 등).
    - ISR 실행이 끝나면, 인터럽트 처리 과정을 마무리할 수 있는 명령어(예: IRET 명령어)를 실행하여 원래의 프로그램으로 복귀합니다.
5. 원래 프로그램으로 복귀
    - 스택에서 저장된 CPU의 상태(레지스터, 프로그램 카운터 등)를 복원합니다.
    - CPU는 인터럽트 발생 전에 실행하던 프로그램의 다음 명령어를 계속해서 실행합니다.

</div>
</details>
<details>
<summary>인터럽트를 처리하는도중 또다른 인터럽트가 발생한다면 어떻게 처리되는지 설명해주세요</summary>
<div markdown="1">

- 첫번째 인터럽트 핸들러를 실행하고있는도중엔 다른 인터럽트를 수행하지않도록 하는 방법 . 이경우엔 새로 발생한 인터럽트는 대기상태로있다가 CPU 가 다시 인터럽트 가능한상태로 바뀐후에 인식됩니다
- 두번째방법은 인터럽트들간에 우선순위를 정하고 우선순위가 낮은 인터럽트를 처리하는동안 우선순위가 높은 인터럽트가 들어오면 새로운 인터럽트를 처리하는 방법이있습니다.
- 원칙적으로는 여러 인터럽트가 발생했을때 데이터 일관성을 유지하기위해 첫번째방법을 사용하지만 두번째방법을 사용하는경우도 있습니다.

</div>
</details>
<details>
<summary>Polling 방식에 대해 설명해주세요.</summary>
<div markdown="1">

- 링(Polling) 방식은 CPU가 주변 장치(예: 키보드, 마우스, 프린터 등)의 상태를 주기적으로 검사하여 해당 장치가 데이터 전송이나 처리를 요청하는지 확인하는 방법입니다. 이는 인터럽트 기반의 커뮤니케이션과는 대조적으로, CPU가 직접 장치의 상태를 적극적으로 확인합니다. 폴링 방식은 주로 간단한 입출력 장치 관리나 실시간 시스템에서 요구되는 정확한 타이밍 제어가 필요한 경우에 사용됩니다.
- 폴링 방식의 작동 원리
    1. 상태 검사: CPU는 특정 주변장치의 상태 레지스터를 주기적으로 읽어, 해당 장치가 데이터 전송 준비가 되었는지(데이터를 보내거나 받을 준비가 되었는지) 확인합니다.
    2. 데이터 처리: 전송 준비가 완료된 장치가 발견되면, CPU는 해당 장치와의 데이터 전송을 진행합니다. 데이터 전송이 완료되면, 다시 다른 장치의 상태를 검사하기 시작합니다.
    3. 반복: CPU는 모든 장치에 대해 이 과정을 반복하며, 계속해서 각 장치의 상태를 체크합니다.
- 폴링 방식의 장단점
    - 장점:
        - 구현이 간단하고, 인터럽트 처리 로직이 필요 없어 하드웨어 요구 사항이 낮습니다.
        - 정확한 타이밍 제어가 가능하여 실시간 시스템에서 유용하게 사용될 수 있습니다.
    - 단점:
        - CPU가 지속적으로 장치의 상태를 체크해야 하므로, CPU 자원의 낭비가 발생할 수 있습니다.
        - 여러 장치를 동시에 관리해야 할 때 효율성이 떨어질 수 있으며, 반응 시간이 느려질 수 있습니다.

</div>
</details>
<details>
<summary>이중 동작 모드에 대해 설명해주세요.</summary>
<div markdown="1">

- 이중 동작 모드는 주로 운영 체제가 사용자 모드(User Mode)와 커널 모드(Kernel Mode) 또는 시스템 모드라고도 불리는 두 가지 다른 권한 수준에서 실행될 수 있도록 함으로써, 시스템의 안전을 유지하고 효율적인 자원 관리를 가능하게 합니다.
- 사용자 모드(User Mode)
    - 사용자 모드에서는 응용 프로그램이 실행됩니다. 이 모드에서 실행되는 프로세스는 제한된 시스템 자원에만 접근할 수 있으며, 직접적으로 하드웨어를 제어할 수 없습니다. 이는 시스템의 안전성을 보장하기 위한 조치로, 잘못된 소프트웨어 동작이나 악의적인 활동으로부터 시스템을 보호합니다. 사용자 모드에서는 시스템 호출을 통해 운영 체제의 서비스를 요청할 수 있지만, 운영 체제가 제공하는 인터페이스를 통해서만 가능합니다.
- 커널 모드(Kernel Mode)
    - 커널 모드에서는 운영 체제의 핵심 구성 요소가 실행됩니다. 이 모드에서 실행되는 프로세스는 시스템의 모든 자원과 하드웨어를 직접 제어할 수 있는 권한을 가집니다. 커널 모드는 시스템의 보안과 안정성을 유지하기 위해 필요한 작업을 수행합니다. 예를 들어, 하드웨어 장치 관리, 메모리 관리, 프로세스 스케줄링 등이 이 모드에서 처리됩니다. 사용자 모드에서 실행되는 프로세스가 시스템 자원이나 서비스를 요청할 때, 시스템 호출을 통해 잠시 커널 모드로 전환되어 처리됩니다.
- 이중 동작 모드의 중요성
    - 이중 동작 모드는 운영 체제가 시스템의 안정성과 보안을 유지하면서, 사용자에게 필요한 서비스를 효율적으로 제공할 수 있도록 합니다. 사용자 모드와 커널 모드의 분리는 잘못된 소프트웨어 동작이나 악의적인 활동으로부터 시스템의 핵심 부분을 보호하며, 시스템 자원의 무분별한 사용을 방지합니다. 또한, 이는 프로그램의 오류나 시스템의 결함으로 인한 시스템 전체의 실패 가능성을 줄여줍니다.

</div>
</details>

<br>

# 📍 Reference
- https://github.com/bombo-dev/CS-JAVA-Study/blob/main/Operating%20System/Interrupt.md
- https://github.com/bombo-dev/CS-JAVA-Study/blob/main/Operating%20System/Process.md