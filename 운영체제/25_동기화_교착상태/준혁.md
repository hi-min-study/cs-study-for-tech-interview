- 프로세스 동기화
  - 공유자원, 경쟁상태, 임계구역
  - 피터슨 알고리즘
  - 뮤텍스
  - 세마포어
  - 모니터
- 교착 상태(Deadlock)
  - 교착 상태 정의
  - 교착 상태 조건
  - 교착 상태 해결 방법
  - 식사하는 철학자 문제

# race condition, critical section
## race condition

두 개 이상의 프로세스가 공통 자원을 병행적으로(concurrently) 읽거나 쓰는 동작을 할 때, 공용 데이터에 대한 접근이 어떤 순서에 따라 이루어졌는지에 따라 그 실행 결과가 같지 않고 달라지는 상황

## race condition이 발생하는 경우

1. **커널 작업을 수행하는 중에 인터럽트 발생**
    - 문제점 : 커널모드에서 데이터를 로드하여 작업을 수행하다가 인터럽트가 발생하여 같은 데이터를 조작하는 경우
    - 해결법 : 커널이 작업을 수행중이면 인터럽트가 발생하더라도 먼저 하던 작업을 먼저 다 끝낸 뒤 인터럽트 처리 루틴을 실행하면 해결할 수 있다.
2. **프로세스가 'System Call'을 하여 커널 모드로 진입하여 작업을 수행하는 도중 문맥 교환이 발생할 때**
    - 문제점 : 프로세스1이 커널모드에서 데이터를 조작하는 도중, 시간이 초과되어 CPU 제어권이 프로세스2로 넘어가 같은 데이터를 조작하는 경우 ( 프로세스2가 작업에 반영되지 않음 )
    - 해결법 : 프로세스가 커널모드에서 작업을 하는 경우 시간이 초과되어도 CPU 제어권이 다른 프로세스에게 넘어가지 않도록 함
3. **멀티 프로세서 환경에서 공유 메모리 내의 커널 데이터에 접근할 때**
    - 문제점 : 멀티 프로세서 환경에서 2개의 CPU가 동시에 커널 내부의 공유 데이터에 접근하여 조작하는 경우
    - 해결법 : 커널 내부에 있는 각 공유 데이터에 접근할 때마다, 그 데이터에 대한 lock/unlock을 하는 방법

## Critical Section

여러 프로세스가 데이터를 공유하며 수행될 때, 각 프로세스에서 공유 데이터를 접근하는 프로그램 코드 부분

프로세스 동기화를 위해선 하나의 프로세스가 임계영역에 있을 때 다른 모든 프로세스는 임계영역에 들어갈 수 없어야한다. 그리고 이를 해결하기 위한 프로그램적 해결법의 **조건이 세 가지** 존재한다.

**mutual exclusion(상호 배제)**

- 프로세스가 임계영역을 수행중이면 다른 모든 프로세스들은 그들의 임계영역에 들어가면 안된다.

**progress(진행)**

- 아무도 임계영역에 있지 않은 상태에서 들어가고자 하는 프로세스가 있으면 들어가게 해줘야한다.

**bounded waiting(유한 대기)**

- 프로세스가 임계영역에 들어가려고 요청한 후부터 그 요청이 허용될 때까지 다른 프로세스들이 임계영역에 들어가는 횟수에는 한계가 있어야 한다.

# 세마포어, 뮤텍스

## 정의

Semaphore S에서(S는 정수)

**P(S) -> 자원이 있으면 하나 가져가고 없으면 while문을 돌며 기다린다.**

**V(S) -> 자원을 다 사용하고 반납하는 과정이다.**

세마포어의 종류는 두 가지가 존재한다.

## 종류

**counting semaphore**

- 세마포어의 S가 범위가 0 이상인 임의의 정수 값이다. 자원의 숫자를 세는 데에 사용한다.

**binery semaphore(mutex)**

- 세마포어의 S가 0 또는 1의 값만 가질 수 있는 세마포어로 주로 Lock/Unlock에 사용한다. 뮤텍스라고도 한다.

## 차이점 정리

둘 다 공유 자원에 접근할 수 있는 프로세스를 제한합니다.

S라는 정수 값을 통해 접근할 수 있는 프로세스를 제한하는데,

**세마포어**는 S가 범위가 0 이상인 임의의 정수 값을 사용하므로, 최대 허용치 만큼 접근이 가능하고,

**뮤텍스**는 S가 0또는 1의 값만 가질 수 있으므로 하나만 접근이 가능합니다.

# 데드락(교착상태)

## 정의

프로세스들이 서로가 가진 자원을 기다리며 무한정 기다리고 있는 상태

## 발생 조건

다음의 4가지 조건 모두 만족해야한다.

**Mutual exclusin(상호배제)**

매 순간 하나의 프로세스만이 자원을 사용할 수 있다.

**No preemption(비선점)**

프로세스는 자원을 스스로 내려놓을 수 있지만 강제로 빼앗기지 않는다.

**Hold and wait(점유 대기)**

자원을 가진 프로세스가 다른 자원을 기다릴 때 보유 자원을 놓지 않고 계속 가지고 있는다.

**Circular wait(순환 대기)**

자원을 기다리는 프로세스간에 사이클이 형성되어야 한다.

## 해결 방법

### 예방

교착 상태 발생 조건 중 하나를 제거하면서 해결한다 (자원 낭비 엄청 심함)

- 상호배제 부정 : 여러 프로세스가 공유 자원 사용
- 점유대기 부정 : 프로세스 실행전 모든 자원을 할당
- 비선점 부정 : 자원 점유 중인 프로세스가 다른 자원을 요구할 때 가진 자원 반납
- 순환대기 부정 : 자원에 고유번호 할당 후 순서대로 자원 요구

### 회피

자원 요청에 대한 부가적인 정보를 이용해서 교착상태의 가능성이 없는 경우에만 자원을 할당한다.

프로세스가 시작될 때 필요로 하는 각 자원별 최대 사용량을 미리 선언해서, 현재의 가용자원만 가지고 최대 자원 요청을 처리할 수 있는 프로세스의 요청만 받아들인다.

- 자원을 할당받는 프로세스가 한개라면 자원 할당 그래프를 이용하여 회피
- 자원을 할당받는 프로세스가 여러 개라면 banker's 알고리즘을 사용하여 회피

### 탐지와 회복

교착상태를 발생하도록 내버려두다가, 만약 교착상태를 발견하면 그것을 회복시키는 방법이다.

회복하는 방법은 2가지가 있다.

- **프로세스 종료**교착상태에 걸린 모든 프로세스를 종료시킨다. 또는 교착상태에 걸린 프로세스를 하나씩 죽이면서 교착상태가 해결되는지 확인한다.
- **자원 선점**종료시켰을 때 비용이 최소화되는 프로세스를 선정한다. 그리고 그 프로세스를 safe한 상태로 롤백하여 restart시킨다. 이 때 계속 동일한 프로세스가 선정되는 경우 기아 상태에 빠질 수 있으므로 롤백 횟수도 같이 고려해서 선정해야 한다.

### 회복

교착상태가 일어나지 않는다고 생각하고 아무런 조치도 취하지 않는다. 교착상태는 매우 드물게 발생하므로 교착상태에 대한 조치가 교착상태에 걸린 것보다 훨씬 큰 오버헤드일 수 있다. 따라서 만약 시스템에 교착상태가 발생한 경우, 시스템이 비정상적으로 동작하는 것을 사람이 느낀 후 직접 프로세스를 종료하는 방법 등으로 대처한다. 현대의 대부분의 범용 OS가 채택하는 방식이다.

## 예상 질문
- race contidion(경쟁상태)에 대해서 설명해주세요
  - 두 개 이상의 프로세스가 공통 자원을 병행적으로(concurrently) 읽거나 쓰는 동작을 할 때, 공용 데이터에 대한 접근이 어떤 순서에 따라 이루어졌는지에 따라 그 실행 결과가 같지 않고 달라지는 상황
- OS에서 경쟁상태는 언제 생기나요?
  - 커널 작업을 수행하는 중에 인터럽트 발생
  - 프로세스가 'System Call'을 하여 커널 모드로 진입하여 작업을 수행하는 도중 문맥 교환이 발생할 때
  - 멀티 프로세서 환경에서 공유 메모리 내의 커널 데이터에 접근할 때
- critical section이란?
  - 여러 프로세스가 데이터를 공유하며 수행될 때, 각 프로세스에서 공유 데이터를 접근하는 프로그램 코드 부분
- critical section 문제 해결을 위한 3가지 조건
  - 프로세스 동기화를 위해선 한 번에 하나의 프로세스만 임계영역에 들어갈 수 있도록 허용해야합니다.
  - 다음과 같은 세 가지 조건이 필요합니다.
  - mutual exclusion(상호 배제), progress(진행), bounded waiting(유한 대기)
- 뮤텍스와 세마포어에 대해 설명해주세요.
  - 둘 다 공유 자원에 접근할 수 있는 프로세스를 제한합니다. 
  - S라는 정수 값을 통해 접근할 수 있는 프로세스를 제한하는데,
  - **세마포어**는 S가 범위가 0 이상인 임의의 정수 값을 사용하므로, 최대 허용치 만큼 접근이 가능하고,
  - **뮤텍스**는 S가 0또는 1의 값만 가질 수 있으므로 하나만 접근이 가능합니다.
- 교착 상태란 무엇인가요?
  - 프로세스들이 서로가 가진 자원을 기다리며 무한정 기다리고 있는 상태
- 교착 상태가 발생하는 조건은 어떻게 되나요?
  - Mutual exclusin(상호배제), No preemption(비선점), Hold and wait(점유 대기), Circular wait(순환 대기)  
- 교착 상태를 해결할 수 있는 방법은 무엇인가요?
  - 예방: 교착 상태 발생 조건 중 하나를 제거하면서 해결한다
  - 회피: 자원 요청에 대한 부가적인 정보를 이용해서 교착상태의 가능성이 없는 경우에만 자원을 할당한다.
  - 탐지와 회복: 교착상태를 발생하도록 내버려두다가, 만약 교착상태를 발견하면 그것을 회복시키는 방법이다.
  - 무시: 교착상태가 일어나지 않는다고 생각하고 아무런 조치도 취하지 않는다. 