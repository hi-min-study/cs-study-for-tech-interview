# 📍 키워드
- 프로세스 동기화
    - 공유자원, 경쟁상태, 임계구역
    - 피터슨 알고리즘
    - 뮤텍스
    - 세마포어
    - 모니터
- 교착 상태(Deadlock)
    - 교착 상태 정의
    - 교착 상태 조건
    - 교착 상태 해결 방법
    - 식사하는 철학자 문제

<br>

# 📍 예상 질문
<details>
<summary>공유자원과 경쟁상태에 대해 설명해주세요.</summary>
<div markdown="1">

- 공유 자원(Shared Resources)
    - 공유 자원이란 여러 프로세스나 스레드가 동시에 접근할 수 있는 메모리 영역이나 데이터, 하드웨어 자원 등을 말합니다. 예를 들어, 파일, 데이터베이스 연결, 전역 변수 등이 공유 자원에 해당합니다. 이러한 자원은 시스템의 효율성을 높이기 위해 여러 프로세스나 스레드와 공유되지만, 동시에 여러 접근이 발생할 경우 데이터의 일관성과 무결성을 해칠 수 있습니다.
- 경쟁 상태(Race Condition)
    - 경쟁 상태는 두 개 이상의 프로세스나 스레드가 동시에 공유 자원에 접근하려고 할 때, 그 실행 순서에 따라 시스템의 결과가 달라지는 상황을 말합니다. 즉, 공유 자원에 대한 접근을 적절히 제어하지 않으면, 예측할 수 없는 결과나 데이터의 손상이 발생할 수 있습니다.
- 예를 들어, 두 스레드가 동시에 같은 메모리 위치에 값을 쓰려고 할 때, 어떤 스레드의 쓰기 연산이 먼저 수행될지에 따라 최종 결과가 달라질 수 있습니다. 만약 이러한 동작이 적절히 동기화되지 않는다면, 최종 데이터는 두 스레드의 연산 순서에 의존적이 되어 예측 불가능한 결과를 초래할 수 있습니다.

</div>
</details>
<details>
<summary>임계구역 문제란 무엇이며, 왜 중요한가요?</summary>
<div markdown="1">

- 임계 구역(Critical Section) 문제는 멀티 프로세싱 환경에서 여러 프로세스가 동시에 공유 자원에 접근할 때 발생하는 동기화 문제를 말합니다. 임계 구역은 공유 자원에 대한 접근을 제어해야 하는 코드 영역으로, 한 번에 하나의 프로세스만이 이 영역에 진입할 수 있어야 합니다.
- 임계 구역 문제의 중요성
    - 임계 구역 문제를 해결하는 것은 병렬 컴퓨팅 및 멀티 스레딩 환경에서 매우 중요합니다. 이 문제를 적절히 관리하지 않으면 다음과 같은 문제가 발생할 수 있습니다.
    1. 데이터 일관성(Data Consistency): 여러 프로세스가 동시에 공유 자원을 변경할 경우, 데이터의 일관성이 깨질 수 있습니다. 예를 들어, 두 프로세스가 동시에 같은 변수를 수정하려고 할 때, 최종 값이 예측 불가능할 수 있습니다.
    2. 경쟁 상태(Race Condition): 임계 구역 문제를 해결하지 않으면 경쟁 상태가 발생할 수 있습니다. 이는 프로세스의 실행 순서에 따라 결과가 달라지는 상황을 의미하며, 이로 인해 시스템의 예측 불가능성이 증가합니다.
    3. 데드락(Deadlock): 임계 구역 문제를 해결하기 위한 부적절한 동기화 메커니즘 사용은 데드락을 유발할 수 있습니다. 데드락은 여러 프로세스가 서로가 점유한 자원의 해제를 무한히 기다리는 상태를 말합니다.
    4. 리소스 낭비(Resource Wastage): 임계 구역에 대한 접근을 제어하기 위해 프로세스가 대기 상태에 들어갈 때, CPU 시간과 같은 리소스가 낭비될 수 있습니다. 효율적인 동기화 메커니즘은 이러한 리소스 낭비를 최소화할 수 있습니다.
- 해결 방안
    - 임계 구역 문제를 해결하기 위해 다음과 같은 세 가지 기본 요구 사항을 충족해야 합니다.
    1. 상호 배제(Mutual Exclusion): 한 번에 하나의 프로세스만이 임계 구역에 진입할 수 있어야 합니다.
    2. 진행(Progress): 임계 구역에 진입하고자 하는 프로세스가 없는 경우, 진입을 원하는 프로세스가 임계 구역에 진입할 수 있도록 해야 합니다.
    3. 유한 대기(Bounded Waiting): 프로세스가 임계 구역에 진입하기 위해 무한히 기다리지 않도록 보장해야 합니다.


</div>
</details>
<details>
<summary>피터슨 알고리즘의 원리와 작동 방식을 설명해주세요.</summary>
<div markdown="1">

- 피터슨 알고리즘(Peterson's algorithm)은 두 프로세스가 임계 구역 문제를 해결하기 위해 사용할 수 있는 간단하면서도 효과적인 알고리즘입니다. 이 알고리즘은 상호 배제(Mutual Exclusion), 진행(Progress), 그리고 유한 대기(Bounded Waiting)의 세 가지 필수 조건을 모두 만족시키며, 두 프로세스가 번갈아 가며 임계 구역에 진입할 수 있도록 합니다.
- 원리
    - 피터슨 알고리즘의 기본 원리는 공유 변수를 사용하여 두 프로세스 간의 동의를 구하는 것입니다. 이 알고리즘은 다음 두 가지 공유 변수를 사용합니다:
    1. flag[]: 각 프로세스가 임계 구역에 진입하고자 할 때 true로 설정하는 플래그 배열입니다. 프로세스가 임계 구역에 진입하려는 의사를 표시합니다.
    2. turn: 어느 프로세스의 차례인지를 나타내는 변수입니다. 이 변수는 다른 프로세스에게 임계 구역 접근 권한을 양도하는 역할을 합니다.
- 작동 방식
    - 피터슨 알고리즘의 작동 방식은 다음과 같습니다. 여기서 P0과 P1은 두 개의 프로세스를 나타냅니다.
    1. 진입 부분(Entry Section): 프로세스 P0이 임계 구역에 진입하고자 할 때, flag[0]을 true로 설정하고 turn을 1로 설정합니다. 이는 P0이 임계 구역에 진입하고자 하며, P1에게 우선권을 양도한다는 것을 의미합니다. P1도 마찬가지 방식으로 진입 부분을 실행합니다.
    2. 임계 구역(Critical Section): P0은 flag[1]이 false이거나 turn이 0인 경우에만 임계 구역에 진입합니다. 이는 P1이 임계 구역에 진입하고자 하지 않거나, P1이 P0에게 우선권을 양도한 경우에 해당합니다. P1에 대해서도 동일한 조건이 적용됩니다.
    3. 퇴장 부분(Exit Section): P0이 임계 구역을 빠져나올 때, flag[0]을 false로 설정하여 임계 구역에 대한 관심이 없음을 나타냅니다. P1도 마찬가지로 퇴장 부분을 실행합니다.
    - 피터슨 알고리즘은 이러한 간단한 논리를 통해 두 프로세스가 임계 구역을 안전하게 공유할 수 있도록 합니다. 상호 배제를 보장하며, 데드락이 발생하지 않고, 한 프로세스가 임계 구역에 영원히 머무르지 않도록 합니다. 그러나 이 알고리즘은 오직 두 프로세스에 대해서만 작동하며, 확장성이 제한적입니다. 또한, 바쁜 대기(busy waiting) 상태가 발생할 수 있어, 효율성 측면에서 단점을 가

</div>
</details>
<details>
<summary>뮤텍스와 세마포어의 차이점은 무엇인가요?</summary>
<div markdown="1">

- 뮤텍스(Mutex)
    - 소유권: 뮤텍스는 잠금을 획득한 스레드가 소유하게 됩니다. 이 스레드만이 뮤텍스를 해제할 수 있습니다.
    - 이진성: 뮤텍스는 이진 성질을 가지고 있으며, 잠금 상태(1)와 잠금 해제 상태(0) 두 가지 상태만 존재합니다.
    - 목적: 주로 상호 배제를 보장하기 위해 사용됩니다. 한 번에 하나의 스레드만이 임계 구역에 진입할 수 있습니다.
- 세마포어(Semaphore)
    - 소유권: 세마포어는 특정 스레드에 의해 소유되지 않습니다. 어떤 스레드든 세마포어를 증가시키거나 감소시킬 수 있습니다.
    - 카운트: 세마포어는 카운트를 사용하여 리소스의 수를 관리합니다. 이 카운트는 동시에 리소스에 접근할 수 있는 스레드의 최대 수를 나타냅니다.
    - 유형: 세마포어는 이진 세마포어(0 또는 1의 값만 가짐)와 카운팅 세마포어(2 이상의 값을 가짐) 두 가지 유형이 있습니다.
    - 목적: 세마포어는 상호 배제 뿐만 아니라, 복수의 스레드가 동시에 임계 구역에 접근하는 것을 조정하는 데에도 사용될 수 있습니다.
- 주요 차이점 요약
    - 소유권과 해제: 뮤텍스는 잠금을 획득한 스레드에 의해서만 해제될 수 있으며, 이는 소유권 개념과 관련이 있습니다. 반면, 세마포어는 잠금을 획득한 스레드와 다른 스레드에 의해 해제될 수 있습니다.
    - 용도: 뮤텍스는 주로 상호 배제를 위해 사용되며, 한 번에 하나의 스레드만이 임계 구역에 진입할 수 있도록 합니다. 세마포어는 이보다 더 일반적인 동기화 목적으로 사용되며, 여러 스레드가 동시에 임계 구역에 접근할 수 있도록 할 수 있습니다.

</div>
</details>
<details>
<summary>세마포어의 대기와 신호 연산은 무엇이며, 어떻게 동작하나요?</summary>
<div markdown="1">

- 대기(Wait) 연산
    - 대기 연산은 종종 P 연산으로도 불리며, wait() 또는 P()로 표시됩니다.
    - 이 연산을 실행할 때, 세마포어의 값을 1 감소시킵니다.
    - 세마포어의 값이 0보다 크면, 연산을 수행하는 스레드는 계속 실행을 진행할 수 있습니다.
    - 만약 세마포어의 값이 0이라면, 연산을 수행하는 스레드는 세마포어의 값이 0보다 커질 때까지 대기 상태로 들어갑니다. 즉, 해당 스레드는 블록(대기 상태)됩니다.
- 신호(Signal) 연산
    - 신호 연산은 V 연산으로도 알려져 있으며, signal() 또는 V()로 표현됩니다.
    - 이 연산을 실행할 때, 세마포어의 값을 1 증가시킵니다.
    - 만약 이 연산으로 세마포어의 값이 1 이상이 되어 대기 중인 스레드가 있다면, 하나의 대기 중인 스레드가 깨어나서 실행을 계속할 수 있게 됩니다.
    - 신호 연산은 리소스가 사용 가능해짐을 나타내며, 대기 중인 스레드 중 하나를 임계 구역으로 진입시킬 수 있습니다.
- 동작 방식
    1. 리소스의 초기 사용 가능 수량을 세마포어 값으로 설정합니다.
    2. 스레드가 리소스를 사용하고자 할 때, 대기 연산을 사용하여 세마포어 값을 감소시키고 리소스 사용을 시도합니다. 만약 세마포어의 값이 0이라면, 스레드는 리소스가 사용 가능해질 때까지 대기합니다.
    3. 스레드가 리소스 사용을 완료하면, 신호 연산을 사용하여 세마포어 값을 증가시키고 리소스를 반환함으로써 다른 스레드가 리소스를 사용할 수 있도록 합니다.

</div>
</details>
<details>
<summary>모니터를 사용한 동기화 방법에 대해 설명해주세요.</summary>
<div markdown="1">

- 모니터를 사용한 동기화는 고급 동기화 메커니즘 중 하나로, 여러 스레드가 동시에 코드의 특정 부분을 실행하는 것을 방지하는 방법입니다. 모니터는 동시 실행을 제어하기 위해 임계 구역(critical section)에 대한 접근을 관리하는 객체 또는 모듈을 의미합니다. 이는 공유 자원에 대한 안전한 접근을 보장하며, 데이터의 일관성과 무결성을 유지하는 데 중요한 역할을 합니다.
- 모니터의 주요 특징과 구성 요소
    - 캡슐화: 모니터는 공유 자원과 이를 조작하기 위한 연산들(함수 또는 메소드)을 캡슐화합니다. 이는 공유 자원에 대한 접근을 모니터 내의 연산을 통해서만 가능하게 합니다.
    - 상호 배제(Mutual Exclusion): 어떤 시점에도 하나의 스레드만이 모니터 내의 임계 구역을 실행할 수 있습니다. 다른 스레드들은 임계 구역이 비워질 때까지 대기해야 합니다.
    - 조건 변수: 대기 중인 스레드를 관리하기 위해 모니터는 조건 변수를 사용합니다. 조건 변수는 일반적으로 스레드가 특정 조건이 충족될 때까지 대기하게 하고, 조건이 충족되면 스레드를 깨우는 데 사용됩니다.
- 동작 방식
    - 스레드가 모니터의 임계 구역에 접근하려고 하면, 모니터는 다른 스레드가 현재 임계 구역을 실행 중인지 확인합니다.
    - 만약 임계 구역이 비어 있으면, 접근을 시도한 스레드는 임계 구역에 진입하여 실행을 시작할 수 있습니다.
    - 임계 구역이 이미 다른 스레드에 의해 실행 중이라면, 접근을 시도한 스레드는 대기 상태로 전환되며, 임계 구역이 사용 가능해질 때까지 기다립니다.
    - 스레드가 임계 구역의 작업을 완료하고 나가면, 모니터는 대기 중인 스레드 중 하나를 선택하여 임계 구역에 진입할 수 있도록 합니다.
- 예시
    - 자바와 같은 프로그래밍 언어에서는 synchronized 키워드를 사용하여 메소드나 블록을 모니터로 지정할 수 있습니다. 이 키워드가 적용된 메소드나 블록은 한 번에 하나의 스레드만이 실행할 수 있으며, 다른 스레드들은 현재 실행 중인 스레드가 메소드나 블록을 빠져나갈 때까지 대기해야 합니다.

</div>
</details>
<details>
<summary>뮤텍스와 세마포어, 모니터 중 어떤 것을 사용하는 것이 좋은가요? 그 이유는 무엇인가요?</summary>
<div markdown="1">

- 뮤텍스(Mutex)
    - 특징: 뮤텍스는 Mutual Exclusion(상호 배제)의 약자로, 한 번에 하나의 스레드만 임계 구역에 접근할 수 있도록 합니다. 뮤텍스는 소유가 가능하며, 잠금을 획득한 스레드만이 해당 잠금을 해제할 수 있습니다.
    - 사용 시기: 공유 자원에 대한 접근을 단일 스레드로 제한해야 할 때 사용합니다. 데드락을 방지하고, 자원의 일관성을 유지하는 데 적합합니다.
- 세마포어(Semaphore)
    - 특징: 세마포어는 동시에 리소스에 접근할 수 있는 스레드의 수를 제한합니다. 이진 세마포어는 뮤텍스와 유사하게 작동할 수 있지만, 일반 세마포어는 여러 스레드가 동시에 접근할 수 있게 할 수 있습니다.
    - 사용 시기: 한정된 수의 자원을 여러 스레드가 사용해야 할 때 유용합니다. 예를 들어, 데이터베이스 연결 풀이나 스레드 풀 관리에 적합합니다.
- 모니터(Monitor)
    - 특징: 모니터는 클래스나 객체에 동기화 메커니즘을 캡슐화하는 방법입니다. 모니터 내의 모든 메소드는 자동으로 임계 구역이 되어, 동시에 하나의 스레드만이 모니터의 메소드를 실행할 수 있습니다.
    - 사용 시기: 객체 지향 프로그래밍에서 공유 자원에 대한 접근을 제어해야 할 때 유용합니다. 코드의 가독성과 유지 보수성을 높이는 데 도움이 됩니다.
- 결론
    - 뮤텍스는 단일 스레드의 접근 제한이 필요할 때,
    - 세마포어는 여러 스레드가 동시에 자원을 사용해야 하지만, 그 수를 제한해야 할 때,
    - 모니터는 객체 지향 설계에서 동기화를 내장하여 코드의 명확성과 안정성을 높이고자 할 때 사용하는 것이 좋습니다.

</div>
</details>
<details>
<summary>교착 상태란 무엇인가요?</summary>
<div markdown="1">

- 교착 상태(Deadlock)는 여러 프로세스나 스레드가 서로가 보유하고 있는 자원을 요청하면서 무한히 기다리는 현상을 말합니다. 이 상태에서는 아무도 자신의 작업을 진행시킬 수 없게 되며, 시스템의 일부분이 멈춰서 전체적인 작업 처리 능력이 저하될 수 있습니다. 

</div>
</details>
<details>
<summary>교착 상태의 네 가지 필수 조건은 무엇인가요?</summary>
<div markdown="1">

1. 상호 배제(Mutual Exclusion): 자원은 한 번에 한 프로세스(또는 스레드)만이 사용할 수 있습니다. 즉, 둘 이상의 프로세스가 동시에 같은 자원을 사용할 수 없는 조건입니다.
2. 보유 대기(Hold and Wait): 프로세스가 최소한 하나의 자원을 이미 보유하고 있으면서, 다른 프로세스에 의해 현재 사용 중인 추가 자원을 대기하는 상태입니다.
3. 비선점(No Preemption): 프로세스가 자원을 일단 할당받으면, 그 자원을 스스로 사용이 끝날 때까지 다른 프로세스에 의해 강제로 빼앗길 수 없는 조건입니다. 즉, 자원을 사용 중인 프로세스가 자발적으로만 자원을 방출할 수 있습니다.
4. 순환 대기(Circular Wait): 대기 중인 프로세스의 집합 {P1, P2, ..., Pn}에서 P1은 P2가 보유한 자원을 대기하고, P2는 P3가 보유한 자원을 대기하며, ..., Pn은 P1이 보유한 자원을 대기하는 순환 형태의 대기 상태입니다.

</div>
</details>
<details>
<summary>교착 상태를 해결하기 위한 방법은 무엇인가요?</summary>
<div markdown="1">

1. 교착 상태 예방(Deadlock Prevention)
    - 상호 배제 부정: 가능한 경우, 자원을 공유할 수 있도록 합니다. 하지만, 모든 자원이 공유 가능한 것은 아닙니다.
    - 보유 대기 부정: 프로세스가 실행되기 전 필요한 모든 자원을 한 번에 요청하도록 합니다. 자원을 일부만 점유하고 대기하지 않게 합니다.
    - 비선점 부정: 프로세스가 요청한 자원이 다른 프로세스에 의해 점유되어 있다면, 이미 점유하고 있는 자원들을 방출하고 나중에 다시 모든 자원을 요청합니다.
    - 순환 대기 부정: 자원에 고유한 순서를 할당하고, 프로세스가 반드시 증가하는 순서로만 자원을 요청할 수 있도록 합니다.
2. 교착 상태 회피(Deadlock Avoidance)
    - 시스템의 상태를 지속적으로 검사하여, 시스템을 안전 상태로 유지함으로써 교착 상태를 회피하는 방법입니다. 대표적인 알고리즘으로는 **은행원 알고리즘(Banker's Algorithm)**이 있습니다.
3. 교착 상태 탐지 및 회복(Deadlock Detection and Recovery)
    - 시스템에서 교착 상태가 발생했는지 주기적으로 검사하고, 교착 상태를 탐지하면 이를 해결하기 위해 하나 이상의 프로세스를 종료하거나 자원을 강제로 회수하는 방법입니다.
    - 탐지: 자원 할당 그래프와 같은 데이터 구조를 사용하여 시스템의 상태를 주기적으로 검사합니다.
    - 회복: 프로세스를 종료하거나 할당된 자원을 선점하여 교착 상태를 해결합니다.
4. 자원 할당 정책 변경
    - 자원 할당 방식을 변경하여 교착 상태의 위험을 줄이는 방법입니다. 예를 들어, 자원을 필요로 하는 프로세스에 더 많은 우선순위를 부여하거나, 자원의 사용 시간을 제한하는 방법 등이 있습니다.

</div>
</details>
<details>
<summary>식사하는 철학자 문제는 무엇이며, 이 문제를 어떻게 해결할 수 있나요?</summary>
<div markdown="1">

- 이 문제는 다수의 철학자들이 원탁에 둘러앉아 생각에 잠기다가 식사를 하기 위해 포크를 사용해야 하는 상황을 모델링 합니다. 철학자들 사이에는 포크가 하나씩 놓여 있으며, 철학자가 식사를 하려면 자신의 오른쪽과 왼쪽에 있는 두 개의 포크를 모두 사용해야 합니다. 이 문제의 핵심은 모든 철학자가 동시에 식사를 시작하려 할 때 교착 상태(Deadlock)에 빠지지 않도록 하는 것입니다.
- 식사하는 철학자 문제 해결 방법
    1. 자원의 계층 순서 정하기
        - 모든 포크에 번호를 매기고, 철학자가 항상 번호가 낮은 포크부터 먼저 집도록 합니다. 이렇게 하면 순환 대기 조건을 방지할 수 있습니다.
    2. 자원 할당에 대한 필요성 검사
        - 철학자가 식사를 시작하기 전에, 필요한 두 포크가 모두 사용 가능한지 먼저 검사합니다. 이 방법은 보유 대기 조건을 방지할 수 있습니다.
    3. 철학자의 수 제한
        - 동시에 식사할 수 있는 철학자의 수를 제한합니다. 예를 들어, 5명의 철학자가 있다면 동시에 최대 4명만 식사할 수 있도록 합니다. 이렇게 하면 적어도 하나의 철학자는 자신의 양쪽에 있는 포크를 모두 사용할 수 있게 됩니다.
    4. 비선점적 할당
        - 철학자가 한 개의 포크만 사용할 수 있을 때는 그 포크를 다른 철학자에게 양보하고, 두 개의 포크를 모두 사용할 수 있을 때만 식사를 시작합니다.
    5. 교대로 식사하기
        - 철학자들이 교대로 식사하도록 시간을 할당합니다. 예를 들어, 짝수 번호의 철학자들이 먼저 식사하고, 그 다음에 홀수 번호의 철학자들이 식사하는 방식입니다.

</div>
</details>


<br>

# 📍 Reference
- https://youtu.be/Dms1oBmRAlo?si=En0Q8hc8lUf4F4mi