# 📍 키워드
- CPU 스케줄링
    - 장기 스케줄링
    - 중기 스케줄링
    - 단기 스케줄링
- 스케줄링 알고리즘
    - FCFS
    - SJF
    - Round Robin
    - SRT
    - Priority scheduling
    - Multilevel Queue
    - Multilevel Feedback Queue
<br>

# 📍 예상 질문
<details>
<summary>CPU 스케줄링이란 무엇이며, 왜 중요한가요?</summary>
<div markdown="1">

- CPU 스케줄링은 운영 체제의 스케줄러가 CPU가 처리해야 할 여러 프로세스 또는 스레드 중에서 어떤 것을 다음으로 실행할지 결정하는 과정입니다. 이 스케줄링은 시스템 내의 준비 큐에 있는 프로세스들 사이에서 이루어지며, 효율적인 CPU 사용과 공정한 자원 배분을 목표로 합니다. CPU 스케줄링은 다음과 같은 이유로 중요합니다.
1. 성능 최적화: CPU 스케줄링은 시스템의 성능을 최적화하는 데 중요한 역할을 합니다. 적절한 스케줄링 알고리즘을 사용함으로써 처리량(Throughput), 응답 시간(Response Time), 대기 시간(Waiting Time) 및 CPU 사용률을 개선할 수 있습니다.
2. 자원 활용도 증가: CPU와 같은 시스템 자원의 활용도를 극대화하는 것은 중요합니다. 효과적인 스케줄링을 통해 CPU가 유휴 상태에 머무르는 시간을 줄이고, 시스템 자원을 최대한 활용할 수 있습니다.
3. 시스템의 공정성 보장: 여러 프로세스가 시스템 자원을 공평하게 사용할 수 있도록 하는 것도 중요합니다. 스케줄링은 모든 프로세스가 적절한 CPU 시간을 할당받도록 관리하여, 특정 프로세스가 자원을 독점하는 것을 방지합니다.
4. 멀티태스킹 및 다중 프로그래밍 환경 지원: 현대의 운영 체제는 멀티태스킹과 다중 프로그래밍을 지원합니다. 이러한 환경에서는 동시에 여러 프로세스가 실행될 수 있으므로, CPU 스케줄링이 이 프로세스들 사이에서 효과적으로 CPU 시간을 분배하는 역할을 합니다.
5. 사용자 경험 개선: 사용자 입장에서는 애플리케이션의 응답성과 성능이 중요합니다. 효과적인 CPU 스케줄링은 사용자 요청에 대한 빠른 응답 시간을 보장하고, 이로 인해 전반적인 사용자 경험을 개선할 수 있습니다.
6. 실시간 시스템 지원: 실시간 운영 체제에서는 특정 작업이 정해진 시간 내에 완료되어야 합니다. CPU 스케줄링은 이러한 시간 제약 조건을 충족시키기 위해 필수적인 역할을 수행합니다.

</div>
</details>
<details>
<summary>장기, 중기, 단기 스케줄링의 차이점에 대해 설명해주세요.</summary>
<div markdown="1">

- 장기 스케줄링(Job Scheduler)
    - 목적: 장기 스케줄링의 주요 목적은 어떤 프로세스가 시스템에 진입하여 실행될 준비를 할 것인지 결정하는 것입니다. 이는 프로세스가 시스템의 준비 큐로 들어가는 속도를 조절하여, 멀티 프로그래밍의 정도를 결정합니다.
    - 기능: 시스템의 리소스에 대한 수요와 공급을 조절하는 역할을 합니다. 즉, 시스템의 부하를 관리하여 너무 많은 프로세스가 동시에 실행되어 시스템이 과부하되는 것을 방지합니다.
    - 주기: 상대적으로 긴 주기를 가지며, 프로세스의 생성과 종료에 영향을 줍니다.
- 중기 스케줄링(Swapper)
    - 목적: 중기 스케줄링의 목적은 시스템의 성능을 최적화하기 위해 현재 실행 중이거나 실행을 대기하고 있는 프로세스들을 메모리와 스왑 영역(swap space) 사이에서 이동시키는 것입니다. 이를 통해 메모리 관리 및 멀티태스킹의 효율성을 개선합니다.
    - 기능: 중기 스케줄링은 메모리 사용률을 극대화하고, 메모리 오버헤드를 최소화하기 위해 프로세스를 스왑 아웃(swap out)하거나 스왑 인(swap in)합니다. 이 과정에서 프로세스의 상태가 준비(ready) 상태와 대기(waiting) 상태 사이에서 변경될 수 있습니다.
    - 주기: 장기와 단기 스케줄링 사이에 위치하며, 메모리 사용의 동적 조절을 위해 사용됩니다.
- 단기 스케줄링(CPU Scheduler)
    - 목적: 단기 스케줄링, 또는 CPU 스케줄링의 주요 목적은 준비 큐에 있는 프로세스들 중 어느 하나를 선택하여 CPU를 할당하는 것입니다. 이는 시스템의 응답 시간, 처리량 등을 최적화하는 데 중점을 둡니다.
    - 기능: 시스템의 효율성을 최대화하기 위해 프로세스 사이에서 CPU 시간을 공정하게 분배합니다. 이를 위해 다양한 스케줄링 알고리즘(예: FCFS, SJF, Round Robin 등)이 사용됩니다.
    - 주기: 매우 짧은 주기를 가지며, CPU와 프로세스 간의 상호 작용을 관리합니다.

</div>
</details>
<details>
<summary>장기 스케줄링은 어떤 역할을 하나요?</summary>
<div markdown="1">

- 이 스케줄링의 핵심 목적은 시스템 내에 어떤 프로세스들이 진입하여 실행될 준비를 할 것인지 결정하는 것입니다. 즉, 프로세스가 시스템의 준비 큐에 들어가는 속도를 조절함으로써 멀티프로그래밍의 정도를 결정하고, 시스템의 부하를 관리합니다. 이를 통해 시스템의 성능과 효율성을 극대화하고자 합니다.
- 장기 스케줄링의 역할
    - 멀티 프로그래밍 정도의 조절: 시스템의 멀티프로그래밍 수준을 결정합니다. 즉, 동시에 메모리에 존재할 수 있는 프로세스의 수를 조절하여, 시스템의 리소스가 효율적으로 사용될 수 있도록 합니다.
    - 시스템 부하 관리: 너무 많은 프로세스가 동시에 실행되면 시스템의 성능이 저하될 수 있습니다. 장기 스케줄링은 시스템에 새로운 프로세스를 추가하는 것을 관리하여, 시스템의 부하를 적절히 유지합니다.
    - 리소스 할당: 프로세스가 시스템에 진입할 때 필요한 리소스(예: 메모리, 입출력 장치 등)를 할당받습니다. 이는 프로세스가 실행되기 전에 필요한 준비 단계입니다.

</div>
</details>
<details>
<summary>현재 CPU에서 장기 스케줄링을 하고있나요? 하고있지 않다면 그 이유는 무엇인가요?</summary>
<div markdown="1">

- 초기 컴퓨터 시스템에서 장기 스케줄러의 주된 역할은 시스템의 자원을 효율적으로 사용하기 위해 어떤 프로세스를 메모리에 적재할지 결정하는 것이었습니다. 하지만, 하드웨어의 발전으로 메모리와 처리 능력이 크게 향상되면서 대부분의 시스템에서는 많은 수의 프로세스를 동시에 메모리에 적재하고 관리할 수 있게 되었습니다. 이로 인해 장기 스케줄러의 필요성이 줄어들었습니다.

</div>
</details>
<details>
<summary>중기 스케줄링의 주요 목적은 무엇이며, 어떻게 메모리 관리와 관련이 있나요?</summary>
<div markdown="1">

- 중기 스케줄링의 주요 목적은 시스템의 성능을 최적화하기 위해 현재 실행 중이거나 실행을 대기하고 있는 프로세스들을 메모리와 스왑 영역(swap space) 사이에서 이동시키는 것입니다. 이를 통해 메모리 관리와 멀티태스킹의 효율성을 개선하고, 시스템의 전반적인 성능을 향상시킵니다.
- 중기 스케줄링의 주요 목적
    - 메모리 사용 최적화: 중기 스케줄링은 메모리 사용률을 최적화하여, 시스템의 리소스를 더 효율적으로 사용할 수 있도록 합니다. 이는 메모리가 제한된 시스템에서 특히 중요합니다.
    - 시스템의 성능 개선: 메모리와 CPU 리소스 사이의 균형을 맞추어 시스템의 성능을 개선합니다. 프로세스가 메모리에 적재되거나 제거됨으로써, CPU 사용률과 메모리 사용률 사이의 최적의 균형을 찾으려고 합니다.
    - 멀티태스킹 효율성 개선: 실행 가능한 프로세스의 집합을 관리하여 멀티태스킹 환경에서의 효율성을 개선합니다. 이는 사용자에게 더 나은 응답 시간과 처리량을 제공하는 데 도움이 됩니다.

- 메모리 관리와의 관련성
    - 중기 스케줄링은 메모리 관리와 직접적으로 관련이 있습니다. 프로세스가 시스템 메모리와 스왑 영역 사이에서 이동함으로써, 실행 중인 프로세스의 메모리 요구사항과 사용 가능한 메모리 리소스 사이의 균형을 조절합니다. 다음과 같은 방식으로 메모리 관리와 연결됩니다:
        - 스왑 아웃(Swap out): 시스템 메모리가 부족할 때, 중기 스케줄러는 일부 프로세스를 스왑 영역으로 이동시켜 메모리를 확보할 수 있습니다. 이는 실행 중이지 않거나 우선순위가 낮은 프로세스를 대상으로 합니다.
        - 스왑 인(Swap in): 실행을 위해 필요한 프로세스가 스왑 영역에 있는 경우, 중기 스케줄러는 해당 프로세스를 다시 메모리로 불러옵니다. 이 과정에서 필요하지 않은 프로세스를 스왑 아웃할 수도 있습니다.
        - 메모리 조각화 관리: 중기 스케줄링은 프로세스를 메모리와 스왑 영역 사이에서 이동시킴으로써 메모리 조각화를 관리하고, 메모리 사용 효율을 개선할 수 있습니다.
    - 이러한 방식으로 중기 스케줄링은 메모리 사용을 최적화하고, 시스템의 전반적인 성능과 사용자 경험을 향상시키는 데 중요한 역할을 합니다.

</div>
</details>
<details>
<summary>단기 스케줄링에서 선점형과 비선점형의 차이점은 무엇인가요?</summary>
<div markdown="1">

- 선점형 스케줄링
    - 정의: 선점형 스케줄링은 이미 CPU를 할당받아 실행 중인 프로세스를 다른 프로세스가 중단시키고 CPU를 선점할 수 있는 스케줄링 방식입니다.
    - 장점: 응답 시간을 단축시킬 수 있으며, 더 높은 우선순위의 작업이 도착했을 때 신속하게 대응할 수 있습니다. 실시간 시스템에서 요구되는 시간 제약 조건을 충족시키기에 적합합니다.
    - 단점: 선점 로직으로 인해 추가적인 오버헤드가 발생할 수 있으며, 자주 선점이 발생하면 프로세스 간의 컨텍스트 스위치로 인한 비용이 증가합니다.
    - 예시: Round Robin, Shortest Remaining Time First(SRTF), Priority Scheduling(선점형)
- 비선점형 스케줄링
    - 정의: 비선점형 스케줄링은 한 번 CPU를 할당받은 프로세스가 해당 CPU 버스트를 완료할 때까지 CPU를 계속 사용할 수 있는 스케줄링 방식입니다. 다른 프로세스가 중간에 CPU를 빼앗을 수 없습니다.
    - 장점: 컨텍스트 스위칭이 덜 발생하여 관련 오버헤드가 줄어들며, 시스템의 예측 가능성이 높아집니다.
    - 단점: 높은 우선순위의 작업이 도착하더라도, 이미 실행 중인 작업이 완료될 때까지 대기해야 하므로 응답 시간이 길어질 수 있습니다. 이는 특히 I/O 집중적인 작업에서 CPU를 오래 동안 사용하지 않을 때 비효율적일 수 있습니다.
    - 예시: First-Come, First-Served(FCFS), Shortest Job First(SJF), Priority Scheduling(비선점형)
- 각 스케줄링 방식의 선택은 시스템의 요구 사항, 작업의 특성, 시스템의 성능 목표 등에 따라 달라집니다. 선점형 스케줄링은 더 높은 응답성과 실시간 처리가 필요한 환경에 적합한 반면, 비선점형 스케줄링은 예측 가능성과 시스템의 단순성을 중시하는 환경에서 유리할 수 있습니다.

</div>
</details>
<details>
<summary>단기 스케줄링이 시스템의 성능에 미치는 영향은 무엇인가요?</summary>
<div markdown="1">

1. 응답 시간(Response Time): 사용자나 시스템이 요청을 제출한 후 첫 번째 응답을 받기까지의 시간입니다. 단기 스케줄링 알고리즘은 프로세스가 빠르게 CPU에 접근할 수 있도록 관리함으로써 응답 시간을 단축할 수 있습니다.
2. 처리량(Throughput): 단위 시간당 완료된 프로세스의 수입니다. 효율적인 단기 스케줄링은 더 많은 작업을 더 빠르게 완료할 수 있도록 하여 처리량을 증가시킵니다.
3. 대기 시간(Waiting Time): 프로세스가 준비 큐에서 실행을 기다리는 시간의 총 합입니다. 적절한 스케줄링 알고리즘을 사용하면 프로세스의 대기 시간을 최소화하여 시스템의 전반적인 효율성을 향상시킬 수 있습니다.
4. 사용률(Utilization): CPU와 같은 시스템 리소스의 사용률입니다. 단기 스케줄링은 CPU가 가능한 한 많은 시간 동안 유휴 상태가 되지 않도록 하여 리소스 사용률을 극대화합니다.

</div>
</details>
<details>
<summary>FCFS(First-Come, First-Served) 스케줄링 알고리즘의 장단점은 무엇인가요?</summary>
<div markdown="1">

- FCFS(First-Come, First-Served) 스케줄링 알고리즘은 가장 간단하고 직관적인 CPU 스케줄링 방법 중 하나입니다. 이 알고리즘은 프로세스가 준비 큐에 도착하는 순서대로 CPU 시간을 할당합니다. FCFS 알고리즘의 장단점을 살펴보겠습니다.

- 장점
    - 단순성과 공정성: FCFS는 구현하기 매우 간단하며, 모든 프로세스가 도착 순서대로 처리되므로 공정한 방식으로 간주됩니다.
    - 예측 가능성: 프로세스의 실행 순서가 명확하므로, 시스템의 동작을 예측하기 쉽습니다.
    - 추가적인 CPU 오버헤드 감소: 프로세스를 선택하는 데 있어 복잡한 계산이 필요 없기 때문에, CPU 스케줄링 오버헤드가 낮습니다.
    - 배치 처리 시스템에 적합: 실행 시간이 비슷한 프로세스들을 순차적으로 처리하는 배치 처리 시스템에서 효율적으로 작동합니다.
- 단점
    - 병목 현상(Convoy Effect): 긴 실행 시간을 가진 프로세스가 먼저 도착할 경우, 이후에 도착하는 짧은 프로세스들이 오랜 시간 대기해야 하는 병목 현상이 발생할 수 있습니다.
    - 비효율적인 CPU 이용: FCFS는 CPU를 효율적으로 이용하지 못하며, CPU가 유휴 상태에 있을 때도 있습니다. 특히 입출력(IO)를 많이 하는 프로세스의 경우 CPU 이용률이 떨어질 수 있습니다.
    - 불평등한 서비스 제공: 짧은 작업이나 중요한 작업이 긴 작업 뒤에 배치되면, 응답 시간이 길어지고 사용자 또는 중요 작업에 불리할 수 있습니다.
    - 평균 대기 시간이 길 수 있음: 특히 짧은 작업이 많고, 이들이 긴 작업 뒤에 오는 경우 평균 대기 시간이 길어질 수 있습니다.

</div>
</details>
<details>
<summary>SJF(Shortest Job First) 알고리즘은 어떤 기준으로 작업을 선택하나요? 그리고 선점형과 비선점형 SJF의 차이는 무엇인가요?</summary>
<div markdown="1">

- SJF(Shortest Job First) 알고리즘은 작업(프로세스)의 실행 시간을 기준으로 CPU 스케줄링을 결정하는 알고리즘입니다. 이 알고리즘의 목표는 평균 대기 시간을 최소화하는 것입니다. SJF는 실행될 프로세스의 총 실행 시간을 미리 알고 있다고 가정하고, 가장 짧은 실행 시간을 가진 프로세스부터 먼저 실행합니다.
- 작업 선택 기준
    - SJF 알고리즘에서는 각 프로세스의 예상 실행 시간을 기준으로 합니다. 준비 상태의 프로세스 중에서 실행 시간이 가장 짧은 프로세스가 CPU를 차지하게 됩니다. 이로 인해 평균 대기 시간이 다른 스케줄링 방법에 비해 상대적으로 짧아질 수 있습니다.

- 선점형(SJF)과 비선점형(SJF)의 차이
    - 비선점형 SJF(Non-Preemptive SJF): 이 방식에서는 한 번 CPU를 할당받은 프로세스가 실행을 완료할 때까지 CPU를 계속 사용합니다. 새로운 프로세스가 도착하더라도, 현재 실행 중인 프로세스가 완료될 때까지 대기해야 합니다. 이 방식은 구현이 비교적 간단하지만, 긴 프로세스가 실행 중일 때 짧은 프로세스가 도착하면 이러한 짧은 프로세스들이 긴 대기 시간을 겪게 됩니다.
    - 선점형 SJF(Preemptive SJF), 또는 SRTF(Shortest Remaining Time First): 선점형 SJF에서는 현재 실행 중인 프로세스보다 더 짧은 실행 시간을 가진 새로운 프로세스가 도착하면, 현재 프로세스의 실행을 중단(선점)하고 새로운 프로세스에게 CPU를 할당합니다. 이러한 방식은 더욱 공정하며 평균 대기 시간을 더욱 줄일 수 있지만, 선점으로 인해 추가적인 컨텍스트 스위칭이 발생할 수 있어 오버헤드가 증가할 수 있습니다.
- 선점형 SJF는 평균 대기 시간을 더욱 최소화할 수 있는 장점이 있지만, 실행 중인 프로세스를 중단하고 다른 프로세스로 전환하는 과정에서 발생하는 오버헤드를 고려해야 합니다. 반면, 비선점형 SJF는 구현이 간단하고 예측 가능하지만, 일부 프로세스에게는 불리할 수 있습니다.

</div>
</details>
<details>
<summary>Round Robin 스케줄링이란 무엇이며, 타임퀀텀의 크기가 성능에 어떤 영향을 미치나요?</summary>
<div markdown="1">

- Round Robin(RR) 스케줄링은 시분할 시스템을 위해 설계된 프로세스 스케줄링 알고리즘입니다. 이 방식은 모든 프로세스에게 동등한 시간(타임퀀텀 또는 타임 슬라이스라고 함) 동안 CPU를 사용할 기회를 제공함으로써 공정성을 보장합니다. 프로세스가 준비 큐에 도착하면, 순환 순서로 CPU 시간을 할당받으며, 할당된 시간 동안 작업을 완료하지 못하면 준비 큐의 맨 끝으로 이동하여 다시 자신의 차례가 올 때까지 기다립니다.

- 타임퀀텀의 크기가 성능에 미치는 영향
    - 타임퀀텀의 크기는 Round Robin 스케줄링의 성능에 중요한 영향을 미칩니다. 타임퀀텀의 크기를 조정함으로써 시스템의 응답 시간, CPU 이용률, 컨텍스트 스위칭 오버헤드 등 여러 성능 지표를 최적화할 수 있습니다.
    1. 타임퀀텀이 너무 클 때:
        - 타임퀀텀이 너무 크면, RR 스케줄링은 사실상 FCFS(First-Come, First-Served) 스케줄링과 유사해집니다.
        - 프로세스가 자신의 타임퀀텀 동안 작업을 완료할 수 있어, 컨텍스트 스위칭이 줄어듭니다.
        - 그러나, 응답 시간이 길어질 수 있으며, 짧은 작업을 기다리게 하는 등의 공정성 문제가 발생할 수 있습니다.
    2. 타임퀀텀이 너무 작을 때:
        - 타임퀀텀이 너무 작으면, 프로세스 간의 자주 전환되어 컨텍스트 스위칭 오버헤드가 증가합니다.
        - 이는 CPU 이용률을 낮출 수 있으며, 시스템의 전반적인 성능을 저하시킬 수 있습니다.
    - 그러나, 작은 타임퀀텀은 더 빠른 응답 시간을 제공하며, 시스템이 더 반응적으로 느껴질 수 있습니다.
    - 적절한 타임퀀텀의 선택은 시스템의 요구사항과 환경에 따라 달라질 수 있습니다. 일반적으로, 타임퀀텀은 프로세스의 평균 실행 시간보다 약간 큰 값을 설정하는 것이 좋습니다. 이렇게 함으로써 공정성과 CPU 이용률 사이의 균형을 찾고, 시스템의 전반적인 성능을 최적화할 수 있습니다. 실험과 조정을 통해 각각의 시스템에 맞는 최적의 타임퀀텀 값을 찾는 것이 중요합니다.

</div>
</details>
<details>
<summary>SRT(Shortest Remaining Time) 알고리즘의 작동 원리와 장단점은 무엇인가요?</summary>
<div markdown="1">

- SRT(Shortest Remaining Time) 알고리즘은 선점형 스케줄링 알고리즘으로, 각 프로세스의 남은 실행 시간을 기준으로 CPU 스케줄링을 결정합니다. 이 방법은 SJF(Shortest Job First) 알고리즘의 선점형 버전이며, 때로는 SRTF(Shortest Remaining Time First)라고도 합니다.
- 작동 원리
    1. 선점 기반: 현재 실행 중인 프로세스보다 짧은 남은 실행 시간을 가진 새로운 프로세스가 도착하면, 현재 프로세스의 실행을 중단하고 새 프로세스에 CPU를 할당합니다.
    2. 남은 실행 시간 비교: 준비 큐에 있는 모든 프로세스의 남은 실행 시간을 주기적으로 비교하여, 가장 짧은 남은 실행 시간을 가진 프로세스에 CPU를 할당합니다.
    3. 동적 스케줄링: 프로세스의 실행 도중에도 상황에 따라 현재 실행 중인 프로세스를 변경할 수 있기 때문에, 프로세스의 도착과 실행 상황에 따라 동적으로 스케줄링이 이루어집니다.
- 장점
    1. 효율적인 CPU 이용: 짧은 작업에 우선순위를 부여함으로써, 평균 대기 시간과 응답 시간을 최소화합니다.
    2. 빠른 프로세스 처리: 짧은 프로세스는 빠르게 처리되므로, 사용자나 시스템에 대한 빠른 피드백 제공이 가능합니다.
    3. 병목 현상 감소: 긴 프로세스가 시스템을 점유하는 시간이 줄어들어, 시스템의 병목 현상을 완화할 수 있습니다.
- 단점
    1. 별도의 정보 필요: 각 프로세스의 정확한 남은 실행 시간을 알아야 하므로, 실제 환경에서 추정하기 어렵습니다.
    2. 스타베이션: 긴 작업이 계속해서 밀려나, 실행될 기회를 얻지 못할 수 있는 문제가 있습니다.
    3. 오버헤드 증가: 선점형 스케줄링은 자주 컨텍스트 스위칭이 발생하므로, 오버헤드가 증가할 수 있습니다.
- SRT 알고리즘은 특히 평균 대기 시간을 중요시하는 환경에서 유용합니다. 그러나 긴 프로세스에 대한 공정성 문제와 실행 시간 추정의 어려움 등을 고려하여 적용해야 합니다.

</div>
</details>
<details>
<summary>우선순위 스케줄링(Priority scheduling)에서 발생할 수 있는 문제는 무엇이며, 어떻게 해결할 수 있나요?</summary>
<div markdown="1">

- 우선순위 스케줄링(Priority Scheduling)은 프로세스에 우선순위를 할당하고, 가장 높은 우선순위를 가진 프로세스부터 CPU를 할당하는 스케줄링 방식입니다. 이 방식은 효율적이고 특정 작업의 중요도를 반영할 수 있다는 장점이 있지만, 몇 가지 문제점도 동반합니다.
- 발생할 수 있는 문제
    1. 스타베이션(기아 현상): 낮은 우선순위를 가진 프로세스가 높은 우선순위의 프로세스들에 의해 계속해서 밀려나 실행될 기회를 얻지 못하는 현상입니다. 시스템에서 계속해서 높은 우선순위의 프로세스가 도착한다면, 낮은 우선순위의 프로세스는 무한히 대기하게 될 수 있습니다.
    2. 우선순위 역전(Priority Inversion): 낮은 우선순위의 프로세스가 공유 자원을 점유하고 있고, 이 자원이 높은 우선순위의 프로세스에 의해 필요로 되는 경우, 낮은 우선순위의 프로세스가 높은 우선순위의 프로세스보다 더 오랜 시간 동안 CPU를 점유할 수 있는 현상입니다. 이는 시스템의 응답성을 저하시킬 수 있습니다.
- 해결 방안
    1. 에이징(Aging): 스타베이션 문제를 해결하기 위해 낮은 우선순위의 프로세스에 대해 시간이 지남에 따라 점차 우선순위를 증가시키는 방법입니다. 이를 통해 모든 프로세스가 결국에는 실행될 수 있는 기회를 보장합니다.
    2. 우선순위 상속(Priority Inheritance): 우선순위 역전 문제를 해결하기 위한 방법으로, 높은 우선순위의 프로세스가 필요로 하는 자원을 점유하고 있는 낮은 우선순위의 프로세스가 임시로 높은 우선순위의 값을 상속받아, 자원을 빨리 해제할 수 있도록 합니다. 이로써 우선순위 역전 문제를 완화할 수 있습니다.

</div>
</details>
<details>
<summary>멀티레벨 큐(Multilevel Queue) 스케줄링 방식이란 무엇이며, 어떤 시나리오에서 유용한가요?</summary>
<div markdown="1">

- 멀티레벨 큐(Multilevel Queue) 스케줄링 방식은 프로세스를 여러 개의 큐에 분류하여 관리하는 스케줄링 방법입니다. 이 방식은 프로세스의 특성(예: 우선순위, 프로세스 타입, 메모리 요구량 등)에 따라 다른 큐에 할당하고, 각 큐는 자신의 스케줄링 알고리즘(예: 라운드 로빈, 우선순위 스케줄링 등)을 가집니다.
- 구조 및 작동 원리
    1. 큐의 분류: 시스템은 여러 개의 큐를 생성하고, 각 큐는 특정한 유형의 프로세스를 위한 것입니다. 예를 들어, 시스템 프로세스, 대화형 사용자 프로세스, 배치 작업 등으로 구분할 수 있습니다.
    2. 큐별 스케줄링 정책: 각 큐는 독립적인 스케줄링 정책을 가집니다. 예를 들어, 높은 우선순위의 큐는 우선순위 스케줄링을 사용하고, 배치 작업 큐는 FCFS(First Come, First Served) 방식을 사용할 수 있습니다.
    3. 고정된 우선순위: 각 큐는 고정된 우선순위를 가지며, CPU는 높은 우선순위의 큐부터 낮은 우선순위의 큐까지 순차적으로 프로세스를 선택하여 실행합니다.
- 멀티레벨 큐 스케줄링이 유용한 시나리오
    1. 다양한 프로세스 유형을 관리해야 하는 시스템: 멀티레벨 큐 스케줄링은 프로세스의 유형이나 요구 사항이 서로 다른 다양한 작업을 효율적으로 관리해야 하는 환경에서 유용합니다.
    2. 실시간 및 대화형 작업의 우선 처리가 필요한 경우: 실시간 처리가 필요한 작업이나 사용자의 입력을 기다리는 대화형 작업에 높은 우선순위를 부여하여, 이러한 작업이 빠르게 처리될 수 있도록 할 수 있습니다.
    3. 시스템의 성능과 반응성을 높이고자 하는 경우: 다양한 유형의 작업에 최적화된 스케줄링 정책을 적용함으로써, 전체 시스템의 성능과 반응성을 향상시킬 수 있습니다.
- 멀티레벨 큐 스케줄링은 다양한 요구 사항을 가진 프로세스들을 효율적으로 관리할 수 있게 해주지만, 각 큐 간의 이동이 제한되어 있어 유연성이 다소 떨어지는 단점이 있습니다. 따라서, 시스템의 요구 사항과 특성을 충분히 고려하여 이 스케줄링 방식을 적용해야 합니다.

</div>
</details>
<details>
<summary>멀티레벨 피드백 큐(Multilevel Feedback Queue) 스케줄링이 멀티레벨 큐 스케줄링과 어떻게 다른가요?</summary>
<div markdown="1">

- 멀티레벨 큐 스케줄링
    - 멀티레벨 큐 스케줄링에서는 프로세스가 시스템에 들어올 때 특정한 큐에 할당되며, 그 후로는 그 큐에 고정되어 다른 큐로 이동할 수 없습니다. 각 큐는 자체적인 스케줄링 알고리즘(예: 라운드 로빈, 우선순위 스케줄링 등)을 가지고 있으며, 큐들 사이에는 고정된 우선순위 순서가 있어서 CPU 접근성이 결정됩니다. 이 방식은 프로세스의 유형이 명확하고, 각 유형별로 다른 스케줄링 요구가 있는 경우에 적합합니다.
- 멀티레벨 피드백 큐 스케줄링
    - 멀티레벨 피드백 큐 스케줄링에서는 프로세스가 실행되는 동안 그 특성에 따라 다른 큐로 이동할 수 있습니다. 이 방식은 프로세스의 실행 시간, 대기 시간 등의 실행 특성에 따라 프로세스의 우선순위를 동적으로 조정합니다. 목적은 시스템의 반응 시간을 최소화하고 CPU 사용률을 최대화하는 것입니다. 프로세스가 짧은 시간 동안 CPU를 사용하면 높은 우선순위 큐로 이동할 수 있고, CPU를 오랫동안 사용하면 낮은 우선순위의 큐로 이동시킵니다. 이런 방식은 프로세스의 다양한 요구와 특성을 더 유연하게 수용할 수 있도록 해줍니다.
- 주요 차이점
    - 큐 간 이동: 멀티레벨 큐 스케줄링에서는 프로세스가 한 번 큐에 할당되면 그 큐에 고정됩니다. 반면, 멀티레벨 피드백 큐 스케줄링에서는 프로세스가 다른 큐로 이동할 수 있어, 그 실행 특성에 따라 우선순위가 변경될 수 있습니다.
    - 유연성: 멀티레벨 피드백 큐 스케줄링은 프로세스의 동적인 특성을 반영할 수 있어 유연성이 더 높습니다. 멀티레벨 큐 스케줄링은 비교적 고정적인 프로세스 분류에 기반합니다.

</div>
</details>
<details>
<summary>타 스케줄링과 비교하여, 멀티레벨 피드백 큐는 어떤 문제점들을 해결한다고 볼 수 있을까요?</summary>
<div markdown="1">

1. 별도의 프로세스 유형 처리
    - 문제: 단일 큐나 단순 우선순위 스케줄링 방식에서는 CPU 집약적인 작업과 I/O 집약적인 작업 사이의 균형을 맞추기 어렵습니다. 이 때문에 어떤 유형의 작업이 다른 작업에 비해 과도하게 우선시되거나 지연될 수 있습니다.
    - 해결: MFQ는 다양한 우선순위의 큐를 사용하고, 프로세스의 특성에 따라 동적으로 큐를 이동시키므로, CPU 및 I/O 요구 사항이 다양한 프로세스를 보다 효율적으로 처리합니다.
2. 기아 현상(Starvation) 방지
- 문제: 우선순위 스케줄링에서 낮은 우선순위의 프로세스는 높은 우선순위의 프로세스가 계속해서 들어올 경우 CPU를 할당받지 못하는 기아 현상에 빠질 수 있습니다.
- 해결: MFQ는 시간이 지남에 따라 대기하는 프로세스의 우선순위를 점진적으로 높여주어, 모든 프로세스가 결국에는 CPU 시간을 얻을 수 있도록 보장합니다.
3. 시스템 반응 시간 최적화
    - 문제: 일괄 처리 시스템이나 단일 큐 스케줄링은 인터랙티브한 작업에 대한 시스템의 반응 시간을 최적화하는 데 한계가 있습니다.
    - 해결: MFQ는 짧은 작업이나 인터랙티브한 프로세스를 빠르게 처리할 수 있는 높은 우선순위 큐를 제공함으로써 사용자에게 더 나은 반응 시간을 제공합니다.
4. 유연성과 효율성
    - 문제: 고정된 스케줄링 정책은 다양한 종류의 작업 부하와 프로세스 요구 사항의 변화에 효과적으로 대응하기 어렵습니다.
    - 해결: MFQ 스케줄링은 프로세스의 행동을 기반으로 우선순위를 동적으로 조정함으로써, 다양한 시나리오에서 시스템의 성능을 유지하고 최적화할 수 있는 유연성을 제공합니다.

</div>
</details>



<br>

# 📍 Reference
- https://github.com/bombo-dev/CS-JAVA-Study/blob/main/Operating%20System/CPU%20Sheduling.md