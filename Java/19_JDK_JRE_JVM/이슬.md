# 📍 키워드
- JDK, JRE, JVM
    - JDK vs JRE vs JVM
    - 컴파일 과정
    - 컴파일 언어 vs 인터프리터 언어
    - GC
        - 동작과정
        - 알고리즘

<br>

# 📍 예상 질문
<details>
<summary>JDK, JRE, JVM 각각에 대해 설명해주세요.</summary>
<div markdown="1">

- JDK (Java Development Kit)
    - JDK는 자바 개발 키트로, JRE에 포함된 모든 것과 함께 자바 애플리케이션을 개발할 때 필요한 도구들(예: 컴파일러, 디버거 등)을 포함합니다. JDK는 자바 프로그램을 개발, 컴파일, 디버그 및 실행하는 데 필요한 통합 환경을 제공합니다. 개발자가 자바로 소프트웨어를 개발하려면 JDK를 설치해야 합니다.
- JRE (Java Runtime Environment)
    - JRE는 자바 런타임 환경으로, JVM, 라이브러리 및 자바 애플리케이션을 실행하는 데 필요한 다른 구성 요소들을 포함합니다. 즉, 자바 애플리케이션을 실행하기 위해 필요한 모든 것을 제공합니다. 하지만, JRE에는 자바 애플리케이션을 개발하기 위한 도구(예: 컴파일러)는 포함되어 있지 않습니다.
- JVM (Java Virtual Machine)
    - JVM은 자바 가상 머신으로, 자바 바이트코드(.class 파일)를 실행하는 역할을 합니다. JVM은 플랫폼 독립적이며, 다양한 운영 체제에서 자바 애플리케이션을 실행할 수 있도록 해줍니다. 즉, 한 번 작성된 자바 코드는 어디서든 실행될 수 있는 "Write Once, Run Anywhere" (WORA)의 원칙을 실현합니다. JVM은 메모리 관리, 가비지 컬렉션, 보안 관리 등도 담당합니다.

</div>
</details>
<details>
<summary>컴파일 언어와 인터프리터 언어의 주요 차이점은 무엇인가요?</summary>
<div markdown="1">

- 컴파일 언어
    - 컴파일 언어는 개발자가 작성한 소스 코드를 기계어로 번역하는 컴파일 과정을 거치는 프로그래밍 언어입니다. 이 과정은 컴파일러에 의해 수행되며, 소스 코드 전체를 한 번에 기계어로 번역합니다.
    - 장점:
        - 실행 속도가 빠릅니다. 컴파일 과정에서 최적화가 이루어지기 때문에, 실행 파일은 직접 기계어로 작성된 코드에 비해 매우 효율적으로 실행됩니다.
        - 실행 파일이 독립적입니다. 컴파일을 통해 생성된 실행 파일은 별도의 프로그램으로 실행되며, 실행 환경에 따른 추가적인 번역 과정이 필요 없습니다.
    - 단점:
        - 컴파일 과정이 필요하기 때문에, 개발 중인 프로그램의 테스트가 비교적 느릴 수 있습니다.
        - 플랫폼에 종속적일 수 있습니다. 다른 운영 체제나 환경에서 실행하려면 해당 환경에 맞게 다시 컴파일해야 합니다.
    - 예시: C, C++, Rust, Go 등
- 인터프리터 언어
    - 인터프리터 언어는 개발자가 작성한 소스 코드를 한 줄씩 읽어서 바로 실행하는 방식의 프로그래밍 언어입니다. 인터프리터는 프로그램을 실행할 때마다 소스 코드를 기계어로 번역합니다.
    - 장점:
        - 개발 및 테스트 주기가 빠릅니다. 소스 코드를 즉시 실행할 수 있기 때문에, 변경 사항을 바로 확인할 수 있습니다.
        - 플랫폼 독립적입니다. 인터프리터만 있으면 다양한 환경에서 동일한 소스 코드를 실행할 수 있습니다.
    - 단점:
        - 실행 속도가 컴파일 언어에 비해 느립니다. 프로그램이 실행될 때마다 소스 코드의 번역 과정을 거쳐야 하기 때문입니다.
        - 실행 시 인터프리터가 항상 필요합니다. 이는 실행 환경을 구성하는 데 추가적인 요구 사항을 의미할 수 있습니다.
    - 예시: Python, JavaScript, Ruby 등
- 컴파일 언어와 인터프리터 언어의 주요 차이는 소스 코드의 번역 및 실행 방식에 있습니다. 컴파일 언어는 전체 코드를 미리 기계어로 번역하여 실행 속도를 최적화하는 반면, 인터프리터 언어는 코드를 실행 시점에 한 줄씩 번역하여 유연성과 개발 효율성을 높입니다. 

</div>
</details>
<details>
<summary>자바는 컴파일 언어와 인터프리터 언어 중 어느 쪽에 속하나요?</summary>
<div markdown="1">

- 자바(Java)는 그 특성 때문에 컴파일 언어와 인터프리터 언어의 중간 형태로 분류될 수 있습니다. 자바는 개발 과정에서 컴파일 언어의 특징을 지니면서, 실행 과정에서는 인터프리터 언어의 특성을 보이기 때문입니다.
- 자바의 컴파일 과정
    - 자바 소스 코드(.java 파일)는 먼저 컴파일러에 의해 바이트코드(.class 파일)로 컴파일됩니다. 이 과정은 컴파일 언어의 특징을 나타냅니다.
    - 바이트코드는 플랫폼에 독립적이며, 어떤 자바 가상 머신(JVM)에서도 실행될 수 있도록 설계되었습니다.
- 자바의 실행 과정
    - 컴파일된 바이트코드는 자바 가상 머신(JVM)에서 실행됩니다. JVM은 바이트코드를 인터프리트하거나, 필요에 따라 Just-In-Time(JIT) 컴파일을 통해 특정 플랫폼의 기계어로 변환하여 실행합니다. 이 과정은 인터프리터 언어의 특성을 보입니다.
- 따라서 자바는 개발 단계에서는 컴파일 언어의 특성을, 실행 단계에서는 인터프리터 언어의 특성을 모두 가지고 있어, 두 범주 사이의 고유한 위치를 차지합니다. 이러한 특성 때문에 자바는 다양한 환경에서의 호환성과 효율성을 동시에 제공할 수 있습니다.

</div>
</details>
<details>
<summary>자바의 컴파일 과정을 설명해주세요.</summary>
<div markdown="1">

1. 소스 코드 작성
    - 개발자는 .java 확장자를 가진 파일에 자바 언어로 소스 코드를 작성합니다.
2. 컴파일
    - 작성된 자바 소스 코드는 자바 컴파일러(javac)에 의해 컴파일됩니다. 이 과정에서 컴파일러는 소스 코드를 분석하고, 문법 오류가 없는지 검사한 뒤, 바이트코드라는 중간 형태의 코드로 변환합니다. 이 바이트코드는 .class 파일에 저장되며, 특정 하드웨어나 운영 체제에 종속되지 않는 플랫폼 독립적인 코드입니다.
3. 로딩
    - 자바 가상 머신(JVM)이 프로그램을 실행할 때, .class 파일로부터 바이트코드를 메모리로 로딩합니다. 클래스 로더는 이 바이트코드를 로드하고, 링크를 통해 다른 클래스나 메서드와의 참조를 해결합니다.
4. 검증
    - 로딩된 바이트코드는 안전성을 확인하기 위해 검증 과정을 거칩니다. 이 과정에서 JVM은 바이트코드가 올바른 형식을 가지고 있으며, 모든 규칙을 준수하는지 확인합니다. 이는 보안, 예외 처리, 형태 검사 등을 포함합니다.
5. 해석 또는 JIT 컴파일
    - 검증을 통과한 바이트코드는 실행 엔진에 의해 실행됩니다. 실행 엔진은 인터프리터 방식을 사용하여 바이트코드를 한 줄씩 읽고 실행하거나, JIT 컴파일러를 사용하여 바이트코드의 일부를 더 빠른 네이티브 코드로 변환하여 실행합니다.
    - JIT 컴파일러는 프로그램 실행 중에 바이트코드의 "핫 스팟"(자주 실행되는 코드)을 식별하고, 이를 최적화된 네이티브 코드로 변환하여 프로그램의 실행 속도를 향상시킵니다.
7. 실행
    - 최종적으로, JVM은 바이트코드 또는 JIT 컴파일을 통해 생성된 기계어 코드를 실행하며, 개발자가 작성한 프로그램이 사용자에게 결과를 제공합니다.

</div>
</details>
<details>
<summary>가비지 컬렉션(GC)의 주요 목적은 무엇인가요?</summary>
<div markdown="1">

- 가비지 컬렉션(Garbage Collection, GC)의 주요 목적은 프로그램이 동적으로 할당한 메모리 영역 중에서 더 이상 사용하지 않는 영역을 자동으로 찾아내어 해제함으로써, 사용가능한 메모리 공간을 효율적으로 관리하는 것입니다. 구체적으로, 가비지 컬렉션은 다음과 같은 목적을 가지고 있습니다:
1. 메모리 누수 방지: 프로그램 실행 중 동적으로 할당된 메모리가 적절히 해제되지 않으면, 점차 사용할 수 있는 메모리 공간이 줄어들어 결국에는 시스템의 성능 저하 또는 실행 실패로 이어질 수 있습니다. 가비지 컬렉션은 이러한 메모리 누수를 방지하여 프로그램의 안정성과 성능을 유지합니다.
2. 메모리 관리의 자동화: 메모리 관리는 프로그래밍에서 매우 중요하지만 복잡한 작업 중 하나입니다. 개발자가 직접 메모리를 할당하고 해제하는 과정에서 실수가 발생하기 쉽습니다. 가비지 컬렉션은 이러한 메모리 관리 작업을 자동화함으로써, 개발자가 메모리 관리에 드는 시간과 노력을 줄이고, 실수로 인한 버그 발생 가능성을 낮출 수 있도록 도와줍니다.
3. 프로그램의 안정성 향상: 메모리를 잘못 해제하거나, 해제하지 않은 채로 사용하는 등의 문제는 프로그램의 오류나 충돌을 일으킬 수 있습니다. 가비지 컬렉션은 이러한 문제를 자동으로 관리하여 프로그램의 안정성과 신뢰성을 향상시킵니다.
4. 메모리 재사용 촉진: 사용하지 않는 메모리 영역을 자동으로 해제함으로써, 가비지 컬렉션은 이러한 메모리를 다시 사용할 수 있도록 만듭니다. 이는 프로그램이 필요로 하는 메모리를 보다 효율적으로 사용할 수 있게 하여, 전체 시스템의 효율성을 증가시킵니다.

</div>
</details>
<details>
<summary>GC의 동작 원리에 대해 설명해주세요.</summary>
<div markdown="1">

1. 객체의 할당
    - 자바 애플리케이션에서 새 객체가 생성되면, JVM의 힙 메모리에 할당됩니다. 힙은 크게 두 부분으로 나뉘는데, 하나는 젊은 세대(Young Generation)이고 다른 하나는 늙은 세대(Old Generation)입니다. 새로 생성된 객체는 대부분 젊은 세대의 에덴(Eden) 영역에 위치합니다.
2. 젊은 세대에서의 GC(Minor GC)
    - 젊은 세대의 메모리가 가득 차면, Minor GC가 발생합니다. 먼저, 에덴 영역에서 살아있는 객체들을 서바이버(Survivor) 영역으로 복사합니다. 이미 서바이버 영역에 있는 객체 중에서도 살아있는 것들은 다른 서바이버 영역으로 이동합니다. 이 과정에서 참조되지 않는 객체들은 메모리에서 제거됩니다. 객체가 일정 횟수 이상 서바이버 영역을 거쳐 살아남으면, 늙은 세대로 이동하게 됩니다.
3. 늙은 세대에서의 GC(Major GC 또는 Full GC)
    - 늙은 세대의 메모리가 가득 차면, Major GC 또는 Full GC가 발생합니다. 이 과정은 젊은 세대의 GC보다 시간이 많이 소요됩니다. Major GC는 늙은 세대에 있는 모든 객체들을 검사하여, 더 이상 사용되지 않는 객체를 찾아내 메모리에서 제거합니다.
    
> GC가 실행될 때, JVM은 애플리케이션의 모든 스레드를 일시 정지시키는데, 이를 "Stop-The-World" 현상이라고 합니다. GC 작업이 끝난 후에 애플리케이션의 실행이 재개됩니다.

</div>
</details>
<details>
<summary>Survivor 영역은 왜 2개 인가요?</summary>
<div markdown="1">

- Survivor 영역이 두 개인 이유는, 가비지 컬렉션(GC)의 효율성을 극대화하기 위한 것입니다. 젊은 세대(Young Generation)의 메모리 관리에는 주로 "복사(Copy)" 가비지 컬렉션 알고리즘이 사용됩니다. 이 알고리즘은 살아있는 객체만을 새로운 위치로 복사하고 나머지는 모두 버리는 방식으로, 메모리를 효율적으로 정리할 수 있게 합니다. 이 과정에서 Survivor 영역이 중요한 역할을 합니다.
- 젊은 세대는 크게 세 부분으로 구성됩니다: 하나의 에덴(Eden) 영역과 두 개의 서바이버(Survivor) 영역(S0와 S1). 가비지 컬렉션이 발생할 때, 에덴 영역과 한쪽 서바이버 영역(S0)에서 살아남은 객체들이 다른 서바이버 영역(S1)으로 복사됩니다. 이때, 복사 대상이 되는 서바이버 영역은 번갈아 가면서 사용됩니다.
- Survivor 영역이 두 개인 주된 이유는 다음과 같습니다:
    1. 효율성 증가
        - 두 개의 서바이버 영역을 사용함으로써, 살아있는 객체만을 대상으로 빠르게 메모리를 이동하고 정리할 수 있습니다. 이 과정에서, 대부분의 객체는 젊은 세대에서 생명주기가 끝나므로, 불필요한 객체들을 효율적으로 처리할 수 있습니다.
    2. 객체의 생존 기간 파악
        - 객체가 여러 번의 GC를 거치면서도 살아남을 경우, 그 객체는 점점 더 오래 살아남을 가능성이 높다고 판단할 수 있습니다. 이러한 객체들을 늙은 세대(Old Generation)로 이동시키기 전에, 일정 횟수 이상 Survivor 영역을 오가게 함으로써, 실제로 오래 살아남을 객체들만을 늙은 세대로 이동시키게 됩니다. 이는 늙은 세대에서의 가비지 컬렉션 빈도를 줄이는 데 도움을 줍니다.
    3. 메모리 단편화 방지
        - 객체를 다른 영역으로 복사하는 과정에서 메모리 단편화를 효과적으로 방지할 수 있습니다. 단편화된 메모리는 프로그램의 성능 저하를 초래할 수 있으므로, 이를 방지하는 것은 중요합니다.

</div>
</details>
<details>
<summary>젊은 세대와 늙은 세대를 나누는 이유는 무엇인가요?</summary>
<div markdown="1">

- 대부분의 객체는 생성된 직후에 빠르게 사용되지 않게 되며(즉, "대부분의 객체는 젊게 죽는다"), 소수의 객체만이 더 오래 사용됩니다. 이런 특성을 이용하여 JVM은 다음과 같은 이유로 메모리를 젊은 세대와 늙은 세대로 나눕니다:
1. 가비지 컬렉션의 효율성 증가
    - 젊은 세대에서는 객체가 빠르게 생성되고 소멸되므로, 자주 발생하는 가비지 컬렉션(Minor GC)을 통해 빠르게 메모리를 정리할 수 있습니다. 젊은 세대의 GC는 대부분의 경우 빠르게 처리되어 애플리케이션의 성능에 큰 영향을 주지 않습니다.
    - 늙은 세대에서는 더 오래 살아남은 객체들이 모입니다. 이 영역에서의 가비지 컬렉션(Major GC 또는 Full GC)은 더 드물게 발생하지만, 처리 시간이 길어질 수 있습니다. 따라서, 늙은 세대로 객체가 이동하는 것을 최소화함으로써 GC의 부담을 줄일 수 있습니다.
2. 메모리 관리 최적화
    - 객체의 생명주기에 따라 메모리를 관리함으로써, JVM은 메모리를 더 효율적으로 사용할 수 있습니다. 젊은 세대에서 빈번히 발생하는 가비지 컬렉션으로 인해 대량의 메모리가 빠르게 회수되고, 늙은 세대에서는 더 안정적인 메모리 사용이 가능해집니다.
3. 성능 최적화
    - 젊은 세대와 늙은 세대를 나눔으로써, 가비지 컬렉션에 의한 애플리케이션의 일시 정지 시간(Stop-The-World)을 최소화할 수 있습니다. 젊은 세대의 가비지 컬렉션은 빠르게 처리되며, 늙은 세대의 가비지 컬렉션은 더 희귀하게 발생하므로, 전반적인 애플리케이션의 성능이 향상됩니다.

</div>
</details>
<details>
<summary>Minor GC와 MajorGC 의 차이점에 대해 말씀해주세요.</summary>
<div markdown="1">

- Minor GC
    - 대상 영역: 젊은 세대(Young Generation)에만 적용됩니다. 젊은 세대는 에덴(Eden) 영역과 두 개의 서바이버(Survivor) 영역으로 구성됩니다.
    - 발생 빈도: Minor GC는 자주 발생합니다. 이는 대부분의 객체가 생성된 직후에 금방 사용되지 않게 되는 경향이 있기 때문입니다("대부분의 객체는 젊게 죽는다").
    - 처리 속도: 일반적으로 Minor GC는 빠르게 처리됩니다. 살아남은 객체는 서바이버 영역 중 하나로 이동되고, 대부분의 메모리가 빠르게 회수됩니다.
    - 영향: 애플리케이션의 일시 정지 시간이 짧아, 애플리케이션의 성능에 미치는 영향이 적습니다.
- Major GC
    - 대상 영역: 늙은 세대(Old Generation)에 적용됩니다. 늙은 세대는 젊은 세대보다 훨씬 크며, 여기에는 오랜 시간 동안 살아남은 객체들이 모입니다.
    - 발생 빈도: Major GC는 Minor GC보다 훨씬 드물게 발생합니다. 늙은 세대의 공간이 가득 차게 되면 Major GC가 트리거됩니다.
    - 처리 속도: Major GC는 Minor GC보다 시간이 더 오래 걸립니다. 늙은 세대의 메모리를 회수하고, 단편화를 줄이며, 살아남은 객체들을 재배치하는 복잡한 과정을 포함하기 때문입니다.
    - 영향: Major GC는 애플리케이션의 일시 정지 시간을 길게 만들 수 있으며, 이는 애플리케이션의 성능에 눈에 띄게 영향을 줄 수 있습니다. 때로는 Full GC라고도 불리며, 젊은 세대와 늙은 세대 모두를 대상으로 가비지 컬렉션이 수행될 때 이 용어가 사용됩니다.
- 차이점 요약
    - 대상 영역: Minor GC는 젊은 세대, Major GC는 늙은 세대(때로는 전체 힙).
    - 발생 빈도: Minor GC는 자주 발생, Major GC는 드물게 발생.
    - 처리 속도와 영향: Minor GC는 빠르고 영향이 적음, Major GC는 처리 시간이 길고 성능에 더 큰 영향을 줌.

</div>
</details>
<details>
<summary>가비지 컬렉션이 수행될 때 애플리케이션 성능에 미치는 영향은 무엇인가요?</summary>
<div markdown="1">

- GC는 필요한 과정이지만, 실행 시간 동안 애플리케이션의 작업을 일시적으로 중단시킬 수 있으며, 이는 "가비지 컬렉션 퍼즈(Garbage Collection Pause)"라고 불립니다. GC의 영향은 다음과 같은 여러 측면에서 나타날 수 있습니다:
1. 응답 시간(Response Time)
    - GC가 실행될 때, 특히 "Stop-The-World" GC 이벤트가 발생하면, JVM은 모든 애플리케이션 스레드를 일시 정지시킵니다. 이로 인해 사용자 요청에 대한 응답 시간이 길어질 수 있으며, 이는 특히 실시간성이 중요한 애플리케이션에서 문제가 될 수 있습니다.
2. 처리량(Throughput)
    - GC 작업에는 CPU 시간이 소요됩니다. GC가 자주 발생하거나 오래 걸리는 경우, 애플리케이션 로직을 처리하는 데 사용할 수 있는 CPU 자원이 줄어들게 됩니다. 이는 전체 애플리케이션의 처리량을 감소시킬 수 있습니다.
3. 메모리 사용량
    - GC는 사용되지 않는 객체를 정리함으로써 힙 메모리를 회수합니다. GC가 효율적으로 수행되지 않는 경우, 메모리 누수(memory leak)나 메모리 부족(out of memory) 상황이 발생할 수 있습니다. 이는 애플리케이션의 성능 저하 또는 비정상 종료를 초래할 수 있습니다.
4. 애플리케이션의 일관성
    - GC 퍼즈 동안 애플리케이션의 일관성 유지가 어려울 수 있습니다. 실시간 처리가 중요한 애플리케이션에서는 GC로 인한 지연이 데이터 처리의 신뢰성을 저하시킬 수 있습니다.

</div>
</details>

# 📍 Reference