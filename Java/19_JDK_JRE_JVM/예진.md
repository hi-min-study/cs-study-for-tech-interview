# 19_JDK_JRE_JVM

- JDK, JRE, JVM
    - JDK vs JRE vs JVM
    - 컴파일 과정
    - 컴파일 언어 vs 인터프리터 언어
    - GC
        - 동작과정
        - 알고리즘

##


# 면접 질문

### JDK, JRE, JVM에 대해 설명해주세요.

JDK는 자바 개발키트(Java Development Kit)의 약자로 개발자들이 자바로 개발하는 데 사용되는 SDK 키트입니다. 
그래서 JDK안에는 자바를 개발 시 필요한 라이브러리들과 javac, javadoc 등의 개발 도구들을 포함되어 있고, 
개발을 하려면자바 프로그램을 실행도 시켜줘야 하기 때문에JRE(Java Runtime Environment)도 함께 포함되어 있습니다.

JRE는 자바 실행환경(Java Runtime Environment)의 약자로서, JVM과 자바 프로그램을 실행(동작)시킬 때 필요한 라이브러리 API를 함께 묶어서 배포되는 패키지입니다. 
이외에도 자바 런타임 환경에서 사용하는 프로퍼티 세팅이나 리소스 파일(jar 파일)을 가지고 있습니다.

JVM은 JRE에 포함되어있는 자바 가상 머신입니다.

### JAVA의 컴파일 동작 과정에 대해 설명해주세요.

1. 개발자가 자바 소스코드(.java)를 작성합니다.
2. 자바 컴파일러(Java Compiler)가 자바 소스파일을 컴파일합니다. 이때 나오는 파일은 자바 바이트 코드(.class)파일로 아직 컴퓨터가 읽을 수 없는 자바 가상 머신이 이해할 수 있는 코드입니다. 바이트 코드의 각 명령어는 1바이트 크기의 Opcode와 추가 피연산자로 이루어져 있습니다.
3. 컴파일된 바이트 코드를 JVM의 클래스로더(Class Loader)에게 전달합니다.
4. 클래스 로더는 동적로딩(Dynamic Loading)을 통해 필요한 클래스들을 로딩 및 링크하여 런타임 데이터 영역(Runtime Data area), 즉 JVM의 메모리에 올립니다.
5. 실행엔진(Execution Engine)은 JVM 메모리에 올라온 바이트 코드들을 명령어 단위로 하나씩 가져와서 실행합니다. 이때, 실행 엔진은 인터프리터, JIT 컴파일러 두가지 방식으로 변경합니다.

### 클래스로더의 세부 동작에 대해 설명해주세요.

1. **로드** : 클래스 파일을 가져와서 JVM의 메모리에 로드합니다.
2. **검증** : 자바 언어 명세(Java Language Specification) 및 JVM 명세에 명시된 대로 구성되어 있는지 검사합니다.
3. **준비** : 클래스가 필요로 하는 메모리를 할당합니다. (필드, 메서드, 인터페이스 등등)
4. **분석** : 클래스의 상수 풀 내 모든 심볼릭 레퍼런스를 다이렉트 레퍼런스로 변경합니다.
5. **초기화** : 클래스 변수들을 적절한 값으로 초기화합니다. (static 필드)

### 실행엔진의 두가지 방식에 대해 설명해주세요.

1. 인터프리터 : 바이트 코드 명령어를 하나씩 읽어서 해석하고 실행합니다. 하나하나의 실행은 빠르나, 전체적인 실행 속도가 느리다는 단점을 가집니다.
2. JIT 컴파일러(Just-In-Time Compiler) : 인터프리터의 단점을 보완하기 위해 도입된 방식으로 바이트 코드 전체를 컴파일하여 바이너리 코드로 변경하고 이후에는 해당 메서드를 더이상 인터프리팅 하지 않고, 바이너리 코드로 직접 실행하는 방식입니다.
3. 하나씩 인터프리팅하여 실행하는 것이 아니라 바이트 코드 전체가 컴파일된 바이너리 코드를 실행하는 것이기 때문에 전체적인 실행속도는 인터프리팅 방식보다 빠릅니다.

### 컴파일언어와 인터프리터 언어에 대해 설명해주세요.

컴파일러(compiler)는 개발자가 작성한 소스 코드를 기계어로 번역하는 프로그램을 가리킵니다. 

컴파일 언어는 컴파일러를 통해 컴파일 타임에 전체 소스 코드를 한 번에 기계어로 변환 후 실행파일을 만듭니다. 컴파일 언어는 컴파일 단계와 실행 단계가 각각 분리되어 있으며, 컴파일은 단 한번만 수행합니다. 
실행은 실행 파일을 실행시킴으로써 할 수 있으며, 실행시에는 컴파일 과정을 거치지 않고 실행만 하면 되므로 코드 실행 속도가 빠릅니다. 
단, 프로젝트의 규모가 클 경우 컴파일 시간이 오래 걸릴 수 있다는 단점이 있습니다.

**컴파일러 언어의 종류**

C, C++, C#

인터프리터(interpreter)는 프로그래밍 언어의 소스 코드를 바로 실행하는 컴퓨터 프로그램을 말합니다.

인터프리터 언어는 소스 코드를 한번에 기계어로 변환하는 컴파일러와 달리, 컴파일 하지 않고 소스 코드를 한 줄씩 읽어들여 실행합니다. 
컴파일 하는 과정이 없기 때문에 컴파일 하는 시간은 소요되지 않으나, 인터프리터 언어는 실행파일을 별도로 생성하지 않기 때문에 실행시마다 인터프리트 과정이 반복 수행되어 실행 속도가 느리다는 단점이 있습니다.

**인터프리터 언어의 종류**

Python, Javascript, Ruby

### **Java는 컴파일 언어인가요 ? 인터프리터 언어인가요 ?**

자바 소스코드는 먼저 자바 컴파일러를 사용하여 바이너리 바이트 코드(.class)로 컴파일된 다음 이 바이트 코드가 소프트웨어 기반 인터프리터인 JVM(Java Virtual Machine)에서 실행된다. 따라서자바는 컴파일과 인터프리터 둘 다 사용하는 것으로 간주됩니다.

### GC란 무엇인가요 ?

가비지 컬렉션(Garbage Collection, 이하 GC)은 자바의 메모리 관리 방법 중의 하나로 JVM(자바 가상 머신)의Heap 영역에서동적으로 할당했던 메모리 중필요 없게 된 메모리 객체(garbage)를 모아 주기적으로 제거하는 프로세스를 말합니다.

### GC의 동작원리에 대해 설명해주세요.

가비지 컬렉터가 동작하면, 다음과 같은 동작을 수행한다. Mark And Sweep (Optionally Compact)

1.Garbage collector가 Stack의 모든 변수를 스켄하면서 각각 어떤 객체를 참조하고 있는지 찾아서 마킹합니다

2.Reachable Object(리스트 안에 객체, 스택 → 힙(리스트) →힙(객체))가 참조하고 있는 객체도 찾아서 마킹합니다.

3.마킹되지 않은 객체를 Heap에서 제거합니다. (Sweep이라 부름)

4.compact를 하는 GC라면, 단편화 된 메모리를 정리합니다

### 영 제너레이션과 올드 제너레이션은 무엇인가요 ? 
영 제너레이션은 새롭게 생성된 객체가 할당되는 공간이며, 에덴과 서바이버 공간으로 나뉩니다.

올드 제너레이션은 영 제너레이션에서 특정 age가 넘은 참조 메모리들이 이동하는 공간입니다.
이 공간이 가득차면, major GC(올드제너레이션에서의 mark and sweep)가 일어납니다.

### 왜 영 제너레이션과 올드 제너레이션을 나눴을까요?
GC 설계자들은 두가지 가설을 전제로 GC를 만들었다고 합니다.
1. 대부분의 객체는 금방 접근 불가능한 상태가 된다. 
2. 오래된 객체에서 젊은 객체로의 참조는 아주 적게 존재한다.
그래서 영 제너레이션과 올드 제너레이션을 나누어놓고 힙 전체에서 GC를 진행하지 않고 영 제너레이션 에서만 GC를 수행(minor GC)합니다.
여기서 대부분의 garbage가 수거되기 때문에, 메모리 낭비를 막을 수 있습니다.

### minor GC, major GC 과정에 대해 설명해주세요.
1. 객체가 힙메모리에 할당 되면 우선 에덴에 할당된다. 에덴 영역이 가득 찬다면, 마이너 GC(에덴 영역에서의 mark and sweep)가 일어앚니다. 
   여기서 reachable해서 살아남은 객체는, survivor영역으로 이동합다.
2. 살아남아서 서바이버 영역으로 이동한 객체는 age가 증가합니다.
3. 또 다음 마이너 gc가 일어나면, 새로운 reachable 객체들은 서바이버 영역으로 이동하고, 기존 서바이버는 age가 1 증가합니다.
4. 이 과정이 반복되어 age가 일정 임계점을 돌파하면, old generation 영역으로 이동(promotion)합니다.


### **가비지 컬렉션 대상은 무엇인가요 ?**

객체에 레퍼런스가 있다면 Reachable로 구분되고, 객체에 유효한 레퍼런스가 없다면 Unreachable로 구분해버리고 수거해버린다.


# Ref

JDK , JRE, JVM : [https://inpa.tistory.com/entry/JAVA-☕-JDK-JRE-JVM-개념-구성-원리-💯-완벽-총정리](https://inpa.tistory.com/entry/JAVA-%E2%98%95-JDK-JRE-JVM-%EA%B0%9C%EB%85%90-%EA%B5%AC%EC%84%B1-%EC%9B%90%EB%A6%AC-%F0%9F%92%AF-%EC%99%84%EB%B2%BD-%EC%B4%9D%EC%A0%95%EB%A6%AC)

[https://gyoogle.dev/blog/computer-language/Java/컴파일 과정.html](https://gyoogle.dev/blog/computer-language/Java/%EC%BB%B4%ED%8C%8C%EC%9D%BC%20%EA%B3%BC%EC%A0%95.html)
컴파일언어, 인터프리터 언어 : 

[https://sunrise-min.tistory.com/entry/컴파일-언어와-인터프리터-언어의-차이-Java는-어떤-언어인가](https://sunrise-min.tistory.com/entry/%EC%BB%B4%ED%8C%8C%EC%9D%BC-%EC%96%B8%EC%96%B4%EC%99%80-%EC%9D%B8%ED%84%B0%ED%94%84%EB%A6%AC%ED%84%B0-%EC%96%B8%EC%96%B4%EC%9D%98-%EC%B0%A8%EC%9D%B4-Java%EB%8A%94-%EC%96%B4%EB%96%A4-%EC%96%B8%EC%96%B4%EC%9D%B8%EA%B0%80)

https://velog.io/@congaweb/compiler-interpreter
GC : 
https://sihyung92.oopy.io/java/garbage-collect/1 
[https://inpa.tistory.com/entry/JAVA-☕-가비지-컬렉션GC-동작-원리-알고리즘-💯-총정리#garbage_collectiongc_이란?](https://inpa.tistory.com/entry/JAVA-%E2%98%95-%EA%B0%80%EB%B9%84%EC%A7%80-%EC%BB%AC%EB%A0%89%EC%85%98GC-%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%F0%9F%92%AF-%EC%B4%9D%EC%A0%95%EB%A6%AC#garbage_collectiongc_%EC%9D%B4%EB%9E%80?)
