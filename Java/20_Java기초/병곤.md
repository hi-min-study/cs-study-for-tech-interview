### 접근 제어자란 무엇인가요?

접근 제어자(Access Modifiers)는 클래스, 변수, 메서드 및 생성자에 대한 접근 수준을 설정하는 데 사용되는 키워드입니다. Java에서는 `private`, `public`, `protected`, 그리고 아무것도 지정하지 않는 경우(기본 접근 제어, package-private)의 네 가지 접근 제어자를 제공합니다. 이러한 접근 제어자를 사용하여 클래스 내부 데이터의 캡슐화와 보호를 강화할 수 있습니다.

### 클래스, 객체, 인스턴스 차이에 대해 말씀해주세요

- **클래스(Class)**: 객체를 생성하기 위한 틀 또는 설계도입니다. 속성과 메서드로 구성됩니다.
- **객체(Object)**: 클래스에 정의된 것을 기반으로 생성된 실체입니다. 소프트웨어 세계의 실체를 의미합니다.
- **인스턴스(Instance)**: 특정 클래스로부터 생성된 객체를 그 클래스의 인스턴스라고 합니다. 객체와 인스턴스는 거의 같은 의미로 사용되나, 객체는 보다 일반적인 의미를, 인스턴스는 특정 클래스로부터 생성되었다는 의미의 강조할 때 사용됩니다.

### Overloading과 Overriding 비교해주세요

- **Overloading(오버로딩)**: 같은 이름의 메서드를 매개변수의 타입이나 개수를 다르게 하여 여러 개 정의하는 것입니다. 컴파일 타임에 결정됩니다.
- **Overriding(오버라이딩)**: 상속 관계에 있는 클래스에서 상위 클래스의 메서드를 하위 클래스가 재정의하여 사용하는 것입니다. 런타임에 결정됩니다.

### Primitive type과 Reference type 에 대해 비교해주세요

- **Primitive Type(원시 타입)**: Java에서 미리 정의하고 제공하는 데이터 타입으로, boolean, char, byte, short, int, long, float, double 등이 있습니다. 스택 메모리에 값이 직접 저장됩니다.
- **Reference Type(참조 타입)**: 객체의 주소를 저장하는 타입으로, 클래스, 인터페이스, 배열 등이 있습니다. 힙 메모리에 객체가 저장되며, 스택 메모리에는 그 객체를 가리키는 참조 값이 저장됩니다.

### Call by Reference과 Call by Value 에 대해 비교해주세요

- **Call by Value**: 함수를 호출할 때 인자로 값의 복사본을 전달합니다. 따라서 함수 내부에서 값이 변경되어도 외부의 변수에는 영향을 미치지 않습니다.
- **Call by Reference**: 함수를 호출할 때 인자로 메모리 주소(참조)를 전달합니다. 이로 인해 함수 내부에서 값을 변경하면, 해당 변경이 외부 변수에도 반영됩니다. Java에서는 객체 참조에 의한 호출이 이에 해당합니다.

### Wrapper Class란 무엇인가요?

Wrapper 클래스는 Java의 원시 데이터 타입을 객체로 취급할 수 있게 해주는 클래스입니다. 각 원시 데이터 타입에 해당하는 Wrapper 클래스가 있으멀로(int에는 Integer, double에는 Double 등), 원시 타입의 데이터를 객체로 관리하거나 메서드의 인자로 전달할 때 유용합니다.

### 인터페이스와 추상 클래스에 대해 말씀 해주세요

- **인터페이스(Interface)**: 모든 메서드가 추상 메서드로 선언되어 있으며, 구현된 로직을갖지 않는 순수한 '계약'을 정의합니다. Java 8부터는 default 메서드와 static 메서드를 포함할 수 있게 되어, 일부 구현을 포함할 수 있게 되었습니다. 클래스는 여러 인터페이스를 구현할 수 있습니다.

- **추상 클래스(Abstract Class)**: 하나 이상의 추상 메서드를 포함하거나, 구체적인 구현 없이 메서드를 선언할 수 있는 클래스입니다. 추상 클래스는 상속을 통해 자식 클래스에서 추상 메서드를 구현하도록 강제합니다. 클래스는 단 하나의 추상 클래스만 상속받을 수 있습니다.
### 예외란 무엇인가요?

예외(Exception)는 프로그램 실행 중에 발생하는 예기치 않은 상황을 의미합니다. 이러한 상황은 일반적으로 프로그램의 비정상적인 종료를 일으킬 수 있으므로, 예외 처리(Exception Handling)를 통해 이를 관리하고 대응합니다. 예외 처리는 오류 발생 시 사용자에게 알림을 주거나, 적절한 로직으로 안전하게 프로그램을 종료하거나 계속 실행할 수 있도록 합니다.

### Checked Exception와 UnChecked Exception 비교해주세요

- **Checked Exception**: 컴파일 타임에 체크되는 예외로, 예외 처리를 강제하는 예외입니다. 이러한 예외들은 주로 외부 시스템과의 연동(파일 입출력, 네트워크 통신 등)에서 발생할 수 있는 예외 상황들을 처리하기 위해 사용됩니다. 예를 들어, `IOException`이 있습니다.
- **Unchecked Exception**: 런타임에 발생하는 예외로, 예외 처리를 강제하지 않습니다. `RuntimeException` 클래스와 그 하위 클래스들이 이에 속합니다. 대표적으로 `NullPointerException`, `ArrayIndexOutOfBoundsException` 등이 있습니다.

### static이란 무엇인가요?

`static` 키워드는 클래스의 특정 필드나 메서드, 블록을 클래스에 속하는 것으로 지정하여, 객체의 생성 없이 해당 필드나 메서드를 사용할 수 있도록 합니다. `static`으로 선언된 멤버는 모든 인스턴스에서 공유되며, 클래스가 메모리에 로드될 때 한 번만 생성됩니다.

### final 이란 무엇인가요?

`final` 키워드는 변수, 메서드, 클래스에 사용될 수 있으며, 해당 요소를 변경할 수 없게 만듭니다. `final` 변수는 값을 한 번만 할당할 수 있으며, `final` 메서드는 오버라이딩할 수 없고, `final` 클래스는 상속받을 수 없습니다.

### generic이란 무엇인가요?

제네릭(Generic)은 클래스, 인터페이스, 메서드를 정의할 때 타입(Type)을 파라미터로 사용할 수 있게 하는 기능입니다. 이를 통해 타입 체크를 컴파일 시간에 수행하여 타입 안전성을 높이고, 타입 변환(casting)을 줄일 수 있습니다. 예를 들어, `List<E>`는 제네릭을 사용한 컬렉션 클래스의 예입니다.

### stream과 lambda에 대해 말씀해주세요

- **Stream**: Java 8에서 도입된, 데이터의 추상화된 시퀀스를 처리하는 기능입니다. 컬렉션의 요소를 하나씩 참조하며 람다를 이용해 처리할 수 있으며, 선언적으로 컬렉션 데이터를 처리할 수 있도록 해줍니다.
- **Lambda Expression(람다 표현식)**: 함수를 간결한 식으로 표현할 수 있게 해주는 기능으로, Java 8에서 추가되었습니다. 람다 표현식을 통해 익명 함수를 간편하게 작성하고, 고차 함수(higher-order function)에 전달할 수 있습니다.

### Reflection과 Dynamic Proxy에 대해 말씀해주세요

- Reflection
	Reflection은 Java에서 실행 시간에 클래스의 속성, 메서드, 생성자 등의 정보를 조회하거나 조작할 수 있게 해주는 API입니다. 이를 통해 컴파일 시간에는 알 수 없는 클래스의 객체를 생성하고, 메서드를 호출하며, 필드에 접근할 수 있습니다. Reflection은 유연성을 크게 향상시키지만, 오버헤드가 발생하고 타입 안정성이 낮아질 수 있다는 단점이 있습니다. 따라서 필요한 경우에 신중하게 사용해야 합니다.
- Dynamic Proxy
	Dynamic Proxy는 프록시(Proxy) 디자인 패턴의 일종으로, 실행 시간에 특정 인터페이스를 구현하는 클래스의 인스턴스를 생성하는 기능을 말합니다. Java에서는 `java.lang.reflect.Proxy` 클래스와 `InvocationHandler` 인터페이스를 사용해 동적 프록시 객체를 생성할 수 있습니다. 이 프록시 객체를 통해 실제 객체의 메서드 호출을 가로채 다양한 목적으로 사용할 수 있습니다. 예를 들어, 메서드 호출 전후에 특정 작업을 실행하거나, 원격 객체에 대한 접근, 로깅, 트랜잭션 처리 등에 활용됩니다.