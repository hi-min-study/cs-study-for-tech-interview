## 내용 정리
### 접근제어자

접근 제어자(access modifier)를 사용하여 변수나 메서드의 사용 권한을 설정할 수 있다. 다음과 같은 접근 제어자를 사용하여 사용 권한을 설정할 수 있다.

- private : 해당 클래스 내부에서만 사용 가능
- default : 해당 클래스 내부, 같은 패키지에서 사용 가능
- protected : 해당 클래스 내부, 같은 패키지, 상속 클래스에서 사용 가능
- public : 어떠한 클래스에서도 접근 가능

### 클래스, 객체, 인스턴스

### 클래스(Class)

- 객체를 만들어 내기 위한 설계도 혹은 틀
- 연관되어 있는 변수와 메서드의 집합

### 객체(Object) 란

- 소프트웨어 세계에 구현할 대상
- 클래스에 선언된 모양 그대로 생성된 실체
- ‘클래스의 인스턴스(instance)’ 라고도 부른다.
- 객체는 모든 인스턴스를 대표하는 포괄적인 의미를 갖는다.
- oop의 관점에서 클래스의 타입으로 선언되었을 때 ‘객체’라고 부른다.

### 인스턴스(Instance) 란

- 설계도를 바탕으로 소프트웨어 세계에 구현된 구체적인 실체
- 즉, 객체를 소프트웨어에 실체화 하면 그것을 ‘인스턴스’라고 부른다.
- 실체화된 인스턴스는 메모리에 할당된다.
- 인스턴스는 객체에 포함된다고 볼 수 있다.
- oop의 관점에서 객체가 메모리에 할당되어 실제 사용될 때 ‘인스턴스’라고 부른다.
- 추상적인 개념(또는 명세)과 구체적인 객체 사이의 관계 에 초점을 맞출 경우에 사용한다.
    - ‘~의 인스턴스’ 의 형태로 사용된다.
    - 객체는 클래스의 인스턴스다.
    - 객체 간의 링크는 클래스 간의 연관 관계의 인스턴스다.
    - 실행 프로세스는 프로그램의 인스턴스다.
- 즉, 인스턴스라는 용어는 반드시 클래스와 객체 사이의 관계로 한정지어서 사용할 필요는 없다.
- 인스턴스는 어떤 원본(추상적인 개념)으로부터 ‘생성된 복제본’을 의미한다.

### 클래스, 객체, 인스턴스의 차이

- 클래스(Class) VS 객체(Object)
    - 클래스는 ‘설계도’, 객체는 ‘설계도로 구현한 모든 대상’을 의미한다.
- 객체(Object) VS 인스턴스(Instance)
    - 클래스의 타입으로 선언되었을 때 객체라고 부르고, 그 객체가 메모리에 할당되어 실제 사용될 때 인스턴스라고 부른다.
    - 객체는 현실 세계에 가깝고, 인스턴스는 소프트웨어 세계에 가깝다.
    - 객체는 ‘실체’, 인스턴스는 ‘관계’에 초점을 맞춘다.
    - 객체를 ‘클래스의 인스턴스’라고도 부른다.
    - ‘방금 인스턴스화하여 레퍼런스를 할당한’ 객체를 인스턴스라고 말하지만, 이는 원본(추상적인 개념)으로부터 생성되었다는 것에 의미를 부여하는 것일 뿐 엄격하게 객체와 인스턴스를 나누긴 어렵다.

### Overloading vs Overriding

### 공통점

- 자바의 특징인 다형성을 이용한다

### Overloading

- 메서드의 파라미터 갯수, 파라미터의 타입을 달리 하여 동일한 메소드를 여러개 생성

### Overriding

- 부모클래스의 메서드를 상속하여 재정의

### Primitive type vs Reference type

### Primitive type(원시 타입)

---

`int, long, double, float, boolean, byte, short, char` 총 8 가지의 primitive type을 Java 에서 미리 정의하고 제공한다.

Java에서 기본 자료형은 반드시 **사용하기 전에 선언(Declared)** 되어야하며, 자료형의 **길이는 운영체제에 독립적**이며 변하지 않는다.

`스택(stack) 메모리` 에 저장된다.

### Reference Type(참조 타입)

---

**원시 타입을 제외한 타입들***(문자열, 배열, 열거, 클래스, 인터페이스)*을 말한다.

즉, `참조 타입(Reference type` 은 Java에서 최상위 클래스인 java.lang.Object 클래스를 상속하는 모든 클래스들을 말한다.

Java에서 `실제 객체` 는 `힙(heap) 메모리`에 저장되며 `참조 타입 변수` 는 `스택 메모리` 에 실제 객체들의 주소를 저장하여, 객체를 사용할때 마다 **참조 변수에 저장된 객체의 주소를 불러와 사용**하는 방식이다.

이후 `Garbage Collector`가 돌면서 메모리를 해제한다.

### 원시 타입 vs. 참조 타입

---

원시 타입과 참조 타입의 기능적 차이는 크게 2가지가 있다.

1. **Null을 담을 수 있는가?**

원시 타입은 null을 담을 수 없다. 반면에 참조 타입은 null을 입력값으로 받을 수 있다.

```java
int i = null; // 불가능
Integer integer = null; // 가능
```

1. **제네릭 타입에서 사용할 수 있는가?**

원시 타입은 제네릭 타입에서 사용할 수 없다. 반면에 참조 타입은 제네릭 타입에서 사용할 수 있다.

```java
List<int> i; // 불가능
List<Integer> integer; // 가능
```

### Call by Reference vs Call by Value

### Call by Reference

함수 호출시 인자로 전달되는 변수의 레퍼런스를 전달한다.

### Call by Value

함수 호출시 전달되는 변수의 값을 복사하여 함수의 인자로 전달한다.

### Java는 Call by Value? Reference?

- Call by Value이다.
- 객체를 인자에 넘겨주어도, 정확히는 해당 객체의 주소값을 가리키는 참조 타입 변수를 넘겨주기 때문에, 함수 내부에서 객체의 값을 수정하면 참조 타입 변수가 가리키는 실제 객체의 주소에서 수정이 이루어지는 식.

### Wrapper Class

- 원시타입(primitive type)을 객체로 다루기 위해서 사용하는 클래스들을 래퍼 클래스(wrapper class)라고 합니다.
- 래퍼 클래스로 감싸고 있는 기본 타입 값은 외부에서 변경할 수 없습니다. 만약 값을 변경하고 싶다면 새로운 포장 객체를 만들어야 합니다.

### Boxing, UnBoxing

기본 타입의 값을 포장 객체로 만드는 과정을 박싱이라고 하고 반대로 포장객체에서 기본타입의 값을 얻어내는 과정을 언박싱이라고 합니다.

### Auto Boxing, Auto UnBoxing의 정의와 성능

### 오토박싱

기본 데이터 타입의 값을 해당 래퍼 클래스의 객체로 자동으로 변환하는 것을 말한다. 예를 들어 int 타입의 변수를 Integer 타입으로 할당하면 자동으로 오토박싱이 발생한다.

### 오토 언박싱

오토박싱의 반대 개념으로 래퍼 클래스의 객체를 해당 기본 데이터 타입으로 자동으로 변환하는 것을 말한다다. 예를 들어 Integer 타입의 객체를 int 타입으로 할당하면 자동으로 오토 언박싱이 발생한다.

### 오토박싱 성능

오토박싱을 사용할 경우 기본 타입의 값을 Wrapper 클래스 객체로 변환하는 과정에서 새로운 객체가 생성된다. 이 과정에서 메모리 할당 가비지 컬렉션 등의 부하가 발생하므로 성능 저하가 발생할 수 있다.

### 인터페이스 vs 추상 클래스

|  | 추상 클래스 | 인터페이스 |
| --- | --- | --- |
| 사용 키워드 | abstract | interface |
| 사용 가능 변수 | 제한 없음 | static final (상수) |
| 사용 가능 접근 제어자 | 제한 없음 (public, private, protected, default) | public |
| 사용 가능 메소드 | 제한 없음 | abstract method, default method, static method, private method |
| 상속 키워드 | extends | implements |
| 다중 상속 가능 여부 | 불가능 | 가능 (클래스에 다중 구현, 인터페이스 끼리 다중 상속) |

공통점

1. 추상 메소드를 가지고 있어야 한다.
2. 인스턴스화 할 수 없다
3. 인터페이스 혹은 추상 클래스를 상속받아 구현한 구현체의 인스턴스를 사용해야 한다.
4. 인터페이스와 추상클래스를 구현, 상속한 클래스는 추상 메소드를 반드시 구현하여야 한다.

### 인터페이스 사용시기

- 다중상속 적용하고 싶을 때
- 인터페이스의 필드가 아닌 기능만 필요할 때

### 추상클래스 사용시기

- 기존 기능을 상속을 통하여 확장시키고자 할때
- 클래스의 상태(필드)가 필요할 때
- 코드 재사용이 필요할 때

### Checked Exception vs UnChecked Exception

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/f161c15f-c5f0-4683-9793-c7551a62792f/87665411-2066-4921-ad94-6ec4f32f4272/Untitled.png)

### Checked Exception

- **컴파일 시점에 컴파일러에서 확인하는 예외**
- **반드시 에러 처리를 해야 하는 특징(try/catch or throw)을 가지고 있다.**

### Unchecked Exception

- **RuntimeException을 상속하는 클래스**
- **런타임 단계에서 확인 가능**
- **에러 처리를 강제하지 않는다.**

### Static

- 객체(인스턴스)에 소속된 멤버가 아니라 클래스에 고정된 멤버입니다.
- 클래스의 로딩이 끝나는 즉시 바로 사용할 수 있습니다.
- 객체가 없어도 사용 가능한 메소드/필드들이기 때문에 유틸성 클래스에서 주로 사용합니다.
- 자바 8 이전
    - Permanent 영역에서 관리
    - Permanent : JVM에 의해 크기가 강제되던 영역
- 자바 8 이후
    - static의 reference는 Metaspace 영역에서 관리
    - 실제로 저장은 heap영역에 이루어짐. → 따라서 GC의 대상이 될 수 있음.
    - Metaspace : Native Memory 영역으로, os가 자동으로 크기를 조절.

### Final

### **final 클래스**

- final이 붙어있는 클래스는 상속할 수 없습니다. 이렇게 하면 보안이나 효율성 측면에서 장점이 있습니다. `java.lang.System`이나 `java.lang.String`처럼 자바에서 기본적으로 제공하는 라이브러리 클래스는 final을 사용한다고 하네요.

### **final 메서드**

- 만약 어떤 클래스를 상속하는데 그 안에 final 메서드가 있다면, 오버라이딩으로 수정할 수 없습니다.

### **final 변수**

- final 변수는 한 번 값을 할당하면 수정할 수 없습니다. 즉, 초기화는 한 번만 가능합니다.

### 장점

- **불변성**: `final` 변수는 읽기 전용이 되므로, 애플리케이션의 실행 도중에 예상치 못한 변경으로부터 안전하다.
- **스레드 안정성**: 멀티스레드 환경에서 `final` 필드는 한 번 생성되고 초기화된 이후에는 변경되지 않으므로, 스레드 간에 안전하게 공유될 수 있다.
- **성능 최적화**: 컴파일러와 `JVM`은 `final` 키워드를 사용하는 요소에 대해 추가적인 최적화를 수행할 수 있다.
    - 컴파일러 최적화: final 변수는 변하지 않는 값이므로, 컴파일러는 이를 알고 더 효율적인 코드로 최적화할 수 있습니다. 예를 들어, final 변수에 대한 접근은 인라인화될 수 있어, 메서드 호출 오버헤드를 줄일 수 있습니다.
    - JIT 컴파일러 최적화: JVM의 JIT(Just-In-Time) 컴파일러는 런타임에 final 메서드와 클래스에 대한 추가 최적화를 수행할 수 있습니다. final 메서드는 오버라이드될 수 없기 때문에, 직접적인 메서드 호출로 해석될 수 있으며, 이는 런타임 성능을 향상시킵니다.
- **설계 의도 명확화**: `final` 키워드는 코드를 읽는 사람에게 해당 요소가 변경되지 않을 것임을 명확하게 전달한다.

### Generic

- 클래스나 메소드에서 사용할 내부 데이터 타입을 컴파일 시에 미리 지정하는 방법

### 장점

**1.** 제네릭을 사용하면 잘못된 타입이 들어올 수 있는 것을 컴파일 단계에서 방지할 수 있다.

**2.** 클래스 외부에서 타입을 지정해주기 때문에 따로 타입을 체크하고 변환해줄 필요가 없다. 즉, 관리하기가 편하다.

**3.** 비슷한 기능을 지원하는 경우 코드의 재사용성이 높아진다.

### stream, lambda

### 람다식

- 람다식(Lambda expression)은 간단히 말해서 메서드를 하나의 '식(expression)'으로 표현한 것이다. 람다식은 함수를 간략하면서도 명확한 식으로 표현할 수 있게 해준다.
- 메서드를 람다식으로 표현하면 메서드의 이름과 반환값이 없어지므로, 람다식을 '익명 함수(anonymous function)'이라고도 한다.

### Stream

- 배열, 컬렉션의 구성요소들을 순회하며 처리할 수 있게 해주는 자료형/코드패턴.
- 람다를 사용할 수 있는 기술 중 하나

### 스트림 특징

### 스트림은 데이터 소스를 변경하지 않는다.

- 스트림은 데이터 소스로 부터 데이터를 읽기만할 뿐, 데이터 소스를 변경하지 않는다는 차이가 있다. 필요하다면, 정렬된 결과를 컬렉션이나 배열에 담아서 반환할 수도 있다.

```java
List<String> sortedList = strStream2.sorted().collect(Collectors.toList());
```

### 스트림은 일회용이다.

- 스트림은 Iterator처럼 일회용이다. Iterator로 컬렉션의 요소를 모두 읽고 나면 다시 사용할 수 없는 것처럼, 스트림도 한번 사용하면 닫혀서 다시 사용할 수 없다. 필요하다면 스트림을 다시 생성해야 한다.

### 스트림은 작업을 내부 반복으로 처리한다.

- 스트림을 이용한 작업이 간결할 수 있는 비결중의 하나가 바로 '내부 반복'이다. 내부 반복이라는 것은 반복문을 메서드의 내부에 숨길 수 있다는 것을 의미한다. forEach()는 스트림에 정의된 메서드 중의 하나로 매개변수에 대입된 람다식을 데이터 소스의 모든 요소에 적용한다.

```
stream.forEach(System.out::println);
//System.out::println == (str)->System.out.println(str)
```

### 스트림의 연산

- 스트림이 제공하는 다양한 연산을 이용해서 복잡한 작업들을 간단히 처리할 수 있다. 마치 데이터베이스에 SELECT문으로 질의하는 것과 같은 느낌이다.
- 스트림이 제공하는 연산은 중간 연산과 최종 연산으로 분류할 수 있는데, 중간 연산은 연산결과를 스트림으로 반환하기 때문에 중간 연산을 연속해서 연결할 수 있다. 반면에 최종 연산은 스트림의 요소를 소모하면서 연산을 수행하므로 단 한번만 연산이 가능하다.

> 중간 연산 : 연산 결과가 스트림인 연산. 스트림에 연속해서 중간 연산할 수 있음
>
>
> 최종 연산 : 연산 결과가 스트림이 아닌 연산. 스트림의 요소를 소모하므로 단 한번만 가능
>

### 지연된 연산

- 스트림 연산에서 한 가지 중요한 점은 최종 연산이 수행되기 전까지는 중간 연산이 수행되지 않는다는 것이다. 스트림에 대해 distinct()나 sort()같은 중간 연산을 호출해도 즉각적인 연산이 수행되는 것은 아니라는 것이다.
- 중간 연산을 호출하는 것은 단지 어떤 작업이 수행되어야하는지를 지정해주는 것일 뿐이다. 최종 연산이 수행되어야 비로소 스트림의 요소들이 중간 연산을 거쳐 최종 연산에서 소모된다.

### 병렬 스트림

- 스트림으로 데이터를 다룰 때의 장점 중 하나가 바로 병렬 처리가 쉽다는 것이다.
    - parallel() : 병렬로 연산은 수행하도록 지시
    - sequential() : 병렬로 처리되지 않도록 지시

### Reflection & Dynamic Proxy

### Reflection

클래스 로더를 통해 static(Method) 영역에 로드된 Class Type의 객체를 통해, 구체적인 Class Type을 알지 못하더라도 해당 Class의 다음과 같은 정보에 접근할 수 있게 한다.

1. Method
2. Class
3. Field
4. Constructor

위와 같은 기능 덕분에, 컴파일된 바이트 코드를 통해 Runtime에 동적으로 특정 Class의 정보를 추출할 수 있는 기능을 제공하는 것이 Java Reflection API이다.

## 언제 사용하는가?

1. 동적으로 Class를 사용하는 경우
    - Compile time이 아닌, Runtime에 Class를 가져와서 실행해야 하는 경우 (ex : Spring DI)
    - 객체 생성, 필드 조작, 메소드 호출
2. 클래스의 정보를 탐색하는 경우
    - 클래스 이름, Super class, (접근제한자와 상관 없이) 모든 필드, 메소드, 생성자 등
3. JSON/XML 등의 데이터로 직렬화/역직렬화 할 때
    - 다양한 라이브러리들이 리플렉션을 통해 해당 클래스의 필드와 직렬화된 JSON/XML을 매핑시킨다.
4. Proxy 객체
    - 다양한 메소드 콜을 intercept하는 프록시 객체를 생성.
    - Lazy Loading
5. AOP(JDK Dynamic Proxy only)
    - AOP 대상을 프록시 객체로 만들기 위해 reflection을 사용하여 구현한다.

## 장점

- 어플리케이션 내에서가 아닌, 외부 라이브러리/프레임워크가 런타임시에 동작할 때 쓰인다.
    - 프레임워크/라이브러리 등에서는 해당 프레임워크/라이브러리가 어디에 쓰일지 모르므로 리플렉션을 이용하여 동적으로 기능을 이용할 수 있도록 한다.
    - 실제로 다양한 프레임워크/라이브러리에서 Reflection을 이용한다. (ex : Spring DI, JPA Entity 등)
- 디버깅 시 리플렉션을 이용하여 private field까지도 검사할 수 있다.

## 단점

- 성능이 떨어진다.
    - 동적으로 객체를 생성하므로, JIT Compiler의 최적화를 받지 못한다.
    - 매번 명시된 클래스가 맞는지, 적절한 생성자를 이용했는지에 대해서 체크를 해야 한다.
- 캡슐화가 깨진다.
    - 리플렉션을 통해 접근제한자 상관없이 모든 필드/메소드를 접근할 수 있으므로.
- Compile-time Safety를 누리지 못한다.
    - 런타임 시에 객체가 생성되므로, 컴파일 시점에 누릴 수 있는 type check/Exception check를 이용하지 못한다.

### Dynamic Proxy

- 프록시를 사용하기 위해서는 대상 클래스 수만큼의 프록시 클래스를 하나하나 만들어줘야하고 그 안에 들어가는 반복되는 코드때문에 코드중복이라는 단점이 있습니다.
- 개발자가 직접 일일히 프록시 객체를 생성하는 것이 아닌, 애플리케이션 실행 도중 java.lang.reflect.Proxy 패키지에서 제공해주는 API를 이용하여 동적으로 프록시 인스턴스를 만들어 등록하는 방법으로서, 자바의Reflection API 기법을 응용한 연장선의 개념이다

### Dynamic Proxy 구성요소

- Class loader
- 타깃의 인터페이스
- InvocationHandler : 타깃의 정보가 포함된 Handler

### ref

- 클래스, 객체, 인스턴스 : https://gmlwjd9405.github.io/2018/09/17/class-object-instance.html
- primitive vs reference : [https://velog.io/@wkdwoo/Primitive-type원시타입-vs.-Reference-type참조타입](https://velog.io/@wkdwoo/Primitive-type%EC%9B%90%EC%8B%9C%ED%83%80%EC%9E%85-vs.-Reference-type%EC%B0%B8%EC%A1%B0%ED%83%80%EC%9E%85)
- Call by Ref, Val : https://wayhome25.github.io/cs/2017/04/11/cs-13/
- Wrapper Class : https://coding-factory.tistory.com/547
- static : https://coding-factory.tistory.com/524
- final : https://makemethink.tistory.com/184, [https://burningfalls.github.io/java/what-is-final-keyword/#d-장점](https://burningfalls.github.io/java/what-is-final-keyword/#d-%EC%9E%A5%EC%A0%90)
- generic : https://st-lab.tistory.com/153
- 람다, 스트림 : [https://velog.io/@suminwooo/람다와-스트림#25-스트림의-최종-연산](https://velog.io/@suminwooo/%EB%9E%8C%EB%8B%A4%EC%99%80-%EC%8A%A4%ED%8A%B8%EB%A6%BC#25-%EC%8A%A4%ED%8A%B8%EB%A6%BC%EC%9D%98-%EC%B5%9C%EC%A2%85-%EC%97%B0%EC%82%B0)

## 질문 정리
### 자바의 접근제한자의 종류와 그에 대해 설명해 주세요

- private : 해당 클래스 내부에서만 사용 가능
- default : 해당 클래스 내부, 같은 패키지에서 사용 가능
- protected : 해당 클래스 내부, 같은 패키지, 상속 클래스에서 사용 가능
- public : 어떠한 클래스에서도 접근 가능

### 클래스, 객체, 인스턴스에 대한 설명과 차이점을 말해주세요.

### 클래스(Class)

- 객체를 만들어 내기 위한 설계도 혹은 틀
- 연관되어 있는 변수와 메서드의 집합

### 객체(Object) 란

- 소프트웨어 세계에 구현할 대상
- 클래스에 선언된 모양 그대로 생성된 실체
- ‘클래스의 인스턴스(instance)’ 라고도 부른다.
- 객체는 모든 인스턴스를 대표하는 포괄적인 의미를 갖는다.
- oop의 관점에서 클래스의 타입으로 선언되었을 때 ‘객체’라고 부른다.

### 인스턴스(Instance) 란

- 설계도를 바탕으로 소프트웨어 세계에 구현된 구체적인 실체
- 즉, 객체를 소프트웨어에 실체화 하면 그것을 ‘인스턴스’라고 부른다.
- 실체화된 인스턴스는 메모리에 할당된다.
- 인스턴스는 객체에 포함된다고 볼 수 있다.
- oop의 관점에서 객체가 메모리에 할당되어 실제 사용될 때 ‘인스턴스’라고 부른다.
- 추상적인 개념(또는 명세)과 구체적인 객체 사이의 관계 에 초점을 맞출 경우에 사용한다.
    - ‘~의 인스턴스’ 의 형태로 사용된다.
    - 객체는 클래스의 인스턴스다.
    - 객체 간의 링크는 클래스 간의 연관 관계의 인스턴스다.
    - 실행 프로세스는 프로그램의 인스턴스다.
- 즉, 인스턴스라는 용어는 반드시 클래스와 객체 사이의 관계로 한정지어서 사용할 필요는 없다.
- 인스턴스는 어떤 원본(추상적인 개념)으로부터 ‘생성된 복제본’을 의미한다.

### 클래스, 객체, 인스턴스의 차이

- 클래스(Class) VS 객체(Object)
    - 클래스는 ‘설계도’, 객체는 ‘설계도로 구현한 모든 대상’을 의미한다.
- 객체(Object) VS 인스턴스(Instance)
    - 클래스의 타입으로 선언되었을 때 객체라고 부르고, 그 객체가 메모리에 할당되어 실제 사용될 때 인스턴스라고 부른다.
    - 객체는 현실 세계에 가깝고, 인스턴스는 소프트웨어 세계에 가깝다.
    - 객체는 ‘실체’, 인스턴스는 ‘관계’에 초점을 맞춘다.
    - 객체를 ‘클래스의 인스턴스’라고도 부른다.
    - ‘방금 인스턴스화하여 레퍼런스를 할당한’ 객체를 인스턴스라고 말하지만, 이는 원본(추상적인 개념)으로부터 생성되었다는 것에 의미를 부여하는 것일 뿐 엄격하게 객체와 인스턴스를 나누긴 어렵다.

### 오버로딩과 오버라이딩의 차이에 대해 설명해 주세요.

### 공통점

- 자바의 특징인 다형성을 이용한다

### Overloading

- 메서드의 파라미터 갯수, 파라미터의 타입을 달리 하여 동일한 메소드를 여러개 생성

### Overriding

- 부모클래스의 메서드를 상속하여 재정의

### 원시타입과 레퍼런스타입에 대해 설명해 주시고, 차이점에 대해 설명해 주세요.

### Primitive type(원시 타입)

---

`int, long, double, float, boolean, byte, short, char` 총 8 가지의 primitive type을 Java 에서 미리 정의하고 제공한다.

Java에서 기본 자료형은 반드시 **사용하기 전에 선언(Declared)** 되어야하며, 자료형의 **길이는 운영체제에 독립적**이며 변하지 않는다.

`스택(stack) 메모리` 에 저장된다.

### Reference Type(참조 타입)

---

**원시 타입을 제외한 타입들***(문자열, 배열, 열거, 클래스, 인터페이스)*을 말한다.

즉, `참조 타입(Reference type` 은 Java에서 최상위 클래스인 java.lang.Object 클래스를 상속하는 모든 클래스들을 말한다.

Java에서 `실제 객체` 는 `힙(heap) 메모리`에 저장되며 `참조 타입 변수` 는 `스택 메모리` 에 실제 객체들의 주소를 저장하여, 객체를 사용할때 마다 **참조 변수에 저장된 객체의 주소를 불러와 사용**하는 방식이다.

이후 `Garbage Collector`가 돌면서 메모리를 해제한다.

### 원시 타입 vs. 참조 타입

---

원시 타입과 참조 타입의 기능적 차이는 크게 2가지가 있다.

1. **Null을 담을 수 있는가?**

원시 타입은 null을 담을 수 없다. 반면에 참조 타입은 null을 입력값으로 받을 수 있다.

```java
int i = null; // 불가능
Integer integer = null; // 가능
```

1. **제네릭 타입에서 사용할 수 있는가?**

원시 타입은 제네릭 타입에서 사용할 수 없다. 반면에 참조 타입은 제네릭 타입에서 사용할 수 있다.

```java
List<int> i; // 불가능
List<Integer> integer; // 가능
```

### Call by Reference와 Call by Value에 대해 설명해 주세요.

### Call by Reference

함수 호출시 인자로 전달되는 변수의 레퍼런스를 전달한다.

### Call by Value

함수 호출시 전달되는 변수의 값을 복사하여 함수의 인자로 전달한다.

### 자바는 Call by Reference일까요, Value일까요?

- Call by Value이다.
- 객체를 인자에 넘겨주어도, 정확히는 해당 객체의 주소값을 가리키는 참조 타입 변수를 넘겨주기 때문에, 함수 내부에서 객체의 값을 수정하면 참조 타입 변수가 가리키는 실제 객체의 주소에서 수정이 이루어지는 식.

### Wrapper 클래스란 무엇인가요? 왜 사용하나요?

- 원시타입(primitive type)을 객체로 다루기 위해서 사용하는 클래스들을 래퍼 클래스(wrapper class)라고 합니다.
- 래퍼 클래스로 감싸고 있는 기본 타입 값은 외부에서 변경할 수 없습니다. 만약 값을 변경하고 싶다면 새로운 포장 객체를 만들어야 합니다.

사용 이유

- null값 사용
- Generic의 사용을 위해

### 박싱, 언박싱, 오토박싱, 오토언박싱에 대해 설명해 주세요.

### Boxing, UnBoxing

기본 타입의 값을 포장 객체로 만드는 과정을 박싱이라고 하고 반대로 포장객체에서 기본타입의 값을 얻어내는 과정을 언박싱이라고 합니다.

### 오토박싱

기본 데이터 타입의 값을 해당 래퍼 클래스의 객체로 자동으로 변환하는 것을 말한다. 예를 들어 int 타입의 변수를 Integer 타입으로 할당하면 자동으로 오토박싱이 발생한다.

### 오토 언박싱

오토박싱의 반대 개념으로 래퍼 클래스의 객체를 해당 기본 데이터 타입으로 자동으로 변환하는 것을 말한다다. 예를 들어 Integer 타입의 객체를 int 타입으로 할당하면 자동으로 오토 언박싱이 발생한다.

### 오토박싱 주의점에 대해 말씀해 주세요.

오토박싱을 사용할 경우 기본 타입의 값을 Wrapper 클래스 객체로 변환하는 과정에서 새로운 객체가 생성된다. 이 과정에서 메모리 할당 가비지 컬렉션 등의 부하가 발생하므로 성능 저하가 발생할 수 있다.

따라서 래퍼클래스가 필요한 곳에선 오토박싱을 이용하지 않고 애초에 래퍼클래스를 사용하는 코드로 작성하는 것이 좋을 것이다.

### 인터페이스, 추상클래스의 공통점에 대해 말씀해 주세요.

1. 추상 메소드를 가지고 있어야 한다.
2. 인스턴스화 할 수 없다
3. 인터페이스 혹은 추상 클래스를 상속받아 구현한 구현체의 인스턴스를 사용해야 한다.
4. 인터페이스와 추상클래스를 구현, 상속한 클래스는 추상 메소드를 반드시 구현하여야 한다.

### 인터페이스, 추상클래스의 차이점에 대해 말씀해 주세요.

|  | 추상 클래스 | 인터페이스 |
| --- | --- | --- |
| 사용 키워드 | abstract | interface |
| 사용 가능 변수 | 제한 없음 | static final (상수) |
| 사용 가능 접근 제어자 | 제한 없음 (public, private, protected, default) | public |
| 사용 가능 메소드 | 제한 없음 | abstract method, default method, static method, private method |
| 상속 키워드 | extends | implements |
| 다중 상속 가능 여부 | 불가능 | 가능 (클래스에 다중 구현, 인터페이스 끼리 다중 상속) |

### 인터페이스, 추상클래스를 각각 사용하기 좋은 시점이 언제라고 생각하시나요?

### 인터페이스 사용시기

- 다중상속 적용하고 싶을 때
- 인터페이스의 필드가 아닌 기능만 필요할 때

### 추상클래스 사용시기

- 기존 기능을 상속을 통하여 확장시키고자 할때
- 클래스의 상태(필드)가 필요할 때
- 코드 재사용이 필요할 때

### Checked/Unchecked Exception에 대해 설명해 주시고, 차이점에 대해 말씀해주세요.

### Checked Exception

- **컴파일 시점에 컴파일러에서 확인하는 예외**
- **반드시 에러 처리를 해야 하는 특징(try/catch or throw)을 가지고 있다.**

### Unchecked Exception

- **RuntimeException을 상속하는 클래스**
- **런타임 단계에서 확인 가능**
- **에러 처리를 강제하지 않는다.**

### 차이점

- 예외 처리 강제유무
- 예외 확인 시점
- 트랜잭션 롤백 유무

### Static에 대해 설명해 주시고, 저장되는 공간에 대해 말씀해 주세요.

- 객체(인스턴스)에 소속된 멤버가 아니라 클래스에 고정된 멤버입니다.
- 클래스의 로딩이 끝나는 즉시 바로 사용할 수 있습니다.
- 객체가 없어도 사용 가능한 메소드/필드들이기 때문에 유틸성 클래스에서 주로 사용합니다.
- 자바 8 이전
    - Permanent 영역에서 관리
    - Permanent : JVM에 의해 크기가 강제되던 영역
- 자바 8 이후
    - static의 reference는 Metaspace 영역에서 관리
    - 실제로 저장은 heap영역에 이루어짐. → 따라서 GC의 대상이 될 수 있음.
    - Metaspace : Native Memory 영역으로, os가 자동으로 크기를 조절.

### Final 키워드가 적용되는 곳에 대해 말씀해 주시고, 장점에 대해 말씀해 주세요.

### **final 클래스**

- final이 붙어있는 클래스는 상속할 수 없습니다. 이렇게 하면 보안이나 효율성 측면에서 장점이 있습니다. `java.lang.System`이나 `java.lang.String`처럼 자바에서 기본적으로 제공하는 라이브러리 클래스는 final을 사용한다고 하네요.

### **final 메서드**

- 만약 어떤 클래스를 상속하는데 그 안에 final 메서드가 있다면, 오버라이딩으로 수정할 수 없습니다.

### **final 변수**

- final 변수는 한 번 값을 할당하면 수정할 수 없습니다. 즉, 초기화는 한 번만 가능합니다.

### 장점

- **불변성**: `final` 변수는 읽기 전용이 되므로, 애플리케이션의 실행 도중에 예상치 못한 변경으로부터 안전하다.
- **스레드 안정성**: 멀티스레드 환경에서 `final` 필드는 한 번 생성되고 초기화된 이후에는 변경되지 않으므로, 스레드 간에 안전하게 공유될 수 있다.
- **성능 최적화**: 컴파일러와 `JVM`은 `final` 키워드를 사용하는 요소에 대해 추가적인 최적화를 수행할 수 있다.
    - 컴파일러 최적화: final 변수는 변하지 않는 값이므로, 컴파일러는 이를 알고 더 효율적인 코드로 최적화할 수 있습니다. 예를 들어, final 변수에 대한 접근은 인라인화될 수 있어, 메서드 호출 오버헤드를 줄일 수 있습니다.
    - JIT 컴파일러 최적화: JVM의 JIT(Just-In-Time) 컴파일러는 런타임에 final 메서드와 클래스에 대한 추가 최적화를 수행할 수 있습니다. final 메서드는 오버라이드될 수 없기 때문에, 직접적인 메서드 호출로 해석될 수 있으며, 이는 런타임 성능을 향상시킵니다.
- **설계 의도 명확화**: `final` 키워드는 코드를 읽는 사람에게 해당 요소가 변경되지 않을 것임을 명확하게 전달한다.

### Generic에 대해 말씀해 주시고, 장점에 대해 말씀해 주세요.

- 클래스나 메소드에서 사용할 내부 데이터 타입을 컴파일 시에 미리 지정하는 방법

### 장점

**1.** 제네릭을 사용하면 잘못된 타입이 들어올 수 있는 것을 컴파일 단계에서 방지할 수 있다.

**2.** 클래스 외부에서 타입을 지정해주기 때문에 따로 타입을 체크하고 변환해줄 필요가 없다. 즉, 관리하기가 편하다.

**3.** 비슷한 기능을 지원하는 경우 코드의 재사용성이 높아진다.

### 람다식과 스트림에 대해 말씀해 주세요.

### 람다식

- 람다식(Lambda expression)은 간단히 말해서 메서드를 하나의 '식(expression)'으로 표현한 것이다. 람다식은 함수를 간략하면서도 명확한 식으로 표현할 수 있게 해준다.
- 메서드를 람다식으로 표현하면 메서드의 이름과 반환값이 없어지므로, 람다식을 '익명 함수(anonymous function)'이라고도 한다.

### Stream

- 배열, 컬렉션의 구성요소들을 순회하며 처리할 수 있게 해주는 자료형/코드패턴.
- 람다를 사용할 수 있는 기술 중 하나

### 스트림의 특징에 대해 말씀해 주세요.

### 스트림은 데이터 소스를 변경하지 않는다.

- 스트림은 데이터 소스로 부터 데이터를 읽기만할 뿐, 데이터 소스를 변경하지 않는다는 차이가 있다. 필요하다면, 정렬된 결과를 컬렉션이나 배열에 담아서 반환할 수도 있다.

```java
List<String> sortedList = strStream2.sorted().collect(Collectors.toList());
```

### 스트림은 일회용이다.

- 스트림은 Iterator처럼 일회용이다. Iterator로 컬렉션의 요소를 모두 읽고 나면 다시 사용할 수 없는 것처럼, 스트림도 한번 사용하면 닫혀서 다시 사용할 수 없다. 필요하다면 스트림을 다시 생성해야 한다.

### 스트림은 작업을 내부 반복으로 처리한다.

- 스트림을 이용한 작업이 간결할 수 있는 비결중의 하나가 바로 '내부 반복'이다. 내부 반복이라는 것은 반복문을 메서드의 내부에 숨길 수 있다는 것을 의미한다. forEach()는 스트림에 정의된 메서드 중의 하나로 매개변수에 대입된 람다식을 데이터 소스의 모든 요소에 적용한다.

```
stream.forEach(System.out::println);
//System.out::println == (str)->System.out.println(str)
```

### 스트림의 연산

- 스트림이 제공하는 다양한 연산을 이용해서 복잡한 작업들을 간단히 처리할 수 있다. 마치 데이터베이스에 SELECT문으로 질의하는 것과 같은 느낌이다.
- 스트림이 제공하는 연산은 중간 연산과 최종 연산으로 분류할 수 있는데, 중간 연산은 연산결과를 스트림으로 반환하기 때문에 중간 연산을 연속해서 연결할 수 있다. 반면에 최종 연산은 스트림의 요소를 소모하면서 연산을 수행하므로 단 한번만 연산이 가능하다.

> 중간 연산 : 연산 결과가 스트림인 연산. 스트림에 연속해서 중간 연산할 수 있음
>
>
> 최종 연산 : 연산 결과가 스트림이 아닌 연산. 스트림의 요소를 소모하므로 단 한번만 가능
>

### 지연된 연산

- 스트림 연산에서 한 가지 중요한 점은 최종 연산이 수행되기 전까지는 중간 연산이 수행되지 않는다는 것이다. 스트림에 대해 distinct()나 sort()같은 중간 연산을 호출해도 즉각적인 연산이 수행되는 것은 아니라는 것이다.
- 중간 연산을 호출하는 것은 단지 어떤 작업이 수행되어야하는지를 지정해주는 것일 뿐이다. 최종 연산이 수행되어야 비로소 스트림의 요소들이 중간 연산을 거쳐 최종 연산에서 소모된다.

### 병렬 스트림

- 스트림으로 데이터를 다룰 때의 장점 중 하나가 바로 병렬 처리가 쉽다는 것이다.
    - parallel() : 병렬로 연산은 수행하도록 지시
    - sequential() : 병렬로 처리되지 않도록 지시

### 리플렉션에 대해 설명해 주시고, 언제 사용하는지 말씀해 주세요.

### Reflection

클래스 로더를 통해 static(Method) 영역에 로드된 Class Type의 객체를 통해, 구체적인 Class Type을 알지 못하더라도 해당 Class의 다음과 같은 정보에 접근할 수 있게 한다.

1. Method
2. Class
3. Field
4. Constructor

위와 같은 기능 덕분에, 컴파일된 바이트 코드를 통해 Runtime에 동적으로 특정 Class의 정보를 추출할 수 있는 기능을 제공하는 것이 Java Reflection API이다.

## 언제 사용하는가?

1. 동적으로 Class를 사용하는 경우
    - Compile time이 아닌, Runtime에 Class를 가져와서 실행해야 하는 경우 (ex : Spring DI)
    - 객체 생성, 필드 조작, 메소드 호출
2. 클래스의 정보를 탐색하는 경우
    - 클래스 이름, Super class, (접근제한자와 상관 없이) 모든 필드, 메소드, 생성자 등
3. JSON/XML 등의 데이터로 직렬화/역직렬화 할 때
    - 다양한 라이브러리들이 리플렉션을 통해 해당 클래스의 필드와 직렬화된 JSON/XML을 매핑시킨다.
4. Proxy 객체
    - 다양한 메소드 콜을 intercept하는 프록시 객체를 생성.
    - Lazy Loading
5. AOP(JDK Dynamic Proxy only)
    - AOP 대상을 프록시 객체로 만들기 위해 reflection을 사용하여 구현한다.

### 리플렉션의 장단점에 대해 설명해 주세요.

## 장점

- 어플리케이션 내에서가 아닌, 외부 라이브러리/프레임워크가 런타임시에 동작할 때 쓰인다.
    - 프레임워크/라이브러리 등에서는 해당 프레임워크/라이브러리가 어디에 쓰일지 모르므로 리플렉션을 이용하여 동적으로 기능을 이용할 수 있도록 한다.
    - 실제로 다양한 프레임워크/라이브러리에서 Reflection을 이용한다. (ex : Spring DI, JPA Entity 등)
- 디버깅 시 리플렉션을 이용하여 private field까지도 검사할 수 있다.

## 단점

- 성능이 떨어진다.
    - 동적으로 객체를 생성하므로, JIT Compiler의 최적화를 받지 못한다.
    - 매번 명시된 클래스가 맞는지, 적절한 생성자를 이용했는지에 대해서 체크를 해야 한다.
- 캡슐화가 깨진다.
    - 리플렉션을 통해 접근제한자 상관없이 모든 필드/메소드를 접근할 수 있으므로.
- Compile-time Safety를 누리지 못한다.
    - 런타임 시에 객체가 생성되므로, 컴파일 시점에 누릴 수 있는 type check/Exception check를 이용하지 못한다.

### 동적 프록시에 대해 설명해 주세요.

### Dynamic Proxy

- 프록시를 사용하기 위해서는 대상 클래스 수만큼의 프록시 클래스를 하나하나 만들어줘야하고 그 안에 들어가는 반복되는 코드때문에 코드중복이라는 단점이 있습니다.
- 개발자가 직접 일일히 프록시 객체를 생성하는 것이 아닌, 애플리케이션 실행 도중 java.lang.reflect.Proxy 패키지에서 제공해주는 API를 이용하여 동적으로 프록시 인스턴스를 만들어 등록하는 방법으로서, 자바의Reflection API 기법을 응용한 연장선의 개념이다

### Dynamic Proxy 구성요소

- Class loader
- 타깃의 인터페이스
- InvocationHandler : 타깃의 정보가 포함된 Handler
