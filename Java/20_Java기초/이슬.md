# 📍 키워드
- Java 기초
    - 접근제어자
    - 클래스, 객체, 인스턴스 차이
    - Overloading vs Overriding
    - Primitive type vs Reference type
        - Call by Reference vs Call by Value
        - Wrapper Class
    - 인터페이스 vs 추상 클래스
    - Checked Exception vs UnChecked Exception
    - static
    - final
    - generic
    - stream, lambda
    - Reflection & Dynamic Proxy

<br>

# 📍 예상 질문
<details>
<summary>접근제어자에 대해 설명해주세요.</summary>
<div markdown="1">

- 자바에서 접근 제어자는 클래스, 변수, 메소드 및 생성자에 대한 접근 수준을 설정하는 데 사용됩니다. 접근 제어자의 목적은 데이터 은닉과 캡슐화를 제공하여, 클래스 내부의 세부 구현을 외부로부터 보호하고, 객체 지향 프로그래밍의 원칙을 강화하는 것입니다. 자바에는 네 가지 접근 제어자가 있습니다: public, protected, default(접근 제어자를 명시하지 않는 경우), private.

1. public: public으로 선언된 클래스, 메소드, 변수는 다른 모든 클래스에서 접근할 수 있습니다. 즉, 어떤 클래스에서든 접근이 가능합니다.
2. protected: protected로 선언된 변수와 메소드는 같은 패키지 안의 다른 클래스 또는 다른 패키지에 있는 서브 클래스에서 접근할 수 있습니다.
3. default: 별도의 접근 제어자를 지정하지 않으면, 클래스, 변수, 메소드는 default 접근 제어를 가집니다. 이는 같은 패키지 내의 클래스에서만 접근할 수 있음을 의미합니다. 다른 패키지에서는 접근할 수 없습니다.
4. private: private로 선언된 변수와 메소드는 해당 변수와 메소드가 선언된 클래스 내에서만 접근할 수 있습니다. 클래스 외부에서는 접근할 수 없어, 가장 제한적인 접근 수준을 제공합니다.

</div>
</details>
<details>
<summary>클래스, 객체, 인스턴스 차이점은 무엇인가요?</summary>
<div markdown="1">

1. 클래스(Class): 클래스는 객체를 생성하기 위한 템플릿 또는 설계도입니다. 클래스는 객체의 상태를 나타내는 필드(변수)와 객체의 행동을 정의하는 메소드(함수)로 구성됩니다. 클래스는 객체의 설계도 역할을 하며, 실제 사용을 위해서는 이를 기반으로 객체를 생성해야 합니다.
2. 객체(Object): 객체는 클래스에 정의된 내용을 바탕으로 메모리에 할당된 실체입니다. 즉, 클래스를 기반으로 생성된 런타임 엔티티입니다. 
3, 인스턴스(Instance): 인스턴스는 객체와 거의 같은 의미로 사용되지만, 클래스와의 관계에 초점을 맞춥니다. 즉, 인스턴스는 특정 클래스로부터 생성된 객체를 의미합니다. 특정 클래스 타입의 객체가 메모리에 할당되어 실제로 사용될 때, 그 객체를 그 클래스의 인스턴스라고 합니다. 예를 들어, 자동차 클래스로부터 생성된 객체는 자동차 클래스의 인스턴스입니다.

- 요약하자면, 클래스는 객체의 설계도이며, 객체는 클래스를 기반으로 생성된 실체입니다. 인스턴스는 특정 클래스로부터 생성된 객체를 지칭하는 데 사용되는 용어로, 클래스와 객체 사이의 관계를 강조합니다.

</div>
</details>
<details>
<summary>메소드 오버로딩과 오버라이딩의 차이점은 무엇인가요?</summary>
<div markdown="1">

- 메소드 오버로딩(Method Overloading)
    - 메소드 오버로딩은 같은 이름을 가진 메소드를 클래스 내에 여러 개 정의하는 것을 의미합니다.
    - 오버로딩된 메소드들은 매개변수의 타입, 개수 또는 순서가 달라야 합니다.
    - 오버로딩은 컴파일 타임(컴파일 시점)에 결정됩니다. 즉, 컴파일러는 메소드를 호출할 때 제공된 매개변수의 타입과 개수를 기반으로 어떤 메소드를 사용할지 결정합니다. (컴파일 다형성)
    - 오버로딩의 목적은 같은 기능을 수행하지만, 다른 매개변수를 받아야 할 때 코드의 가독성과 재사용성을 높이는 것입니다.

- 메소드 오버라이딩(Method Overriding)
    - 메소드 오버라이딩은 서브 클래스에서 수퍼 클래스로부터 상속받은 메소드의 구현을 재정의하는 것을 의미합니다.
    - 오버라이딩된 메소드는 수퍼 클래스의 메소드와 같은 이름, 같은 매개변수, 같은 반환 타입을 가져야 합니다.
    - 오버라이딩은 런타임(실행 시점)에 결정됩니다. 즉, 객체의 타입을 기반으로 어떤 메소드가 호출될지 결정됩니다. (런타임 다형성)
    - 오버라이딩의 목적은 상속받은 메소드를 서브 클래스가 특정한 방식으로 동작하도록 변경하는 것입니다.

- 요약하면, 메소드 오버로딩은 같은 클래스 내에서 같은 이름의 메소드를 매개변수를 달리하여 여러 번 정의하는 것이고, 메소드 오버라이딩은 서브 클래스에서 수퍼 클래스의 메소드를 재정의하는 것입니다.

</div>
</details>
<details>
<summary>Primitive 타입과 Reference 타입의 차이점은 무엇인가요?</summary>
<div markdown="1">

- Primitive 타입 (기본 타입)
    - 정의: 기본 타입은 자바에서 미리 정의되어 있고, 이름이 키워드로 지정된 8가지 타입을 말합니다. 이에는 byte, short, int, long, float, double, char, boolean이 포함됩니다.
    - 저장되는 값: 기본 타입의 변수는 실제 값을 메모리에 직접 저장합니다.
    - 메모리 사용: 기본 타입의 값은 스택 메모리 영역에 저장됩니다. 이로 인해 처리 속도가 빠릅니다.
    - 초기값: 각 기본 타입은 명시적으로 초기화하지 않을 경우 자동으로 기본값을 가집니다. 예를 들어, int의 기본값은 0, boolean의 기본값은 false입니다.
- Reference 타입 (참조 타입)
    - 정의: 참조 타입은 기본 타입을 제외한 타입으로, 클래스, 인터페이스, 배열 등이 있습니다. 참조 타입의 변수는 객체의 참조(주소)를 저장합니다.
    - 저장되는 값: 참조 타입의 변수는 메모리에 객체가 저장된 주소를 가리키며, 실제 데이터는 힙 메모리 영역에 저장됩니다.
    - 메모리 사용: 객체는 힙 메모리에 저장되고, 이 힙 영역은 실행 시간 동안 동적으로 할당 및 해제됩니다. 참조 타입은 스택 메모리에 참조 값만 저장하기 때문에 기본 타입에 비해 상대적으로 더 많은 메모리를 사용할 수 있습니다.
    - 초기값: 참조 타입 변수는 명시적으로 초기화하지 않으면 null 값을 가집니다. null은 아무것도 참조하지 않음을 의미합니다.
- 요약
    - Primitive 타입: 실제 값을 메모리에 직접 저장하며, 처리 속도가 빠릅니다. 기본값이 있습니다.
    - Reference 타입: 메모리에 객체의 주소를 저장하며, 객체 자체는 힙 메모리에 저장됩니다. 초기화하지 않으면 null 값을 가집니다.

</div>
</details>
<details>
<summary>Wrapper 클래스란 무엇이며, 왜 사용하나요?</summary>
<div markdown="1">

- Wrapper 클래스는 자바의 기본 타입(Primitive 타입)을 객체로 다루기 위해 사용하는 클래스입니다. 
- Wrapper 클래스의 사용 이유:
    1. 컬렉션 프레임워크와의 호환: 자바의 컬렉션 프레임워크(예: ArrayList, HashMap 등)는 객체만 저장할 수 있습니다. 기본 타입의 데이터를 이러한 컬렉션에 저장하려면, 해당 기본 타입의 Wrapper 클래스를 사용해야 합니다.
    2. 유용한 메소드 제공: Wrapper 클래스는 기본 타입의 데이터를 다루는 데 유용한 여러 메소드를 제공합니다. 예를 들어, 문자열을 해당 기본 타입의 값으로 변환하거나, 최대/최소값을 얻는 등의 작업이 이에 해당합니다.
    3. null 값 사용: 기본 타입은 null 값을 가질 수 없지만, Wrapper 클래스를 사용하면 null 값을 할당할 수 있습니다. 이는 데이터가 '없음' 또는 '정의되지 않음'을 표현해야 할 경우 유용합니다.
    4. 제네릭과의 사용: 자바의 제네릭은 기본 타입을 직접 사용할 수 없습니다. 따라서, 기본 타입 데이터를 제네릭 타입으로 사용하고 싶을 때 Wrapper 클래스를 활용합니다.

</div>
</details>
<details>
<summary>Boxing(박싱), Unboxing(언박싱)에 대해서 설명해주세요.</summary>
<div markdown="1">

- 박싱(Boxing)과 언박싱(Unboxing)은 자바에서 기본 타입(Primitive type)과 참조 타입(Reference type, 여기서는 Wrapper 클래스) 사이의 변환 과정을 말합니다. 이러한 과정은 기본 타입의 데이터를 객체로 다루기 위해 필요하며, 자바 5부터는 자동으로 이러한 변환을 처리하는 '오토 박싱(Auto Boxing)'과 '오토 언박싱(Auto Unboxing)' 기능을 제공합니다.
- 박싱은 기본 타입의 데이터를 해당하는 Wrapper 클래스의 객체로 변환하는 과정입니다.
- 언박싱은 박싱의 반대 과정으로, Wrapper 클래스의 객체를 기본 타입의 데이터로 변환하는 것을 말합니다.
- 자바 5부터는 개발자의 편의를 위해 박싱과 언박싱 과정을 자동으로 처리하는 기능을 도입했습니다. 이를 통해 기본 타입과 Wrapper 클래스 사이에서 명시적으로 변환 메서드를 호출하지 않아도 자동으로 변환됩니다.

</div>
</details>
<details>
<summary>인터페이스와 추상 클래스의 차이점은 무엇인가요?</summary>
<div markdown="1">

- 인터페이스와 추상 클래스는 자바에서 추상화를 구현하는 두 가지 주요 방법입니다. 둘 다 직접 인스턴스화할 수 없으며, 하위 클래스 또는 구현 클래스가 상세한 구현을 제공하도록 합니다. 그러나 사용 목적과 제공하는 기능에서 차이점이 있습니다.

- 인터페이스 (Interface)
    - 정의: 인터페이스는 모든 메소드가 추상 메소드(Java 8부터는 default 메소드와 static 메소드를 제외한)로 선언되어야 하는 타입입니다. 인터페이스는 어떤 클래스가 구현해야 하는 행동을 정의하지만, 그 행동이 어떻게 실행되어야 하는지에 대해서는 설명하지 않습니다.
    - 특징:
        - 인터페이스의 메소드는 기본적으로 public abstract입니다.
        - Java 8 이후로는 default 메소드와 static 메소드를 사용할 수 있어, 구현 코드를 포함할 수 있게 되었습니다.
        - 필드는 public static final이어야 하므로, 변경할 수 없는 상수만 포함할 수 있습니다.
        - 하나의 클래스가 여러 인터페이스를 구현할 수 있습니다.
    - 사용 목적: 인터페이스는 다중 상속을 지원합니다. 이를 통해 서로 관련 없는 클래스들이 인터페이스를 구현함으로써 동일한 인터페이스 타입으로 처리될 수 있도록 합니다.

- 추상 클래스 (Abstract Class)
    - 정의: 추상 클래스는 하나 이상의 추상 메소드를 포함할 수 있는 클래스입니다. 추상 클래스는 이러한 추상 메소드의 실제 구현을 자식 클래스에게 강제합니다.
    - 특징:
        - 추상 클래스는 abstract 키워드를 사용하여 선언됩니다.
        - 추상 메소드뿐만 아니라 구현된 메소드도 포함할 수 있습니다.
        - 필드, 생성자, 정적 메소드 등을 포함할 수 있습니다.
        - 추상 클래스는 다른 클래스가 상속받을 수 있지만, 자바에서는 단일 상속만 지원하므로 하나의 추상 클래스만 상속받을 수 있습니다.
    - 사용 목적: 추상 클래스는 상속을 통한 다형성을 제공합니다. 공통된 기능을 구현하면서도 일부 메소드는 하위 클래스에서 구현하도록 강제하고자 할 때 사용됩니다.

- 인터페이스와 추상 클래스의 주요 차이점
    - 다중 구현: 클래스는 여러 인터페이스를 구현할 수 있지만, 하나의 추상 클래스만 상속받을 수 있습니다.
    - 메소드 구현: 인터페이스는 Java 8 이전에는 구현된 메소드를 가질 수 없었지만, 추상 클래스는 구현된 메소드를 가질 수 있습니다.
    - 구성 요소: 인터페이스는 static이거나 final인 필드만 가질 수 있으며, 추상 클래스는 이러한 제한 없이 필드를 가질 수 있습니다.
    - 생성자: 인터페이스에는 생성자가 없지만, 추상 클래스에는 생성자가 있어서 하위 클래스가 객체를 초기화할 때 사용할 수 있습니다.

</div>
</details>
<details>
<summary>언제 인터페이스를 사용하고, 언제 추상 클래스를 사용해야 하는가요?</summary>
<div markdown="1">

- 인터페이스를 사용해야 할 때:
1. 다중 구현이 필요한 경우: 자바는 다중 상속을 지원하지 않지만, 한 클래스가 여러 인터페이스를 구현할 수 있습니다. 서로 다른 클래스들이 공통의 계약(contract)을 공유해야 하지만, 그 구현이 서로 다를 때 인터페이스를 사용합니다.
2. 모듈 간의 결합도를 낮추고자 할 때: 인터페이스를 사용하면 구현체의 내부 로직에 대한 의존 없이, 단지 인터페이스가 정의하는 메소드 시그니처에만 의존하게 됩니다. 이는 모듈 간의 결합도를 낮추고 유지보수성을 향상시킵니다.
3. 확장성이 중요한 경우: 인터페이스는 시스템을 확장하기 위한 유연한 방법을 제공합니다. 새로운 기능이 필요할 때 기존 코드를 변경하지 않고 인터페이스에 새로운 메소드를 추가하거나 새로운 인터페이스를 정의함으로써 확장할 수 있습니다.

- 추상 클래스를 사용해야 할 때:
1. 공통된 코드를 공유하고 싶을 때: 추상 클래스를 사용하면 구현 코드를 하위 클래스에 상속할 수 있습니다. 여러 클래스에서 공통으로 사용되는 메소드나 필드가 있을 경우, 이를 추상 클래스에 정의하여 코드 중복을 줄일 수 있습니다.
2. 기본적인 행동을 정의하고 일부만 변경하고자 할 때: 추상 클래스는 기본적인 실행 로직을 구현하고, 하나 또는 그 이상의 메소드를 추상 메소드로 남겨서 하위 클래스에서 이를 구현하도록 할 수 있습니다. 이는 '템플릿 메소드 패턴'과 같은 디자인 패턴을 구현할 때 유용합니다.
3. 컴파일 시간에 서브 클래스 구현을 강제하고 싶을 때: 추상 클래스에 추상 메소드를 선언함으로써, 이를 상속받는 모든 클래스가 해당 메소드를 구현하도록 강제할 수 있습니다. 이는 인터페이스도 마찬가지이지만, 추상 클래스는 이와 더불어 공통의 구현을 제공할 수 있습니다.

</div>
</details>
<details>
<summary>인터페이스의 default 메서드가 나오게 된 계기에 대해서 설명해주세요.</summary>
<div markdown="1">

- 인터페이스의 default 메서드는 자바 8에서 도입되었으며, 이러한 기능이 추가된 주된 계기는 호환성 유지와 함수형 프로그래밍의 도입, 특히 람다 표현식의 지원을 용이하게 하기 위함입니다.

- 호환성 유지
    - 자바는 널리 사용되는 언어이며, 많은 라이브러리와 애플리케이션이 자바를 기반으로 개발되었습니다. 인터페이스에 새로운 메서드를 추가하는 것은 이전에 개발된 코드에 큰 영향을 줄 수 있습니다. 인터페이스에 새로운 메서드를 추가하면, 이 인터페이스를 구현한 모든 클래스에서 새로운 메서드를 구현해야 합니다. 이는 기존 코드의 호환성을 해치고, 많은 추가 작업을 필요로 합니다.
    - default 메서드는 이러한 문제를 해결합니다. 인터페이스에 새로운 기능을 추가하면서도, 기존에 이 인터페이스를 구현한 코드를 변경하지 않아도 되도록 해줍니다. default 메서드는 기본 구현을 제공하므로, 인터페이스를 구현한 기존 코드는 변경 없이 그대로 작동합니다. 따라서, 라이브러리나 프레임워크 개발자들은 기존 코드의 호환성을 유지하면서도 새로운 기능을 인터페이스에 추가할 수 있게 되었습니다.

- 함수형 프로그래밍의 도입
    - 자바 8에서는 함수형 프로그래밍 패러다임을 지원하기 위한 여러 기능이 도입되었습니다. 람다 표현식의 도입은 이러한 변화 중 하나였으며, 자바에서 함수형 인터페이스(functional interface)의 개념을 강화하는 데 중요한 역할을 했습니다. 함수형 인터페이스는 하나의 추상 메서드만을 가지며, 람다 표현식을 통해 이를 간결하게 구현할 수 있습니다.
    - default 메서드의 도입은 인터페이스에 추가적인 메서드를 제공하면서도, 해당 인터페이스가 함수형 인터페이스로서의 역할을 계속 유지할 수 있도록 해줍니다. 즉, 인터페이스에 새로운 메서드를 추가하더라도 추상 메서드의 수가 변하지 않게 하여, 람다 표현식과의 호환성을 유지할 수 있습니다.

- 결론적으로, default 메서드는 기존 코드의 호환성을 유지하고, 라이브러리 및 애플리케이션의 점진적인 개선을 용이하게 하며, 자바의 함수형 프로그래밍 기능을 강화하는 데 중요한 역할을 합니다.

</div>
</details>
<details>
<summary>인터페이스에서 default 메서드를 사용하게 되면 추상 클래스와 크게 다르지 않을 것 같은데 차이점이 있을까요?</summary>
<div markdown="1">

- 추상클래스와 인터페이스의 목적이 다릅니다. 추상 클래스는 코드의 중복을 제거하고 부모의 기능을 재사용을 하기 위해 사용하며, 단일 상속밖에 안된다는 단점이 있고, 인터페이스는 코드의 유연한 설계를 위해 사용하는 것이고, 다중 구현이 가능합니다. 따라서, 상황에 맞게 적절하게 사용 할 필요가 있습니다.

- 상속과 구현
    - 추상 클래스: 하나의 추상 클래스만 상속받을 수 있습니다. 이는 자바가 단일 상속만을 지원하기 때문입니다. 추상 클래스는 상태(필드)와 행동(메서드)을 상속할 수 있습니다.
    - 인터페이스: 하나의 클래스가 여러 인터페이스를 구현할 수 있습니다. 인터페이스는 메서드 선언과 default 메서드 구현을 통해 행동만을 제공하며, 전통적으로 상태(필드)를 제공하지 않습니다. (인터페이스에서 정적 또는 final 필드를 선언할 수는 있지만, 이는 인터페이스의 구현체가 공유하는 상수일 뿐입니다.)
- 상태 관리
    - 추상 클래스: 상태(필드)를 가질 수 있으며, 이 상태를 통해 객체의 상태를 관리할 수 있습니다. 또한, 비공개(private) 필드와 메서드를 통해 캡슐화를 구현할 수 있습니다.
    - 인터페이스: 자바 8 이전에는 상태를 가질 수 없었으며, 모든 필드는 public static final이어야 했습니다. 자바 8 이후로 default 메서드와 static 메서드를 가질 수 있게 되었지만, 여전히 인스턴스 필드를 가질 수 없으멀로 상태를 직접 관리할 수 없습니다.
- 생성자
    - 추상 클래스: 생성자를 가질 수 있습니다. 이를 통해 하위 클래스의 객체 생성 시 초기화 과정을 제어할 수 있습니다.
    - 인터페이스: 생성자를 가질 수 없습니다. 인터페이스는 직접 인스턴스화될 수 없으며, 구현체가 초기화 과정을 관리합니다.

</div>
</details>
<details>
<summary>Checked Exception과 UnChecked Exception의 차이점은 무엇인가요?</summary>
<div markdown="1">

- Checked Exception
    - 컴파일 시점에 확인됩니다. 즉, 컴파일러는 메서드에서 발생할 수 있는 Checked Exception을 선언하거나 처리하도록 강제합니다. 이를 통해 개발자가 예외를 명시적으로 처리하도록 유도합니다.
    - java.lang.Exception 클래스를 직접 또는 간접적으로 상속하지만, RuntimeException을 상속하지 않는 모든 예외가 여기에 해당합니다.
    - 일반적으로 외부의 영향(파일 입출력 오류, 네트워크 문제 등)으로 인해 발생할 수 있는 상황에서 사용됩니다.
    - 예를 들어, IOException, SQLException 등이 Checked Exception에 속합니다.
- Unchecked Exception
    - 런타임 시점에 확인됩니다. 즉, 컴파일러가 예외를 처리하거나 선언하도록 강제하지 않습니다. 개발자는 이러한 예외를 처리하기로 선택할 수 있지만, 필수는 아닙니다.
    - java.lang.RuntimeException과 그 하위 클래스들이 이 범주에 속합니다.
    - 일반적으로 프로그램의 버그나 잘못된 사용으로 인해 발생합니다. 예를 들어, 잘못된 타입 변환, 배열의 잘못된 인덱스 접근, null 참조 등이 이에 해당합니다.
    - 예를 들어, NullPointerException, IndexOutOfBoundsException, ClassCastException 등이 Unchecked Exception에 속합니다.

</div>
</details>
<details>
<summary>Spring에서 Transaction을 관리하는 경우 예외 롤백 대상에 대해 설명해주세요.</summary>
<div markdown="1">

- Unchecked Exception과 Error: 기본적으로 Spring은 RuntimeException (즉, Unchecked Exception)과 Error가 발생할 경우 트랜잭션을 롤백합니다. 이는 Spring의 기본 정책으로, 대부분의 경우 이러한 예외는 복구할 수 없는 심각한 문제를 나타내므로 트랜잭션을 롤백하는 것이 합리적입니다.
- Checked Exception: 기본적으로 Spring은 Checked Exception이 발생해도 트랜잭션을 롤백하지 않습니다. Checked Exception은 일반적으로 복구 가능한 예외 상황을 나타내며, 애플리케이션 코드에서 이를 적절히 처리할 수 있다고 가정하기 때문입니다.

- Spring에서는 @Transactional 어노테이션을 사용하여 트랜잭션 관리를 선언적으로 처리합니다. 이 어노테이션을 사용하면, 롤백을 위한 예외 처리 규칙을 커스터마이징할 수 있습니다.
    - rollbackFor: 특정 예외 타입이나 그 하위 타입의 예외가 발생했을 때 롤백을 수행하도록 설정할 수 있습니다. Checked Exception을 명시적으로 롤백 대상으로 지정할 때 유용합니다.
    - noRollbackFor: 특정 예외 타입에 대해서는 롤백을 수행하지 않도록 설정할 수 있습니다. 예를 들어, 특정 비즈니스 예외가 발생했을 때는 롤백하지 않도록 설정할 수 있습니다.

</div>
</details>
<details>
<summary>static 키워드는 어떤 경우에 사용되나요?</summary>
<div markdown="1">

- static은 클래스 멤버라고 하며, 클래스 로더가 클래스를 로딩해서 메소드 메모리 영역에 적재할 때 클래스별로 관리됩니다.
- static 키워드를 통해 생성된 정적멤버들은 PermGen 또는 Metaspace에 저장되며 저장된 메모리는 모든 객체가 공유하며 하나의 멤버를 어디서든지 참조할 수 있는 장점이 있습니다.
- 그러나, GC의 관리 영역 밖에 존재하기 때문에 프로그램 종료시까지 메모리가 할당된 채로 존재합니다. 너무 남발하게 되면 시스템 성능에 악영향을 줄 수 있습니다.

- 클래스 레벨의 멤버(필드, 메서드, 블록)를 선언하는 데 사용됩니다. static으로 선언된 멤버는 해당 클래스의 모든 인스턴스에 대해 공유되며, 클래스가 메모리에 로드될 때 한 번만 생성됩니다. 이러한 특징 때문에 static 멤버는 클래스 인스턴스 없이도 접근 가능합니다.

</div>
</details>
<details>
<summary>static 변수와 인스턴스 변수의 차이점은 무엇인가요?</summary>
<div markdown="1">

- 공유성: static 변수는 클래스 레벨에서 공유되는 반면, 인스턴스 변수는 각 객체 인스턴스에 고유합니다.
- 메모리 할당: static 변수는 클래스가 메모리에 로드될 때 한 번만 할당되고, 인스턴스 변수는 객체가 생성될 때마다 각 인스턴스마다 새로 할당됩니다.
- 접근성: static 변수는 클래스 이름을 통해 어디서든 접근할 수 있지만, 인스턴스 변수에 접근하려면 해당 객체의 인스턴스가 필요합니다.

</div>
</details>
<details>
<summary>static을 사용하면 어떤 이점이 있나요?</summary>
<div markdown="1">

1. 메모리 효율성
    - static 변수는 클래스가 메모리에 로드될 때 단 한 번만 할당되며, 이후 해당 클래스의 모든 인스턴스가 이 메모리를 공유합니다. 이는 같은 값을 가지는 변수를 각 인스턴스마다 별도로 저장할 필요가 없어 메모리 사용을 줄여줍니다.
2. 공유 데이터 관리
    - static 변수는 클래스의 모든 인스턴스에 의해 공유됩니다. 이를 통해 애플리케이션 내에서 공유되어야 하는 데이터(예: 설정 정보, 카운터 등)를 쉽게 관리할 수 있습니다.
3. 클래스 레벨의 메서드 접근
    - static 메서드는 인스턴스를 생성하지 않고도 호출할 수 있습니다. 이는 유틸리티 함수나 헬퍼 함수 같이 객체의 상태에 의존하지 않는 작업을 수행하는 데 유용합니다. 예를 들어, Math.sqrt() 메서드는 인스턴스 상태와 무관하게 동작하므로 static으로 선언됩니다.
4. 초기화 블록
    - static 초기화 블록을 사용하여 클래스 변수를 초기화하는 복잡한 로직을 구현할 수 있습니다. 이 초기화 블록은 클래스가 메모리에 로드될 때 단 한 번만 실행되며, 복잡한 초기화 작업을 수행하는 데 유용합니다.
5. 싱글턴 패턴 구현
    - static 변수와 메서드는 싱글턴 패턴 구현에 필수적입니다. 싱글턴 패턴은 특정 클래스의 인스턴스가 하나만 생성되어야 할 때 사용되며, static을 통해 이를 간단하게 구현할 수 있습니다.

</div>
</details>
<details>
<summary>JVM에서 static이 저장되는 위치는 어디인가요?</summary>
<div markdown="1">

- Java 7에서는 정적 멤버 변수가 PermGen(Method Area)에 저장되었습니다.
- 하지만 메모리 관리상의 문제로 인해 PermGen 영역이 사라지고 Metaspace 영역이 등장하면서, 정적 멤버 변수는 힙에 저장이 되도록 변경 되었습니다.
 
</div>
</details>
<details>
<summary>final 키워드는 어떤 경우에 사용되나요?</summary>
<div markdown="1">

- final 키워드는 주로 불변성을 부여하는 목적으로 사용됩니다.
1. 변수에 사용될 경우
    - 로컬 변수: final로 선언된 로컬 변수는 한 번 할당된 값을 변경할 수 없습니다. 이는 데이터의 불변성을 보장하는 데 유용합니다.
    - 필드(멤버 변수): 클래스의 필드에 final을 사용하면, 이 필드는 객체 생성 시 할당된 값을 변경할 수 없습니다. 객체마다 고유한 상수 값을 가질 때 유용합니다. final 필드는 선언 시, 또는 생성자 내에서 초기화해야 합니다.
    - 매개변수: 메서드의 매개변수를 final로 선언하면, 메서드 내에서 매개변수의 값을 변경할 수 없습니다. 이는 함수형 프로그래밍 패러다임에서 부수 효과(side effect)를 줄이는 데 도움이 됩니다.
2. 메서드에 사용될 경우
    - final로 선언된 메서드는 하위 클래스에서 오버라이드(재정의)할 수 없습니다. 이는 메서드의 동작을 변경할 수 없게 하여, 부모 클래스의 특정 행위가 모든 하위 클래스에서 동일하게 유지되도록 보장합니다.
3. 클래스에 사용될 경우
    - 클래스 전체에 final을 사용하면, 해당 클래스는 확장될 수 없습니다(상속 불가). 즉, 다른 클래스가 이 클래스를 상속할 수 없습니다. 이는 클래스의 동작을 변경할 수 없도록 하여, 보안과 불변성을 강화할 때 유용합니다.
- final 키워드의 사용은 객체의 불변성을 보장하고, 의도치 않은 변경으로부터 코드를 보호하는 데 도움이 됩니다.

</div>
</details>
<details>
<summary>final 키워드를 사용하면 어떤 이점이 있나요?</summary>
<div markdown="1">

1. 불변성(Immutability)의 보장
    - 변수: final을 사용한 변수는 불변의 값을 가집니다. 이는 데이터의 안전성을 향상시키며, 의도치 않은 변경으로부터 변수를 보호합니다. 불변 객체는 멀티스레드 환경에서 안전하게 공유될 수 있어, 동시성 문제를 줄이는 데 도움이 됩니다.
    - 메서드: final 메서드는 하위 클래스에서 오버라이드할 수 없습니다. 이를 통해 부모 클래스의 핵심 로직이 변경되지 않도록 보장하며, 코드의 안정성을 높일 수 있습니다.
    - 클래스: final 클래스는 다른 클래스에 의해 상속될 수 없습니다. 이는 클래스의 동작을 변경할 수 없게 하여, 클래스 설계의 안정성을 유지하며 보안 문제를 방지할 수 있습니다.
2. 컴파일 타임 체크
    - final 키워드를 사용함으로써 컴파일러는 불변성을 강제할 수 있으며, 이는 잠재적인 오류를 컴파일 시점에 발견하는 데 도움이 됩니다. 예를 들어, final 변수가 초기화 후에 변경되려고 하면 컴파일러는 오류를 발생시킵니다.
3. 성능 최적화
    - 컴파일러 최적화: final 변수는 변하지 않는 값이므로, 컴파일러는 이를 알고 더 효율적인 코드로 최적화할 수 있습니다. 예를 들어, final 변수에 대한 접근은 인라인화될 수 있어, 메서드 호출 오버헤드를 줄일 수 있습니다.
    - JIT 컴파일러 최적화: JVM의 JIT(Just-In-Time) 컴파일러는 런타임에 final 메서드와 클래스에 대한 추가 최적화를 수행할 수 있습니다. final 메서드는 오버라이드될 수 없기 때문에, 직접적인 메서드 호출로 해석될 수 있으며, 이는 런타임 성능을 향상시킵니다.
4. 코드의 의도와 가독성 향상
    - final 키워드의 사용은 변수, 메서드, 클래스가 변경되지 않아야 한다는 의도를 명확히 표현합니다. 이는 코드를 읽는 다른 개발자들에게 코드의 의도를 명확하게 전달하며, 코드의 가독성을 향상시킵니다.

</div>
</details>
<details>
<summary>final은 완벽히 불변성을 보장할까요?</summary>
<div markdown="1">

- final 키워드는 자바에서 변수, 메서드, 클래스에 대한 수정을 제한하지만, 완벽한 불변성(immutability)을 보장하지는 않습니다.
- 예를 들어, 객체 참조가 final이라도 그 객체의 필드가 변경될 수 있습니다(필드가 final이 아니라면).

</div>
</details>
<details>
<summary>Generic이란 무엇인가요?</summary>
<div markdown="1">

- 타입(type)의 안전성을 증가시키고, 코드 중복을 줄이기 위해 도입된 개념입니다. 제네릭을 사용하면 클래스, 인터페이스, 메서드를 정의할 때 타입(type)을 하나의 매개변수처럼 취급할 수 있습니다. 이를 통해 컴파일 시점에 타입 체크를 수행함으로써 타입 안정성을 높이고, 실행 시간에 발생할 수 있는 타입 관련 오류를 최소화할 수 있습니다.

</div>
</details>
<details>
<summary>Generic의 장점은 무엇인가요?</summary>
<div markdown="1">

1. 타입 안전성(Type Safety) 강화: 제네릭을 사용하면 컴파일 시점에 타입 체크가 가능해져, 잘못된 타입이 사용될 경우 컴파일 에러로 미리 알릴 수 있습니다. 이는 런타임에 발생할 수 있는 ClassCastException과 같은 오류를 예방해 줍니다.

2. 코드 재사용성 향상: 제네릭을 사용하면 동일한 코드를 다양한 타입에 대해 사용할 수 있습니다. 이는 코드의 재사용성을 높이고, 코드 중복을 줄여줍니다. 예를 들어, 제네릭을 사용한 단일 리스트 클래스는 다양한 타입의 객체를 저장할 수 있습니다.

3. 명시적인 타입 캐스팅 제거: 제네릭을 사용하지 않는 코드에서는 객체를 특정 타입으로 캐스팅하기 위해 명시적인 타입 캐스팅이 필요합니다. 제네릭을 사용하면 이러한 타입 캐스팅이 필요 없어져 코드가 보다 간결해지고 가독성이 향상됩니다.

4. API 설계와 사용의 명확성: 제네릭을 사용하면 메서드 시그니처나 클래스, 인터페이스의 선언에서 사용되는 타입의 의도를 명확하게 표현할 수 있습니다. 이는 API를 설계하고 사용하는 과정에서 오류를 줄이고, 사용자가 API를 보다 쉽게 이해하고 사용할 수 있게 합니다.

5. 보다 강력한 추상화 수단: 제네릭을 통해 타입 매개변수를 사용함으로써, 보다 일반적이고 유연한 코드를 작성할 수 있습니다. 이는 프로그래밍 언어에서의 추상화 수준을 한 단계 끌어올릴 수 있는 수단을 제공합니다.

</div>
</details>
<details>
<summary>와일드카드 타입은 무엇이며 어떻게 사용하나요?</summary>
<div markdown="1">

- 와일드카드 타입(Wildcard Type)은 제네릭 타입의 불확실성을 다루기 위해 자바에서 사용하는 특별한 매개변수 타입입니다. 와일드카드는 ? 기호를 사용하여 표현되며, 제네릭 타입의 범위를 제한할 수 있습니다. 와일드카드는 주로 제네릭 타입의 상한(Upper Bounded Wildcards)과 하한(Lower Bounded Wildcards)을 지정하는 데 사용됩니다.
- 상한 와일드카드(Upper Bounded Wildcards)
    - 상한 와일드카드는 특정 타입 또는 그 타입의 하위 타입만을 허용하도록 제한합니다. ? extends Type 형태로 사용되며, Type이나 그 하위 타입의 객체들만 받을 수 있습니다.
- 하한 와일드카드(Lower Bounded Wildcards)
    - 하한 와일드카드는 특정 타입 또는 그 타입의 상위 타입만을 허용하도록 제한합니다. ? super Type 형태로 사용되며, Type이나 그 상위 타입의 객체들만 받을 수 있습니다.

</div>
</details>
<details>
<summary>자바 8의 스트림(Stream)이란 무엇인가요?</summary>
<div markdown="1">

- 자바 8에서 소개된 스트림(Stream) API는 데이터 컬렉션 처리를 위한 새로운 추상화입니다. 스트림 API를 사용하면 선언적으로(즉, 어떻게(How)가 아닌 무엇을(What)에 집중하여) 컬렉션 데이터를 처리할 수 있으며, 이는 코드의 가독성과 간결성을 높여줍니다. 또한, 스트림 API는 함수형 프로그래밍 스타일을 자바에 도입하여, 병렬 처리(parallel processing)를 포함한 고성능 데이터 처리가 가능하도록 설계되었습니다.

- 스트림(Stream)의 특징
    -  선언적 처리: 데이터를 어떻게 처리할지의 절차적인 로직 대신, 무엇을 할지에 대한 선언적인 접근을 제공합니다.
    - 불변성(Immutability): 스트림 연산은 원본 데이터를 변경하지 않고, 새로운 스트림을 반환합니다.
    - 내부 반복(Internal Iteration): 스트림 API는 '내부 반복'을 사용하여 컬렉션의 요소를 반복 처리합니다. 이는 명시적으로 반복문을 작성할 필요가 없음을 의미합니다.
    - 파이프라이닝(Pipelining): 여러 스트림 연산을 연결하여 큰 연산 파이프라인을 구성할 수 있으며, 이는 마치 물이 파이프를 통해 흐르는 것과 유사합니다.
    - 병렬 처리(Parallel Processing) 지원: 스트림 API는 '병렬 스트림'을 통해 데이터를 병렬로 처리할 수 있는 기능을 제공합니다. 이를 통해 멀티코어 프로세서의 성능을 쉽게 활용할 수 있습니다.

</div>
</details>
<details>
<summary>람다 표현식의 장점은 무엇이며, 어떤 상황에서 사용하나요?</summary>
<div markdown="1">

- 람다 표현식은 자바 8부터 도입된 기능으로, 간결하게 익명 함수를 표현할 수 있게 해주는 문법입니다. 

- 람다 표현식의 장점
    1. 코드의 간결성: 복잡한 익명 클래스를 사용하는 대신, 람다 표현식을 사용하면 보다 간결하고 읽기 쉬운 코드를 작성할 수 있습니다. 이는 코드의 양을 줄이고, 가독성을 높여줍니다
    2. 함수형 프로그래밍 지원: 람다 표현식은 함수형 프로그래밍의 개념을 자바에 도입합니다. 이를 통해 개발자는 함수를 일급 객체로 다루며, 높은 수준의 추상화와 모듈성을 달성할 수 있습니다.
    3. 병렬 처리 용이: 람다 표현식은 스트림 API와 결합하여 사용될 때, 데이터의 병렬 처리와 함수형 연산을 쉽게 구현할 수 있도록 해줍니다. 이는 멀티코어 프로세서의 효율적인 활용을 가능하게 합니다.
    4. 지연 실행(Lazy Execution): 람다 표현식을 사용하면 필요할 때까지 코드의 실행을 지연시킬 수 있습니다. 이는 성능 최적화에 도움을 줄 수 있습니다.

- 람다 표현식의 사용 상황
    1. 컬렉션 처리: 자바의 컬렉션 프레임워크와 스트림 API를 사용할 때, 람다 표현식을 활용하면 데이터를 효율적으로 처리, 필터링, 변환 및 집계할 수 있습니다.
    2. 스레드 실행: Runnable 인터페이스의 구현체를 생성할 때 람다 표현식을 사용하면, 스레드를 생성하고 실행하는 코드를 간결하게 작성할 수 있습니다.
    3. 함수형 인터페이스 사용: 자바에서 제공하는 함수형 인터페이스(Function<T,R>, Predicate<T>, Consumer<T> 등)를 사용할 때 람다 표현식을 활용하면, 명시적인 클래스 선언 없이도 인터페이스의 구현체를 쉽게 제공할 수 있습니다.

</div>
</details>
<details>
<summary>자바 리플렉션(Reflection)에 대해 설명해 주세요.</summary>
<div markdown="1">

- 자바 리플렉션(Reflection)은 런타임 시에 클래스의 정보를 조회하거나 수정할 수 있는 기능을 말합니다. 클래스의 필드(field), 메소드(method), 생성자(constructor) 등의 메타데이터를 조회하거나, 객체를 동적으로 생성하고 메소드를 호출하는 등의 작업을 할 수 있습니다. 리플렉션은 자바의 java.lang.reflect 패키지를 통해 제공됩니다.

- 리플렉션의 주요 사용 사례
    1. 런타임 시에 클래스 정보 조회: 클래스의 이름, 필드, 메소드, 어노테이션 등의 정보를 런타임 시에 조회할 수 있습니다. 이는 동적으로 객체의 상태를 분석하거나 변경해야 할 때 유용합니다.
    2. 동적 객체 생성: Class 객체를 통해 런타임 시에 객체를 동적으로 생성할 수 있습니다. 이는 클래스의 이름이 컴파일 시점에는 알려져 있지 않지만, 런타임 시에 결정되는 경우에 유용합니다.
    3. 동적 메소드 호출: 메소드의 이름을 이용하여 런타임 시에 해당 메소드를 호출할 수 있습니다. 이는 유연한 코드 작성을 가능하게 합니다.
    4. 어노테이션 처리: 런타임 시에 어노테이션 정보를 읽어와서 처리할 수 있습니다. 이는 다양한 프레임워크에서 설정 정보를 처리할 때 자주 사용됩니다.

</div>
</details>
<details>
<summary>리플렉션을 사용할 때 문제점은 무엇인가요?</summary>
<div markdown="1">

1. 성능 저하: 리플렉션을 통한 메소드 호출, 필드 접근 등은 직접적인 코드 실행보다 상대적으로 느립니다. 리플렉션은 런타임 시에 메소드를 찾고, 접근 권한을 확인하고, 호출을 수행하는 등의 추가적인 처리가 필요하기 때문에 오버헤드가 발생합니다. 성능이 중요한 애플리케이션에서는 이러한 성능 저하가 문제가 될 수 있습니다.
2. 보안 문제: 리플렉션을 사용하면 private 메소드나 필드에도 접근할 수 있게 됩니다. 이는 객체의 캡슐화를 깨뜨리고, 불필요하거나 위험한 방식으로 내부 구조를 변경할 가능성을 열어줍니다. 따라서 보안이 중요한 애플리케이션에서는 리플렉션 사용에 주의가 필요합니다.
3. 코드의 복잡성 증가: 리플렉션을 사용하는 코드는 일반적인 자바 코드에 비해 이해하기 어렵고 복잡할 수 있습니다. 리플렉션을 사용한 코드는 디버깅이 어렵고, 유지보수성이 떨어질 수 있습니다.
4. 컴파일 타임 체크의 부재: 리플렉션을 사용하면 대부분의 에러 체크가 런타임 시에 이루어집니다. 존재하지 않는 메소드나 필드에 접근하려고 할 때, 컴파일 타임이 아닌 런타임에 NoSuchMethodException, NoSuchFieldException 등의 예외가 발생합니다. 이는 개발 과정에서 버그를 조기에 발견하는 것을 어렵게 만듭니다.
5. API 변경에 대한 취약성: 리플렉션을 사용하는 코드는 사용하는 클래스나 메소드의 내부 구현에 의존하게 됩니다. 이러한 내부 구현이 변경될 경우, 리플렉션을 사용하는 코드는 쉽게 깨질 수 있으며, 이는 애플리케이션의 안정성을 저하시킬 수 있습니다.

</div>
</details>
<details>
<summary>리플렉션을 사용하는 경우는 언제인가요?</summary>
<div markdown="1">

- 리플렉션은 테스트에서 내부 상태를 검사하거나, 비공개 메소드를 테스트하기 위해 사용될 수 있습니다.
- 또한 JPA Entity에서 기본키 자동 생성 전략인 경우, 단위 테스트를 위해 리플렉션으로 id값을 세팅해줄 때도 사용합니다.

</div>
</details>

<br>

# 📍 Reference
- https://headf1rst.github.io/TIL/jvm-static
- https://77loopin.github.io/java/Java-1/