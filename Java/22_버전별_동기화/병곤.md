###  자바 8의 주요 특징
2014년에 출시
- **람다 표현식(Lambda Expressions):** 코드를 더 간결하게 만들어주며, 함수형 프로그래밍 스타일을 자바에 도입했습니다.
- **스트림 API(Stream API):** 컬렉션 처리를 위한 새로운 API로, 람다를 활용하여 데이터를 선언적으로 처리할 수 있게 해줍니다.
- **인터페이스의 디폴트 메서드(Default Methods in Interfaces):** 인터페이스에 새로운 메서드를 추가하면서도 기존 구현을 깨트리지 않는 방법을 제공합니다.
- **날짜와 시간 API(Date and Time API):** Joda-Time에서 영감을 받은 새로운 날짜와 시간 API를 제공합니다.

### 자바 11의 주요 특징

2018년에 출시

- **로컬 변수의 var 키워드:** 소스 코드에서 로컬 변수에 대한 타입 추론을 가능하게 해주어, 변수 선언을 더 간결하게 만들어줍니다.
- **새로운 HTTP 클라이언트 API:** HTTP/2 프로토콜과 WebSocket을 지원하는 새로운 HTTP 클라이언트 API를 도입했습니다.
- **JDK의 일부 라이브러리와 API 제거:** Java EE와 CORBA 모듈과 같은 오래된 라이브러리와 API를 JDK에서 제거했습니다.
### 자바 17의 주요 특징
2021년에 출시시

- **실드 클래스(Sealed Classes):** 클래스나 인터페이스가 어떤 다른 클래스들에 의해서만 상속되거나 구현될 수 있게 제한할 수 있습니다.
- **패턴 매칭 for instanceof:** instanceof 연산자와 함께 사용할 때 타입 캐스팅 없이도 안전하게 변수를 사용할 수 있게 해줍니다.
- **새로운 가비지 컬렉터:** ZGC와 Shenandoah GC 같은 새로운 가비지 컬렉터를 지원하여, 더 짧은 가비지 컬렉션 휴지 시간을 제공합니다.
- **외부 메모리 액세스 API:** 자바 프로그램이 비자바 힙 메모리를 안전하게 관리하고 액세스할 수 있는 새로운 API를 도입했습니다.

### GC의 자바 주요 버전별 차이

자바의 가비지 컬렉션(GC) 메커니즘은 버전이 업데이트될 때마다 개선되어 왔습니다. 주요 버전별로 다음과 같은 차이점이 있습니다:

- **자바 8:** G1(Garbage-First) 가비지 컬렉터가 기본 GC로 도입되었습니다. 이는 대규모 힙에 적합하며, 가비지 컬렉션 휴지 시간을 줄여주는 것을 목표로 합니다.
- **자바 11:** 이후 버전에서는 기존 GC의 개선사항이 추가되었지만, 큰 변화는 없었습니다.
- **자바 17:** ZGC(Zero Garbage Collector)와 Shenandoah GC가 실험적 기능에서 정식 기능으로 승격되었습니다. 이들은 낮은 지연시간을 목표로 하며, 매우 큰 힙에서도 일관된 가비지 컬렉션 시간을 제공합니다.

### Thread safe란 무엇인가요?

Thread safe란, 여러 스레드에서 동시에 접근해도 프로그램 실행에 문제가 없는 코드를 의미합니다. 즉, 코드가 예상대로 실행되며, 공유 자원의 일관성과 상태의 정확성이 유지됩니다.

### Synchronized란 무엇인가요?

`Synchronized` 키워드는 자바에서 스레드 간의 동기화를 위해 사용됩니다. 이 키워드가 사용된 메소드나 블록은 한 번에 하나의 스레드만 실행할 수 있게 함으로써, 공유 자원에 대한 동시 접근을 방지합니다.

### Synchronized의 동작 과정

`Synchronized` 키워드가 적용된 메서드나 블록에 스레드가 접근하려 할 때, 이 스레드는 해당 객체의 락(lock)을 획득해야 합니다. 락을 이미 다른 스레드가 보유하고 있다면, 접근 시도한 스레드는 대기 상태가 됩니다. 락을 보유한 스레드가 실행을 마치고 락을 반환하면, 대기 중인 스레드 중 하나가 락을 획득하고 실행을 시작합니다.

### Synchronized를 직접 구현한다면 어떻게 하실건가요?

`Synchronized`와 유사한 기능을 직접 구현하려면, 락(locking) 메커니즘을 사용해야 합니다. 자바에서는 `ReentrantLock` 클래스를 사용하여 명시적인 락을 구현할 수 있습니다. 이 클래스는 `lock()`과 `unlock()` 메소드를 제공하여, 스레드가 블록을 실행하기 전에 락을 획득하고 실행 후에 락을 반환할 수 있도록 합니다.

### Volatile이란 무엇이고 Lock과 어떤 차이가 있나요?

`volatile` 키워드는 변수의 읽기와 쓰기를 메인 메모리에서 직접 실행하도록 함으로써, 변수 값의 가시성을 보장합니다. 하지만 `volatile` 변수는 원자적(atomic) 연산을 보장하지 않습니다. 반면, `Lock`은 여러 스레드가 동시에 접근하는 공유 자원에 대해 상호 배제(mutual exclusion)를 보장하며, 복잡한 조작이 필요한 경우에 사용됩니다.

### Atomic이란 무엇인가요?

Atomic 클래스들(예: `AtomicInteger`, `AtomicLong` 등)은 원자적 연산을 지원하는 클래스입니다. 이들은 멀티스레드 환경에서도 변수에 대한 연산이 중단되지 않고 완전히 실행됨을 보장합니다.

### CAS 알고리즘에 대해 말씀해주세요

CAS(Compare-And-Swap) 알고리즘은 멀티스레드 프로그래밍에서 변수의 값을 비교한 후, 예상한 값과 일치할 경우에만 새로운 값으로 업데이트하는 저수준 동기화 기법입니다. 이 방법은 락을 사용하지 않고도 동시성을 관리할 수 있게 해줍니다.

### Reentrant Lock이란 무엇인가요?

`ReentrantLock`은 `synchronized` 블록 또는 메소드와 유사한 기능을 제공하지만, 더 유연한 방식으로 락을 관리할 수 있게 해주는 동기화 메커니즘입니다. 이 락은 재진입이 가능하며, 한 스레드가 이미 보유한 락을 다시 획득할 수 있습니다.

### Fast-fail과 Fail-safe에 대해 설명해주세요

- **Fast-fail:** 컬렉션을 순회하는 도중 구조적인 변경이 발생하면 `ConcurrentModificationException`을 발생시키는 방식입니다. 이는 오류를 빠르게 발견하게 해줍니다.
- **Fail-safe:** 컬렉션을 순회하는 도중에도 원본 컬렉션이 변경되어도 `ConcurrentModificationException`을 발생시키지 않는 방식입니다. 이는 주로 컬렉션의 복사본을 순회하면서 발생합니다.