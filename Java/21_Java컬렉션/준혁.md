- Java 컬렉션
  - hashcode() & equals()
  - String
  - String vs StringBuffer vs StringBuilder
  - Immutable Object
    - `String a = ""` vs `String a = new String("")`
  - List
    - ArrayList vs LinkedList
  - Map
    - HashTable vs HashMap vs LinkedHashMap vs TreeMap vs ConcurrentHashMap

## 예상 질문
- 동등성과 동일성을 각각 설명해주세요
  - 동등성은 두 객체가 논리적으로 같음을 의미하고, 사람이 판단하는 기준이라고 할 수 있습니다.
  - 동일성은 두 객체가 같은 주소값을 참조함을 의미하고, 컴퓨터가 판단하는 기준이라고 할 수 있습니다.
- 두 객체가 동등하도록 만들려면 어떻게 해야 되나요?
  - hashCode()와 equals() 메소드를 오버라이딩 하면 됩니다.
- 왜 hashCode()와 equals() 메소드 모두 오버라이딩 해야 되나요?
  - hash값을 사용하는 collection framework를 사용할 때 문제가 될 수 있기 때문입니다.
  - hash 기반의 collection framework는 두 객체의 동등성을 비교하기 위해 두 가지 과정을 거칩니다. 
  - 첫 번째로 hashCode 메서드를 호출하여 같은지 판단하고, 두 번째로 equals 메서드를 호출하여 같은지 판단합니다.
- immutable object에 대해서 설명해주세요
  - 불변 객체라는 뜻으로, 한 번 생성이 되면 데이터를 변경할 수 없고, 참조만 가능한 객체를 말합니다.
- immutable object의 장단점에 대해서 말해주세요
  - thread-safe 하고, 신뢰도가 높다는 장점이 있고,
  - 만약 변경이 필요할 시, 새로운 객체를 생성하는 방식으로 접근해야한다는 단점이 있습니다.
- 문자열의 수정은 어떤 식으로 이루어지나요?
  - 문자열은 immutable instance 이므로, 새로운 문자열을 생성하는 식으로 이루어집니다.
- 문자열의 수정이 빈번한 상황에서는 어떻게 하는 것이 좋을까요?
  - StringBuffer나 StringBuilder 등의 클래스를 사용하는 것이 좋습니다.
- StringBuffer와 StringBuilder 클래스를 설명해주세요.
  - 두 클래스 모두 내부적으로 문자열을 저장할 수 있는 공간을 가지는 클래스입니다.
  - thread-safe하냐 하지 않느냐의 차이가 있습니다.
- LinkedList와 ArrayList를 비교해주세요
  - LinkedList는 node들이 서로 연결되어있는 방식으로 구현이 되어있고, ArrayList는 배열을 기반으로 구현되어있습니다.
  - ArrayList는 참조 속도가 빠른 반면, 추가/삭제가 느리고, LinkedList는 참조 속도가 느린 반면, 추가/삭제가 빠르다는 장점이 있습니다.
- ConcurrentHashMap은 왜 HashTable 보다 성능이 더 좋은가요?
  - 동기화가 적용된 위치가 다르기 때문입니다. 
  - HashTable은 데이터를 조작하는 메소드에 synchronized가 걸려있어서 메소드에 접근하는 쓰레드의 수를 하나로 제한하는 반면
  - ConcurrencHashMap은 bucket 단위로 synchronized가 걸려 있어서 쓰레드를 제한하는 범위가 HashTable에 비해 좁습니다. 따라서, 더 빠르게 동작할 수 있습니다.