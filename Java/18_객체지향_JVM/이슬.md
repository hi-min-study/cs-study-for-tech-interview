# 📍 키워드
- 객체지향
    - 4가지 특징
    - 5원칙 (SOLID)
    - 객체지향 vs 절차지향 vs 함수형 프로그래밍
- JVM 메모리 구조

<br>

# 📍 예상 질문
## 1️⃣ JPA
<details>
<summary>객체지향이란 무엇인가요?</summary>
<div markdown="1">

- 객체지향이란 프로그래밍 패러다임 중 하나로, 객체를 자율적인 존재로 바라보는 것입니다. 여기서 자율적인 객체란 상태와 행위를 함께 지니며 스스로의 행동에 의해서만 상태가 변경되는 객체입니다.
- 객체는 적절한 책임과 역할을 수행하며, 다른 객체와 협력하기 위해 메시지를 전송하고, 메시지를 수신한 객체는 메시지를 처리하는 데 적합한 메서드를 자율적으로 선택합니다.

</div>
</details>
<details>
<summary>객체지향의 4가지 기본 특징(캡슐화, 상속, 다형성, 추상화)에 대해 설명해주세요.</summary>
<div markdown="1">

- 객체지향의 특징에는 크게 4가지가 있습니다. 캡슐화, 상속, 다형성, 추상화 입니다.
- 캡슐화
    - 객체의 속성(data fields)과 행위(메서드, methods)를 하나로 묶는 것을 의미합니다.
    - 이를 통해 객체의 세부 구현 내용을 외부에서 직접 접근할 수 없도록 하여, 객체의 데이터를 보호하고, 객체 간의 상호작용을 메서드를 통해서만 수행하도록 합니다.
    - 캡슐화는 데이터의 안정성과 신뢰성을 높이며, 외부에서 불필요한 접근을 제한함으로써 코드의 안정성을 높입니다.
- 상속
    - 한 클래스(부모 클래스)의 속성과 메서드를 다른 클래스(자식 클래스)가 받아서 사용할 수 있게 하는 기능입니다.
    - 이를 통해 기존에 작성된 코드를 재사용하여 새로운 클래스를 쉽게 만들 수 있으며, 코드의 중복을 줄이고 유지보수성을 향상시킵니다.
    - 상속을 통해 클래스 간의 계층구조를 형성하며, 다형성을 구현하는 데에도 중요한 역할을 합니다.
- 다형성
    - 다형성은 같은 이름의 메서드나 속성이 여러 객체에 대해 다른 방식으로 작동할 수 있게 해주는 특징입니다.
    - 이는 메서드 오버로딩(같은 이름의 메서드를 매개변수의 유형이나 개수를 다르게 해 여러 개 정의하는 것)과 메서드 오버라이딩(상속받은 메서드의 기능을 자식 클래스에서 변경하는 것)을 통해 구현됩니다. 
    - 다형성은 소프트웨어의 유연성과 확장성을 높이며, 코드의 재사용성을 증가시킵니다.
- 추상화
    - 불필요한 세부 사항들은 제거하고 가장 본질적이고 공통적인 부분만을 추출하여 표현하는 것입니다. 
    - 프로그래밍적 관점에서는 객체의 공통의 속성과 메서드를 추출하여 일반화하는 것입니다.
    - 추상 클래스와 인터페이스를 사용하여 구체적인 구현을 감추고, 사용자에게는 필요한 정보만을 제공함으로써 복잡성을 관리할 수 있습니다.

</div>
</details>
<details>
<summary>다형성이란 무엇이며, 왜 중요한가요?</summary>
<div markdown="1">

- 다형성이란 서로 다른 유형의 객체가 동일한 메시지에 대해 서로 다른 방식의 메서드를 이용해 메시지를 처리하는 것을 의미합니다.
- 다형성은 같은 이름의 메서드가 다양한 방식으로 구현될 수 있음을 말하며, 메서드 오버로딩과 오버라이딩으로 나타납니다.
    - 메서드 오버로딩(Method Overloading)은 같은 이름의 메서드를 하나의 클래스 내에 여러 개 정의하는 것이지만, 매개변수의 유형이나 개수를 다르게 함으로써 각 메서드를 구별합니다. 이를 통해 같은 기능이지만 다른 입력을 받는 메서드들을 쉽게 관리할 수 있습니다.
    - 메서드 오버라이딩(Method Overriding)은 상속 관계에 있는 클래스에서 발생합니다. 자식 클래스가 부모 클래스로부터 상속받은 메서드를 재정의하여, 동일한 메서드 호출에 대해 자식 클래스에 특화된 동작을 구현할 수 있습니다.
- 다형성이 중요한 이유는 다음과 같습니다.
    -유연성 및 확장성: 다형성을 통해 코드를 더욱 유연하게 작성할 수 있습니다. 새로운 클래스를 추가하거나 기존 클래스를 수정할 때 기존 코드에 영향을 미치지 않거나 최소화하면서 기능을 확장할 수 있습니다.
    - 재사용성: 다형성은 코드의 재사용성을 증가시킵니다. 공통된 인터페이스를 사용하여 다양한 구현을 가진 객체들을 동일한 방식으로 처리할 수 있으므로, 새로운 클래스나 메서드를 추가하더라도 기존 시스템을 쉽게 확장할 수 있습니다.
    - 인터페이스 분리: 다형성을 활용하면, 구현을 추상화하여 인터페이스만을 노출시킵니다. 이는 사용자나 다른 개발자가 구현 세부 사항을 몰라도 해당 기능을 사용할 수 있게 해주며, 시스템의 모듈성을 증가시킵니다.

</div>
</details>
<details>
<summary>SOLID원칙에 대해 설명해주세요.</summary>
<div markdown="1">

- SOLID 원칙은 객체지향 프로그래밍 및 설계의 다섯 가지 기본 원칙을 말합니다. 프로그래머가 시간이 지나도 유지 보수와 확장이 쉬운 시스템을 만들고자 할 때 이 원칙들을 함께 적용할 수 있습니다.
1. SRP(Single Responsibility Principle, 단일책임원칙)
    - 한 클래스는 하나의 책임만 가져야 한다.
    > 로버트 마틴은 책임을 변경하려는 이유로 정의하고, 어떤 클래스나 모듈은 변경하려는 단 하나 이유만을 가져야 한다고 결론 짓는다. 예를 들어서 보고서를 편집하고 출력하는 모듈을 생각해 보자. 이 모듈은 두 가지 이유로 변경될 수 있다. 첫 번째로 보고서의 내용 때문에 변경될 수 있다. 두 번째로 보고서의 형식 때문에 변경될 수 있다. 이 두 가지 변경은 하나는 실질적이고 다른 하나는 꾸미기 위한 매우 다른 원인에 기인한다. 단일 책임 원칙에 의하면 이 문제의 두 측면이 실제로 분리된 두 책임 때문이며, 따라서 분리된 클래스나 모듈로 나누어야 한다. 다른 시기에 다른 이유로 변경되어야 하는 두 가지를 묶는 것은 나쁜 설계일 수 있다.
2. OCP(Open Closed Principle, 개방폐쇄원칙)
    - 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.
    > 소프트웨어 개발 작업에 이용된 많은 모듈 중에 하나에 수정을 가할 때 그 모듈을 이용하는 다른 모듈을 줄줄이 고쳐야 한다면, 이와 같은 프로그램은 수정하기가 어렵다. 개방-폐쇄 원칙은 시스템의 구조를 올바르게 재조직(리팩토링)하여 나중에 이와 같은 유형의 변경이 더 이상의 수정을 유발하지 않도록 하는 것이다. 개방-폐쇄 원칙이 잘 적용되면, 기능을 추가하거나 변경해야 할 때 이미 제대로 동작하고 있던 원래 코드를 변경하지 않아도, 기존의 코드에 새로운 코드를 추가함으로써 기능의 추가나 변경이 가능하다.
    > 추상화를 통한 개방-폐쇄 원칙: 객체 지향 프로그래밍 언어(JAVA, C++ 등)에서는 고정되기는 해도 제한되지는 않은, 가능한 동작의 묶음을 표현하는 추상화가 가능하다. 모듈은 추상화를 조작할 수 있다. 이런 모듈은 고정된 추상화에 의존하기 때문에 수정에 대해 닫혀 있을 수 있고, 반대로 추상화의 새 파생 클래스를 만드는 것을 통해 확장도 가능하다. 따라서 추상화는 개방-폐쇄 원칙의 핵심 요소이다.
3. LSP(Liskov Substitution Principle, 리스코프 치환 원칙)
    - 프로그램 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
    > 자료형 S가 자료형 T의 하위형이라면, 프로그램에서 자료형 T의 객체는 프로그램의 속성을 변경하지 않고 자료형 S의 객체로 교체할 수 있다.
4. ISP(Interface Segregation Principle, 인터페이스 분리 원칙)
    - 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
    - 역할을 여러 개로 나눈다면, 다형성으로 인해 유연한 설계가 가능합니다.
    > 인터페이스 분리 원칙은 큰 덩어리의 인터페이스들을 구체적이고 작은 단위들로 분리시킴으로써 클라이언트들이 꼭 필요한 메서드들만 이용할 수 있게 한다. 이와 같은 작은 단위들을 역할 인터페이스라고도 부른다. 인터페이스 분리 원칙을 통해 시스템의 내부 의존성을 약화시켜 리팩토링, 수정, 재배포를 쉽게 할 수 있다
5. DIP(Dependency Inversion Principle, 의존관게 역전 원칙)
    - 추상화에 의존해야지, 구체화에 의존하면 안된다.
    > 객체 지향 프로그래밍에서 의존관계 역전 원칙은 소프트웨어 모듈들을 분리하는 특정 형식을 지칭한다. 이 원칙을 따르면, 상위 계층(정책 결정)이 하위 계층(세부 사항)에 의존하는 전통적인 의존관계를 반전(역전)시킴으로써 상위 계층이 하위 계층의 구현으로부터 독립되게 할 수 있다. 이 원칙은 다음과 같은 내용을 담고 있다. 첫째, 상위 모듈은 하위 모듈에 의존해서는 안된다. 상위 모듈과 하위 모듈 모두 추상화에 의존해야 한다. 둘째, 추상화는 세부 사항에 의존해서는 안된다. 세부사항이 추상화에 의존해야 한다. 이 원칙은 '상위와 하위 객체 모두가 동일한 추상화에 의존해야 한다'는 객체 지향적 설계의 대원칙을 제공한다.

</div>
</details>
<details>
<summary>OCP(개방-폐쇄 원칙)을 어떻게 적용할 수 있나요?</summary>
<div markdown="1">

1. 추상화와 다형성 사용: 가장 일반적인 방법은 인터페이스나 추상 클래스를 사용하는 것입니다. 이를 통해 구체적인 구현 대신 추상화에 의존하게 만들어, 새로운 기능이 필요할 때 기존 코드를 변경하지 않고도 새로운 클래스를 추가하여 기능을 확장할 수 있습니다.
2. 전략 패턴(Strategy Pattern): 특정 기능을 인터페이스로 정의하고, 그 인터페이스를 구현하는 여러 전략(구체적인 동작) 클래스를 만듭니다. 실행 중에 이러한 전략을 선택하거나 변경함으로써, 기존 코드를 수정하지 않고도 동작을 확장할 수 있습니다.
3. 템플릿 메소드 패턴(Template Method Pattern): 이 패턴은 알고리즘의 구조를 메서드에 정의하고, 알고리즘의 일부 단계를 서브클래스에서 구현할 수 있도록 합니다. 이렇게 하면 알고리즘의 구조를 변경하지 않고도 특정 단계를 새롭게 정의하여 확장할 수 있습니다.
4. 데코레이터 패턴(Decorator Pattern): 이 패턴을 사용하면, 객체의 기능을 동적으로 확장할 수 있습니다. 새로운 기능을 추가하기 위해 기존 코드를 변경할 필요 없이, 기능을 추가하고자 하는 객체를 데코레이터 객체로 감싸서 확장합니다.
5. 팩토리 메소드 및 추상 팩토리 패턴: 객체 생성 로직을 클라이언트 코드로부터 분리하여, 시스템에 새로운 클래스를 추가하더라도 클라이언트 코드를 변경할 필요 없이 객체를 생성할 수 있도록 합니다.

</div>
</details>
<details>
<summary>SOLID 원칙 중 어떤 원칙이 가장 중요하다고 생각하시는지 알려주세요.</summary>
<div markdown="1">

- 단일 책임 원칙(SRP)을 적용하여 각 클래스가 하나의 기능만 수행하도록 설계하는 것이 시작 단계에서 매우 중요합니다. 이렇게 하면 나중에 코드를 변경하거나 확장할 때 다른 기능에 미치는 영향을 최소화할 수 있습니다. 또한, 개방-폐쇄 원칙(OCP)을 통해 기존 코드를 수정하지 않고도 새로운 기능을 추가할 수 있는 유연성을 확보할 수 있습니다.

</div>
</details>
<details>
<summary>객체지향 프로그래밍, 절차지향 프로그래밍, 함수형 프로그래밍의 차이점은 무엇인가요?</summary>
<div markdown="1">

객체지향 프로그래밍 (OOP)
특징: 데이터(속성)와 그 데이터를 처리하는 함수(메서드)를 결합하여 ‘객체’를 만드는 방식입니다. 클래스라는 틀을 만들어, 그 틀을 기반으로 객체를 생성합니다.
장점: 코드 재사용성이 높고, 유지보수가 용이하며, 실제 세계의 사물을 모델링하기에 적합합니다. 캡슐화, 상속, 다형성 같은 특성을 가집니다.
용도: 대규모 소프트웨어 개발, 복잡한 시스템 개발, 사용자 인터페이스가 중요한 어플리케이션 등에 적합합니다.
절차지향 프로그래밍
특징: 프로그램을 일련의 절차나 루틴의 집합으로 보고, 순차적인 처리를 중시하는 방법입니다. 주로 함수를 중심으로 코드가 구성됩니다.
장점: 간단하고 이해하기 쉬우며, 컴퓨터의 처리 구조와 유사해 효율적인 경우가 많습니다.
용도: 비교적 간단한 어플리케이션, 하드웨어 낮은 수준의 프로그래밍, 데이터 처리 등에 적합합니다.
함수형 프로그래밍
특징: ‘함수’를 기본 단위로 사용하며, 불변성(Immutable), 순수 함수(Pure Function), 고차 함수(Higher-Order Function) 등의 개념을 중시합니다. 데이터의 변화보다는 데이터의 흐름과 변환에 초점을 맞춥니다.
장점: 부작용(Side-effect)을 최소화하고, 동시성(Concurrency) 처리와 테스트, 디버깅이 용이합니다.
용도: 병렬 처리, 대규모 시스템, 데이터 분석과 같은 분야에서 효과적입니다.

</div>
</details>
<details>
<summary>자바의 함수형 프로그래밍의 예시에 대해 설명해주세요.</summary>
<div markdown="1">

- 자바에서 함수형 프로그래밍의 가장 대표적인 예는 스트림 API(Stream API) 사용입니다. 스트림 API를 사용하면 컬렉션을 선언적으로 처리할 수 있으며, 데이터를 파이프라인 방식으로 처리할 수 있습니다. 이는 데이터의 변환, 필터링, 집계 등을 간결하게 표현할 수 있게 해줍니다.

</div>
</details>
<details>
<summary>JVM(Java Virtual Machine)은 무엇인가요?</summary>
<div markdown="1">

JVM(Java Virtual Machine)은 자바 가상 머신을 의미하며, 자바 애플리케이션을 실행하기 위한 가상 컴퓨터입니다. JVM은 자바 애플리케이션을 클래스 로더로 읽어들여 자바 API와 함께 실행하는 역할을 합니다. 자바로 작성된 프로그램은 모든 하드웨어나 운영 체제 상에서 동일하게 실행될 수 있도록 설계되었는데, 이는 JVM이 해당 시스템에 맞게 자바 바이트코드(.class 파일)를 해석하고 실행하기 때문입니다. 이러한 특성 덕분에 자바는 "한 번 작성하면 어디서나 실행된다(Write Once, Run Anywhere; WORA)"는 슬로건을 가지게 되었습니다.

</div>
</details>
<details>
<summary>JVM의 메모리 구조에 대해 설명해주세요.</summary>
<div markdown="1">

힙(Heap) 영역:
이 영역은 애플리케이션 전체에서 공유되는 데이터를 저장하는 곳으로, 주로 인스턴스(객체)와 배열이 저장됩니다.
힙은 가비지 컬렉션의 주 대상이 되는 공간이며, 더 이상 참조되지 않는 객체들을 자동으로 정리합니다.
힙 영역의 크기는 JVM이 시작될 때 설정되며, 실행 중에 조정될 수도 있습니다.
스택(Stack) 영역:
각 스레드마다 하나씩 존재하는 영역으로, 스레드가 시작될 때 생성됩니다.
메소드 호출 시 마다 각 호출에 대한 프레임이 추가되며, 메소드가 종료될 때 해당 프레임이 제거됩니다.
지역 변수, 매개 변수, 리턴 값 등을 저장합니다.
스택 영역은 LIFO(Last In First Out) 방식으로 데이터를 관리합니다.
메소드(Method) 영역:
클래스 로더에 의해 로드된 클래스와 인터페이스의 메타 데이터(클래스 이름, 부모 클래스 이름, 메소드와 변수의 정보 등)를 저장합니다.
런타임 상수 풀도 이 영역에 위치하는데, 이는 컴파일 타임에 알려진 모든 리터럴과 심볼릭 레퍼런스를 포함합니다.
JVM당 하나의 메소드 영역이 존재하며, 모든 스레드에 의해 공유됩니다.
프로그램 카운터(PC) 레지스터:
현재 스레드가 실행 중인 JVM 명령의 주소를 가집니다.
각 스레드마다 하나씩 존재하며, 스레드가 어떤 부분을 실행하고 있는지 추적합니다.
네이티브 메소드 스택:
자바 외의 언어로 작성된 네이티브 코드를 실행하기 위한 공간입니다.
자바 네이티브 인터페이스(Java Native Interface, JNI)를 통해 호출된 네이티브 메소드의 정보를 저장합니다.

</div>
</details>
<details>
<summary>스택(Stack)과 힙(Heap) 메모리 영역의 차이점은 무엇인가요?</summary>
<div markdown="1">

1. 메모리 할당 및 관리 방식의 차이
스택은 메소드 호출과 함께 로컬 변수들이 순차적으로 쌓이고, 메소드가 종료되면 할당된 메모리가 자동으로 해제되는 LIFO(Last In First Out) 방식으로 관리됩니다. 각 스레드마다 별도의 스택 영역을 가지며, 스택 프레임에는 지역 변수, 매개 변수 등이 저장됩니다.
힙은 객체와 배열과 같은 동적으로 할당되는 데이터를 저장하는 영역으로, 가비지 컬렉터에 의해 메모리 관리가 이루어집니다. 힙 영역에 저장된 데이터는 애플리케이션 전체 스레드에서 공유될 수 있습니다.
2. 용도 및 저장되는 데이터의 차이
스택은 각 스레드의 메소드 호출과 실행에 필요한 데이터를 저장합니다. 이에 따라 메소드 내부에서 선언된 지역 변수, 매개 변수, 리턴 값 등이 여기에 해당합니다.
힙은 애플리케이션 전역에서 사용되는 객체와 배열을 저장합니다. 예를 들어, new 키워드를 사용하여 생성된 인스턴스와 배열은 모두 힙 영역에 위치합니다.
3. 생명 주기의 차이
스택에 저장된 데이터는 해당 메소드의 호출이 종료되면 메모리에서 사라집니다. 따라서 스택 영역의 데이터 생명 주기는 매우 짧습니다.
힙에 할당된 객체의 생명 주기는 더 길며, 해당 객체를 참조하는 변수가 존재하는 한, 또는 가비지 컬렉터에 의해 회수되지 않는 한 메모리에 남아 있습니다.

</div>
</details>
<details>
<summary>String = "a", new String("a") 는 각각 어디에 생성되나요?</summary>
<div markdown="1">

1. String = "a":
이 구문은 리터럴 방식으로 문자열을 생성합니다. 자바에서 문자열 리터럴은 컴파일 시에 문자열 상수 풀(String Constant Pool)에 저장됩니다. 상수 풀은 힙 메모리 영역에 위치하지만, 특별 관리 영역으로서 동일한 리터럴 값은 여러 참조가 있더라도 하나의 객체로 관리됩니다. 따라서 "a"라는 문자열 리터럴은 상수 풀에 저장되며, 같은 문자열 리터럴에 대한 참조는 모두 같은 메모리 주소를 가리킵니다.

2. new String("a"):
이 구문은 new 키워드를 사용하여 새로운 문자열 객체를 생성합니다. 이 방식으로 생성된 문자열 객체는 힙 영역에 저장되며, 상수 풀과는 별개로 관리됩니다. new를 사용하여 문자열 객체를 생성하면, 매번 새로운 메모리 영역에 객체가 할당되므로, 동일한 내용의 문자열이라도 서로 다른 메모리 주소를 가지게 됩니다.

즉, String = "a"는 상수 풀에 저장되며, 같은 리터럴 값에 대해서는 JVM이 하나의 객체를 재사용하도록 합니다. 반면, new String("a")는 힙 영역에 위치하지만 상수 풀과는 별개의 영역에 새로운 객체를 생성하여, 동일한 문자열이라도 각각 다른 메모리 주소를 가집니다.

</div>
</details>

# 📍 Reference
- https://github.com/bombo-dev/CS-JAVA-Study/blob/main/Java/OOP.md
- https://ko.wikipedia.org/wiki/SOLID_(%EA%B0%9D%EC%B2%B4_%EC%A7%80%ED%96%A5_%EC%84%A4%EA%B3%84)