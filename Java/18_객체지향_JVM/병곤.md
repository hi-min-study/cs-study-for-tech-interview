### 객체지향
- 객체지향 4가지 특징에 대해 말해주세요
	- 캡슐화
		- 객체의 데이터와 메서드를 하나로 묶는 것
		- 실제 구현 내용을 숨기고 외부에서는 객체가 제공하는 메서드를 통해서만 객체와 상호작용 하는 것 
	- 상속
		- 한 클래스가 다른 클래스의 속성 및 메서드를 물려받아 사용할 수 있게 하는 특성입니다. 
		- 상속을 통해 기존 코드를 재사용하면서, 확장성 있는 프로그램을 개발할 수 있습니다
		- 공통된 코드를 상위 클래스에 정의함으로써 코드의 중복을 줄일 수 있습니다.
	- 다형성
		- 하나의 인터페이스나 메서드가 서로 다른 클래스에서 여러 가지 방식으로 실행될 수 있음을 의미합니다. 
		- 다형성은 주로 오버라이딩(overriding, 상위 클래스의 메서드를 하위 클래스에서 재정의)과 오버로딩(overloading, 같은 이름의 메서드를 매개변수의 타입이나 개수를 달리하여 여러 개 정의)을 통해 구현됩니다. 
		- 이를 통해 코드의 유연성을 높이고, 확장성과 유지보수성을 개선할 수 있습니다.
	- 추상화
		- 복잡한 실제 세계의 문제를 단순화하여 모델링하는 과정입니다. 추상화를 통해 필요한 부분만을 간추려 클래스를 정의함으로써, 프로그램의 복잡도를 관리할 수 있습니다. 
		- 추상 클래스(abstract class)와 인터페이스(interface)는 추상화를 구현하는 데 사용될 수 있는 객체지향 프로그래밍의 두 가지 주요 도구입니다.
- SOLID 5원칙에 대해서 설명해주세요
	- 1. **단일 책임 원칙(Single Responsibility Principle, SRP)**: 한 클래스는 하나의 책임만 가져야 합니다. 즉, 클래스가 변경되어야 하는 이유는 단 하나여야 합니다. 이 원칙은 클래스를 변경하는 이유를 최소화하여, 시스템의 복잡성을 관리하고 유지보수를 용이하게 합니다.
	    
	2. **개방-폐쇄 원칙(Open-Closed Principle, OCP)**: 소프트웨어 엔티티(클래스, 모듈, 함수 등)는 확장에 대해서는 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 합니다. 즉, 기존의 코드를 변경하지 않으면서도 시스템의 기능을 확장할 수 있어야 합니다. 이 원칙은 시스템을 더 유연하게 만들어 줍니다.
	    
	3. **리스코프 치환 원칙(Liskov Substitution Principle, LSP)**: 서브타입은 언제나 기반 타입으로 교체할 수 있어야 합니다. 즉, 기반 클래스의 인스턴스를 서브 클래스의 인스턴스로 대체하더라도 시스템의 동작에 문제가 없어야 합니다. 이 원칙은 상속 구조를 설계할 때 유의해야 할 중요한 지침을 제공합니다.
	    
	4. **인터페이스 분리 원칙(Interface Segregation Principle, ISP)**: 클라이언트는 자신이 사용하지 않는 메서드에 의존하면 안 됩니다. 즉, 한 클래스가 자신이 사용하지 않는 인터페이스를 구현하도록 강요되어서는 안 됩니다. 이 원칙은 인터페이스를 작고, 목적에 맞게 분리하여, 시스템의 유연성을 높입니다.
	    
	5. **의존성 역전 원칙(Dependency Inversion Principle, DIP)**: 고수준 모듈은 저수준 모듈에 의존해서는 안 되며, 둘 다 추상화에 의존해야 합니다. 추상화는 세부 사항에 의존해서는 안 되고, 세부 사항은 추상화에 의존해야 합니다. 이 원칙은 의존성의 방향을 역전시켜, 모듈 간의 결합도를 낮추고, 시스템의 유연성을 향상시킵니다.
- 프로젝트에서 SOLID 중 적용한게 있다면 한가지 말씀해주세요
	- DIP
		- 스프링의 IoC 컨테이너는 애플리케이션에서 사용되는 객체(빈)의 생명주기와 의존성을 관리합니다. 개발자는 스프링이 제공하는 어노테이션(예: `@Autowired`, `@Bean`, `@Component` 등)을 사용하여 필요한 객체를 명시함으로써, 스프링 컨테이너로 하여금 해당 객체들을 자동으로 생성하고, 관리하도록 할 수 있습니다
		-  이러한 과정을 통해, 객체 간의 의존성이 컨테이너에 의해 자동으로 주입되며, 이는 코드의 유연성과 재사용성을 높여주고, 결합도를 낮춰줍니다..
- 객체지향, 절차지향, 함수형 프로그래밍에 대해 비교해서 말씀해주세요 
	- 객체지향
		- 객체지향 프로그래밍은 데이터와 그 데이터를 처리하는 메서드들을 객체로 캡슐화하여 프로그래밍하는 방식입니다.
		- 코드 재사용성이 높고 유지 보수하기 편하지만 너무 많은 추상화는 성능 저하에 원인이 될 수 있습니다.
	- 절차지향
		-  절차지향 프로그래밍은 프로그램을 일련의 절차나 함수의 순서로 구성하는 방식입니다. 데이터와 함수가 분리되어 있으며, 실행되어야 할 순서대로 코드가 작성됩니다.
		- 구현이 단순하고 이해하기 쉽지만 대규모 프로젝트에서는 오히려 복잡해지고 유지보수 하기 어렵습니다.
	- 함수형 프로그래밍
		- 함수형 프로그래밍은 순수 함수와 불변성에 중점을 둡니다. 프로그램의 상태를 변경하지 않고, 데이터 처리를 수학적 함수의 조합으로 표현합니다.
		- 사이드 이펙트가 없어서 버그 추적이 쉽고 병령 처리, 비동기 처리에 유리하지만 불병성을 위해 계속 변수를 복사하다 보면 메모리 사용량 증가로 성능 저하로 이어질 수 있습니다.
		- 또한 사이드 이펙트를 허용하지 않는 경우 외부 시스템과 상호작용하기 어려울 수 있습니다. 

### 자바
- JVM 메모리 구조는 어떤 것으로 이루어져 있나요?
	- 힙, 스택, 메소드 영역, PC 레지스터, 네이티브 메소드 스택으로 구분 됩니다.
- 힙에 대해서 설명해주세요
	- 힙 영역은 JVM이 관리하는 메모리 중 가장 큰 부분을 차지합니다. 
	- 이 영역은 모든 Java 객체와 배열이 동적으로 할당되는 곳입니다. 
	- 가비지 컬렉터(Garbage Collector)에 의해 관리되며, 더 이상 참조되지 않는 객체들을 정리합니다.
	- 힙은 더 세부적으로 여러 부분으로 나눌 수 있는데, 주로 Young Generation, Old Generation(또는 Tenured Generation), 그리고 옵션에 따라 Permanent Generation(Java 8 이전) 또는 Metaspace(Java 8 이후)로 구성됩니다.
- 스택에 대해서 설명해주세요
	- 스택 영역은 각 스레드별로 생성되며, 스레드의 메소드 호출과 로컬 변수들을 저장합니다.
	- 메소드가 호출될 때마다 프레임(Frame)이 생성되어 스택에 푸시되고, 메소드가 종료되면 해당 프레임은 스택에서 팝됩니다. 
	- 이 영역은 LIFO(Last In First Out) 구조를 가지며, 스레드가 종료되면 해당 스레드의 스택 영역도 사라집니다.
- 메소드 영역에 대해서 설명해주세요
	- 메소드 영역은 모든 스레드가 공유하는 메모리 영역으로, 클래스 정보, 상수, 정적 변수와 같은 메타데이터를 저장합니다. 
	- 또한, 런타임 상수 풀(Runtime Constant Pool)도 이 영역에 위치하며, 각 클래스와 인터페이스의 상수 및 메소드와 필드의 참조를 포함합니다. 
	- Java 8 이후로는 PermGen 대신 Metaspace가 이 역할을 대체하게 되었습니다.
- PC 레지스터에 대해서 설명해주세요
	- PC 레지스터는 현재 스레드가 실행 중인 JVM 명령의 주소를 가집니다. 
	- 각 스레드마다 PC 레지스터를 별도로 가지며, 스레드가 메소드를 실행할 때 해당 메소드의 바이트코드를 가리키는 역할을 합니다.

