# 📍 키워드
- 대용량 처리
- 메시지 큐
- CDN
- 클라우드
- Maven vs Gradle
- 프레임워크와 라이브러리 차이점
- POJO
- jar vs war

<br>

# 📍 예상 질문
<details>
<summary>대용량 데이터 처리 시 어떤 기술을 주로 활용하나요?</summary>
<div markdown="1">

1. 분산 시스템: 대용량 데이터 처리를 위해서는 하나의 컴퓨터로는 한계가 있기 때문에, 여러 대의 컴퓨터가 네트워크를 통해 데이터를 분산 처리하는 방식을 사용합니다. 예를 들어, Hadoop, Spark 같은 분산 처리 프레임워크가 있습니다.
2. 데이터베이스 샤딩: 샤딩은 대형 데이터베이스를 여러 서버에 분할하여 데이터를 수평 분할하는 기술입니다. 이를 통해 각 서버는 데이터의 일부만을 관리하게 되므로 처리 능력이 향상됩니다.
3. NoSQL 데이터베이스: 대용량의 비정형 데이터를 저장하고 처리하기 위해 NoSQL 데이터베이스가 사용됩니다. 예를 들어, MongoDB, Cassandra, HBase 등이 있으며, 이들은 빠른 읽기 및 쓰기 속도, 확장성, 유연한 데이터 모델 등의 장점을 가지고 있습니다.
4. 메모리 내 데이터 처리: Redis, Memcached 같은 메모리 내 캐싱 시스템을 사용하여 데이터 처리 속도를 향상시킬 수 있습니다. 이는 데이터를 디스크가 아닌 RAM에 저장하여 처리하기 때문에 빠른 데이터 액세스가 가능합니다.
5. 메세지 큐: Kafka, RabbitMQ 같은 메세지 큐를 사용하여 데이터 처리 작업을 비동기로 수행할 수 있습니다. 이를 통해 시스템 간의 결합도를 낮추고, 처리 능력을 향상시킬 수 있습니다.
6. 스트림 처리: 실시간 데이터 스트림을 처리하기 위해 Apache Kafka Streams, Apache Flink, Amazon Kinesis 같은 스트림 처리 플랫폼을 사용합니다. 이러한 기술을 통해 실시간으로 데이터를 분석하고, 대응할 수 있습니다.

</div>
</details>
<details>
<summary>대용량 트래픽 처리 시 어떤 기술을 주로 활용하나요?</summary>
<div markdown="1">

1. 로드 밸런싱 (Load Balancing): 트래픽이 여러 서버에 균등하게 분배되도록 합니다. 이를 통해 단일 서버에 부하가 집중되는 것을 방지하고, 시스템의 가용성과 성능을 향상시킵니다.
2. 캐싱 (Caching): 자주 요청되는 데이터나 결과를 미리 저장해 두고, 동일한 요청이 들어올 때 빠르게 응답합니다. 이를 통해 데이터베이스나 서버의 부하를 줄이고 응답 속도를 향상시킵니다.
3. CDN (Content Delivery Network): 전 세계에 분산된 서버 네트워크를 통해 사용자에게 콘텐츠를 빠르게 제공합니다. 사용자와 가장 가까운 서버에서 콘텐츠를 제공함으로써 로딩 시간을 단축하고 트래픽을 분산시킵니다.
4. 데이터베이스 분산 (Database Sharding): 대용량 데이터를 여러 데이터베이스에 분할하여 저장함으로써, 단일 데이터베이스에 대한 부하를 줄이고 쿼리 성능을 향상시킵니다.
5. 마이크로서비스 아키텍처 (Microservices Architecture): 어플리케이션을 작고 독립적인 서비스들로 나누어 개발하여, 각 서비스가 독립적으로 확장 및 관리될 수 있도록 합니다. 이를 통해 시스템 전체의 확장성과 유연성을 향상시킵니다.
6. 비동기 처리 (Asynchronous Processing): 요청 처리 중에 블로킹(대기)이 발생하지 않도록 비동기 방식을 사용합니다. 이는 시스템의 처리량을 높이고, 응답 시간을 개선하는데 도움이 됩니다.
7. 자동 확장 (Auto-Scaling): 트래픽 양에 따라 서버의 수를 자동으로 늘리거나 줄여 시스템의 부하를 조절합니다. 클라우드 환경에서 특히 유용한 기능입니다.

</div>
</details>
<details>
<summary>메시지 큐에 대해 설명해주세요.</summary>
<div markdown="1">

- 메시지 큐(Message Queue)는 메시지 기반 미들웨어(MBM)의 핵심 구성 요소로, 애플리케이션 간 메시지를 비동기적으로 전달하기 위해 사용되는 기술입니다. 메시지 큐는 메시지의 전송을 중개하며, 메시지를 보내는 측(sender)과 받는 측(receiver) 사이에서 메시지를 일시적으로 저장합니다. 이를 통해 두 시스템 간의 결합도를 낮추고, 효율적인 데이터 처리와 시스템의 확장성 및 안정성을 향상시킬 수 있습니다.
- 메시지 큐의 주요 특징
    - 비동기 통신: 메시지 큐를 사용하면 메시지를 보내는 측이 메시지를 큐에 전달한 후, 자신의 작업을 계속 진행할 수 있습니다. 메시지를 받는 측은 준비가 되었을 때 큐에서 메시지를 꺼내 처리할 수 있습니다.
    - 탈중앙화: 메시지 큐는 메시지를 중앙 집중식 서버가 아닌 분산된 방식으로 관리할 수 있게 해주며, 이를 통해 시스템의 확장성과 장애 내성을 향상시킵니다.
    - 유연성과 확장성: 메시지 큐를 사용하면 새로운 서비스나 컴포넌트를 시스템에 쉽게 추가하거나 제거할 수 있습니다. 또한, 시스템의 부하에 따라 자원을 동적으로 할당하거나 조정할 수 있습니다.
    - 신뢰성 있는 메시지 전송: 메시지 큐는 메시지의 전송이 실패했을 경우 재시도 기능을 제공하여 메시지가 안전하게 전달될 수 있도록 합니다.
- 메시지 큐의 사용 사례
    - 분산 시스템 간의 데이터 동기화
    - 마이크로서비스 아키텍처에서 서비스 간의 비동기 통신
    - 대규모 시스템에서의 로그 수집
    - 이메일 알림, SMS 전송 등의 배치 작업 처리
- 대표적인 메시지 큐 솔루션
    - RabbitMQ: AMQP(Advanced Message Queuing Protocol)를 기반으로 하는 오픈 소스 메시지 브로커
    - Apache Kafka: 고성능, 분산형 스트리밍 플랫폼으로 대량의 데이터 처리에 적합
    - Amazon SQS: AWS에서 제공하는 관리형 메시지 큐 서비스

</div>
</details>
<details>
<summary>메시지 큐를 사용하는 주된 이유는 무엇인가요?</summary>
<div markdown="1">

1. 비동기 통신(Asynchronous Communication): 메시지 큐를 통해 시스템 간에 메시지를 비동기적으로 전송할 수 있습니다. 이는 한 시스템이 다른 시스템의 처리 속도나 가용성에 영향을 받지 않도록 하여, 시스템 간의 결합도를 낮추고, 전체적인 응답성과 처리량을 향상시킵니다.
2. 부하 분산(Load Balancing): 메시지 큐는 작업을 여러 소비자(Consumer)에게 분산시켜 처리할 수 있도록 합니다. 이를 통해 시스템의 부하를 균등하게 분산시켜, 과부하 상황을 방지하고 전체 시스템의 성능을 최적화할 수 있습니다.
3. 탄력성 및 확장성(Elasticity and Scalability): 메시지 큐는 시스템의 탄력성과 확장성을 지원합니다. 처리해야 할 메시지의 양이 증가하면, 소비자의 수를 동적으로 조정하여 부하에 대응할 수 있습니다. 이는 클라우드 환경에서 특히 유용합니다.
4. 시스템 해체(Decoupling Systems): 메시지 큐는 시스템 간의 직접적인 연결 없이 메시지를 전달함으로써, 시스템 간의 결합도를 낮춥니다. 이는 각 시스템을 독립적으로 개발, 배포, 유지보수할 수 있게 하여 전체 시스템의 유연성을 향상시킵니다.
5. 신뢰성 있는 메시지 전달(Reliable Message Delivery): 메시지 큐는 메시지를 신뢰성 있게 전달하는 메커니즘을 제공합니다. 메시지가 성공적으로 처리될 때까지 큐에 보관되어, 시스템 장애 발생 시에도 메시지 손실을 방지할 수 있습니다.
6. 이벤트 주도 아키텍처(Event-Driven Architecture) 지원: 메시지 큐는 이벤트 주도 아키텍처의 구현을 용이하게 합니다. 이벤트가 발생하면 메시지 큐를 통해 해당 이벤트를 구독하는 시스템에 알릴 수 있으며, 이를 통해 시스템 간의 상호작용을 비동기적으로 처리할 수 있습니다.

</div>
</details>
<details>
<summary>Kafka와 RabbitMQ의 차이점에 대해 설명해주세요.</summary>
<div markdown="1">

- Apache Kafka와 RabbitMQ는 두 가지 인기 있는 메시지 브로커 시스템이지만, 설계 철학과 지원하는 기능 면에서 서로 다릅니다. 각각의 시스템이 제공하는 기능과 사용 사례를 기반으로 주요 차이점을 다음과 같이 설명할 수 있습니다:
- 설계 및 아키텍처
    - Kafka는 분산된 스트리밍 플랫폼으로 설계되었습니다. Kafka는 높은 처리량, 내구성, 확장성을 목표로 하며, 메시지를 파티션이라는 구조로 구성된 토픽에 저장합니다. Kafka는 시간에 따라 메시지를 순차적으로 저장하며, 메시지는 로그 형태로 디스크에 저장됩니다.
    - RabbitMQ는 경량 메시지 브로커 시스템으로, 복잡한 라우팅, 메시지 패턴(예: 요청/응답, 발행/구독)을 지원합니다. RabbitMQ는 AMQP(Advanced Message Queuing Protocol)을 기반으로 하며, 메시지를 큐에 저장하고 다양한 라우팅 옵션을 제공합니다.
- 사용 사례
    - Kafka는 대규모 메시지 처리, 로그 수집, 스트림 처리, 실시간 분석 등에 적합합니다. Kafka는 높은 처리량과 지연 시간이 낮은 애플리케이션에 주로 사용됩니다.
    - RabbitMQ는 다양한 메시지 패턴을 지원하며, 작업 큐, 분산 시스템 간의 비동기 메시지 전송, 내부 애플리케이션 간의 통신 등에 적합합니다. RabbitMQ는 복잡한 라우팅과 메시지 패턴을 필요로 하는 시스템에 주로 사용됩니다.
- 확장성 및 내구성
    - Kafka는 클러스터를 구성하여 확장할 수 있으며, 파티션과 리플리케이션을 통해 높은 내구성과 가용성을 제공합니다.
    - RabbitMQ도 클러스터링과 미러링 큐를 통해 확장성과 내구성을 제공하지만, Kafka에 비해 상대적으로 더 복잡한 라우팅 룰을 처리할 때 성능이 저하될 수 있습니다.
- 메시지 모델
    - Kafka는 메시지를 토픽에 저장하며, 소비자는 토픽에서 메시지를 순차적으로 읽습니다. Kafka는 장기간 메시지를 저장할 수 있으며, 메시지가 소비되어도 자동으로 삭제되지 않습니다.
    - RabbitMQ는 메시지를 큐에 저장하며, 메시지는 소비되거나 만료되면 큐에서 제거됩니다. RabbitMQ는 메시지를 다양한 방식으로 라우팅할 수 있으며, 더 복잡한 메시지 패턴을 지원합니다.
- Kafka는 높은 처리량과 대용량 데이터 스트리밍에 적합한 반면, RabbitMQ는 복잡한 라우팅과 메시지 패턴을 필요로 하는 시나리오에 더 적합합니다.

</div>
</details>
<details>
<summary>CDN에 대해 설명해주세요.</summary>
<div markdown="1">

- CDN(Content Delivery Network)은 전 세계 여러 지역에 분산된 서버 네트워크를 통해 웹 콘텐츠(HTML 페이지, 자바스크립트 파일, 스타일시트, 이미지, 비디오 등)를 사용자에게 빠르게 제공하는 시스템입니다. 사용자가 요청을 할 때, 가장 가까운 서버에서 콘텐츠를 제공함으로써 로딩 시간을 줄이고, 웹 사이트의 성능을 향상시킵니다.
- CDN의 주요 기능
    - 성능 향상: 사용자에게 가장 가까운 서버에서 콘텐츠를 제공함으로써 웹 사이트의 로딩시간을 단축시킵니다.
    - 가용성 및 안정성 증가: 콘텐츠를 전 세계 여러 서버에 분산시키므로, 하나의 서버에 문제가 발생해도 다른 서버에서 콘텐츠를 제공할 수 있습니다.
    - 보안 강화: DDoS 공격과 같은 보안 위협으로부터 웹 사이트를 보호하는 데 도움이 됩니다.
- CDN 작동 방식
    1. 사용자가 웹 사이트에 접속하여 콘텐츠를 요청합니다.
    2. DNS 시스템은 사용자의 요청을 처리할 수 있는 가장 가까운 CDN 서버를 찾아 요청을 전달합니다.
    3. 선택된 CDN 서버에서 요청받은 콘텐츠가 캐시되어 있다면 즉시 사용자에게 제공합니다. 만약 캐시되어 있지 않다면, 원본 서버에서 콘텐츠를 가져와 사용자에게 제공하고, 이를 캐시에 저장합니다.
- CDN 사용의 이점
    - 전 세계 어디서든 사용자에게 더 빠른 콘텐츠 로딩 시간을 제공합니다.
    - 원본 서버의 부하를 줄여주며, 트래픽 스파이크가 발생해도 웹 사이트의 안정성을 유지할 수 있습니다.
    - 보안 기능을 통해 웹 사이트를 더 안전하게 보호할 수 있습니다.

</div>
</details>
<details>
<summary>동적 컨텐츠와 정적 컨텐츠를 처리하는 CDN의 방식에는 어떤 차이가 있나요?</summary>
<div markdown="1">

- 정적 컨텐츠
    - 정적 컨텐츠는 변하지 않는 데이터로, HTML 파일, CSS 스타일시트, JavaScript 파일, 이미지 및 비디오 파일 등이 여기에 속합니다. 이러한 컨텐츠는 사용자의 요청이나 행동에 따라 변하지 않으므로, CDN은 이러한 정적 파일을 전 세계에 분산된 서버에 캐시(저장)하여 제공합니다. 사용자가 콘텐츠를 요청하면, CDN은 사용자에게 가장 가까운 서버에서 해당 콘텐츠를 즉시 제공하여 로딩 시간을 감소시킵니다. 정적 컨텐츠의 경우, 캐시된 데이터를 통해 높은 캐시 히트율(cache hit rate)을 달성할 수 있으며, 이는 웹사이트의 성능을 크게 향상시킵니다.
- 동적 컨텐츠
    - 동적 컨텐츠는 사용자의 요청이나 행동에 따라 실시간으로 변하는 데이터입니다. 예를 들어, 사용자별로 맞춤화된 웹 페이지, 실시간 데이터 처리가 필요한 웹 애플리케이션, API 호출 등이 여기에 속합니다. 동적 컨텐츠는 캐싱하기 어렵거나 캐싱할 수 없기 때문에, CDN은 다른 방식으로 이를 처리합니다.
    - CDN은 동적 컨텐츠를 위해 주로 두 가지 방법을 사용합니다:
        1. 엣지 서버를 통한 최적화된 라우팅: CDN은 사용자의 요청을 최적화된 경로를 통해 원본 서버로 라우팅하여 처리 시간을 단축시킵니다. 이 과정에서 네트워크 지연을 최소화하고, 사용자에게 더 빠른 응답 시간을 제공할 수 있습니다.
        2. 엣지 컴퓨팅 및 엣지 로직: 일부 CDN은 엣지 서버에서 간단한 데이터 처리나 사용자 맞춤화 로직을 실행할 수 있는 기능을 제공합니다. 이를 통해 서버와 사용자 간의 통신 부담을 줄이고, 전체적인 응답 속도를 개선할 수 있습니다.
    - 동적 컨텐츠를 처리하는 경우, 콘텐츠의 실시간 처리와 사용자 맞춤화가 중요하기 때문에, CDN의 엣지 서버는 원본 서버와의 효율적인 통신과 데이터 전송 최적화에 초점을 맞춥니다. 따라서, 정적 컨텐츠의 캐싱과는 다르게 동적 컨텐츠를 처리하는 데에는 네트워크 최적화와 데이터 처리 속도가 더 중요한 역할을 합니다.

</div>
</details>
<details>
<summary>Gradle이 Maven에 비해 가지는 장점은 무엇인가요?</summary>
<div markdown="1">

1. 성능
    - 증분 빌드: Gradle은 변경된 부분만 빌드하는 증분 빌드를 지원합니다. 이는 불필요한 작업을 수행하지 않아 빌드 시간을 크게 단축시킵니다.
    - 빌드 캐시: Gradle은 빌드 결과를 캐시하여 재사용합니다. 이는 로컬 및 CI 환경에서 빌드 시간을 줄이는 데 기여합니다.
2. 유연성 및 확장성
    - 동적 스크립팅 언어 지원: Gradle은 Groovy와 Kotlin DSL을 사용하여 빌드 스크립트를 작성합니다. 이는 XML 기반의 Maven보다 훨씬 더 유연하고 강력한 구성이 가능하게 합니다.
    - 맞춤형 빌드 로직: 사용자 정의 작업 및 플러그인을 쉽게 작성하여 빌드 프로세스를 맞춤화할 수 있습니다.
3. 다양한 언어 및 프레임워크 지원
    - Gradle은 Java 외에도 Kotlin, Groovy, Scala 등 다양한 JVM 언어를 지원합니다. 또한, C/C++, Python 등 다른 언어에 대한 지원도 확장하고 있습니다.
    - Android 공식 빌드 도구로 사용되며, Android 개발에 최적화된 다양한 기능을 제공합니다.
4. 멀티 프로젝트 빌드
    - Gradle은 멀티 프로젝트 빌드를 쉽게 처리할 수 있습니다. 이는 복잡한 프로젝트 구조를 가진 대규모 애플리케이션에서 효율적인 빌드 관리를 가능하게 합니다.
5. 풍부한 플러그인 생태계
     - Gradle은 다양한 빌드 및 배포 작업을 쉽게 확장할 수 있는 풍부한 플러그인 생태계를 가지고 있습니다. 이를 통해 개발자는 필요한 기능을 쉽게 추가할 수 있습니다.
6. 툴링 지원
    - Gradle은 강력한 CLI 도구를 제공하며, IntelliJ IDEA, Eclipse, Android Studio 등 주요 IDE와 통합됩니다. 이는 개발자가 빌드 및 디버깅 작업을 쉽게 수행할 수 있게 합니다.

</div>
</details>
<details>
<summary>프레임워크와 라이브러리의 주요 차이점은 무엇인가요?</summary>
<div markdown="1">

- 프레임워크
    - 통제의 역전(Inversion of Control, IoC): 프레임워크가 애플리케이션의 흐름을 제어합니다. 개발자는 프레임워크가 정의한 규칙과 인터페이스에 맞춰 코드를 작성합니다. 즉, 프레임워크가 애플리케이션의 전체적인 흐름을 책임지며, 개발자는 프레임워크가 제공하는 '틀' 안에서 필요한 부분을 구현합니다.
    - 포괄적인 솔루션 제공: 프레임워크는 특정 문제를 해결하기 위한 포괄적인 솔루션을 제공합니다. 이는 데이터베이스 연동, 네트워킹, 사용자 인터페이스 관리 등 애플리케이션 개발에 필요한 다양한 기능을 포함할 수 있습니다.
    - 사용의 복잡성: 프레임워크를 사용하면 초기 학습 곡선이 높을 수 있으며, 프레임워크의 구조 내에서 작업해야 하므로 특정 부분의 커스터마이징이 어려울 수 있습니다.
- 라이브러리
    - 통제의 유지: 라이브러리를 사용하는 애플리케이션은 실행 흐름을 직접 제어합니다. 개발자는 필요할 때 특정 기능을 수행하기 위해 라이브러리의 함수나 객체를 호출합니다. 즉, 라이브러리는 도구의 집합으로, 개발자가 필요에 따라 선택적으로 사용합니다.
    - 특정 기능 제공: 라이브러리는 특정 기능이나 작업을 수행하기 위한 함수나 클래스 등을 모아 둔 것입니다. 예를 들어, 문자열 처리, 이미지 조작, HTTP 요청 처리 등 특정 작업을 위한 라이브러리가 있습니다.
    - 사용의 유연성: 라이브러리는 애플리케이션의 특정 부분에서 필요에 따라 사용되므로, 프레임워크에 비해 사용이 더 유연합니다. 개발자는 애플리케이션의 다른 부분에 영향을 주지 않고 필요한 기능을 추가하거나 변경할 수 있습니다.
- 결론
    - 프레임워크는 애플리케이션의 전체적인 흐름과 구조를 제공하며, 개발자는 이 틀 안에서 필요한 부분을 구현합니다. 프레임워크는 애플리케이션의 '빌딩 블록'을 제공하는 것입니다.
    - 라이브러리는 개발자가 애플리케이션을 제어하면서 필요에 따라 사용하는 도구의 집합입니다. 라이브러리는 개발자가 '도구 상자'에서 필요한 도구를 선택하는 것입니다.

</div>
</details>
<details>
<summary>POJO의 정의와 그 중요성에 대해 설명해주세요.</summary>
<div markdown="1">

- POJO(Plain Old Java Object)는 "순수한 오래된 자바 객체"를 의미하며, 특정 자바 모델이나 프레임워크, 규약에 의존하지 않는 단순한 자바 객체를 지칭합니다. 이 용어는 2000년대 초반에 자바 커뮤니티에서 EJB(Enterprise JavaBeans)와 같은 복잡한 프레임워크에 대한 반작용으로 생겨났습니다.
- POJO의 정의
    - 특정 규약이나 인터페이스 구현을 요구하지 않습니다.
    - 특정 클래스를 상속받지 않습니다.
    - 특정 환경이나 프레임워크에 종속되지 않습니다.
    - 자바의 객체 지향적 특성을 최대한 활용하여 만들어진 객체입니다.
    - 간단히 말해, POJO는 자바에서 사용되는 일반적인 클래스로, 다른 클래스를 상속받거나 인터페이스를 구현하지 않고도 필요한 데이터와 그 데이터를 처리하는 메서드를 포함할 수 있습니다.
- POJO의 중요성
    - 단순성: POJO는 특별한 제약이나 규칙 없이 순수한 자바 문법만으로 작성되기 때문에, 이해하기 쉽고 유지 관리하기 쉽습니다.
    - 재사용성: 특정 기술이나 프레임워크에 의존하지 않기 때문에, POJO는 다양한 환경에서 재사용될 수 있습니다. 이는 소프트웨어 공학에서 중요한 원칙인 DRY(Don't Repeat Yourself)를 지키는 데 도움이 됩니다.
    - 테스트 용이성: POJO는 외부 종속성이 적기 때문에 단위 테스트를 작성하고 실행하기가 더 쉽습니다. 이는 테스트 주도 개발(TDD)과 같은 현대적인 소프트웨어 개발 방법론과 잘 어울립니다.
    - 프레임워크와의 결합도 감소: POJO를 사용함으로써 개발자는 특정 프레임워크에 강하게 결합된 코드를 작성하는 것을 피할 수 있습니다. 이는 애플리케이션의 유연성을 향상시키고, 필요에 따라 다른 기술로 쉽게 전환할 수 있게 합니다.

</div>
</details>
<details>
<summary>POJO를 사용함으로써 얻을 수 있는 이점은 무엇인가요?</summary>
<div markdown="1">

1. 단순성과 명확성
    - POJO는 복잡한 프레임워크나 라이브러리에 의존하지 않기 때문에, 코드가 단순하고 이해하기 쉽습니다. 이로 인해 개발자가 코드를 더 빠르게 이해하고 수정할 수 있으며, 코드의 가독성과 유지 보수성이 향상됩니다.
2. 재사용성
    - 특정 기술이나 프레임워크에 종속되지 않는 자바 객체이므로, 다양한 프로젝트나 모듈에서 재사용이 가능합니다. 이는 코드의 중복을 줄이고, 개발 시간과 비용을 절약할 수 있습니다.
3. 테스트 용이성
    - POJO는 외부 종속성이 적어 단위 테스트 작성이 용이합니다. 테스트 주도 개발(TDD)이나 자동화된 테스트 작성 시 POJO를 활용하면, 테스트 케이스를 간단하게 작성할 수 있으며, 테스트의 신뢰성을 높일 수 있습니다.
4. 유연성 및 확장성
    - 프레임워크나 라이브러리에 강하게 결합되지 않기 때문에, 기술 스택의 변화나 새로운 기술의 도입에 유연하게 대처할 수 있습니다. 또한, POJO를 기반으로 시스템을 설계하면, 시스템의 구성 요소를 쉽게 교체하거나 확장할 수 있습니다.
5. 프레임워크와의 결합도 감소
    - POJO는 특정 프레임워크의 API나 클래스를 상속받지 않기 때문에, 프레임워크에 대한 의존도가 낮습니다. 이는 프레임워크를 변경하거나 업그레이드할 때 발생할 수 있는 문제를 최소화하며, 애플리케이션의 이식성을 향상시킵니다.
6. 객체 지향 설계 원칙의 적용 용이성
    - POJO는 객체 지향 설계 원칙(SOLID 원칙 등)을 적용하기 쉬운 구조를 가지고 있습니다. 이는 소프트웨어의 설계 품질을 향상시키고, 유지 보수 및 확장성을 높이는 데 기여합니다.

</div>
</details>
<details>
<summary>jar 파일과 war 파일의 차이점은 무엇인가요?</summary>
<div markdown="1">

- JAR(Java ARchive) 파일과 WAR(Web application ARchive) 파일은 모두 Java 애플리케이션을 배포하기 위한 압축 파일 포맷입니다. 이들은 Java 클래스 파일, 라이브러리, 메타데이터 등을 패키징하는 방법을 제공하지만, 주로 사용되는 목적과 내용에서 차이가 있습니다.
- JAR 파일
    - 목적: JAR 파일은 주로 재사용 가능한 Java 라이브러리, 애플리케이션 또는 애플리케이션의 일부분을 패키징하기 위해 사용됩니다.
    - 내용: JAR 파일은 Java 클래스 파일(.class 파일), 관련된 리소스 파일(이미지, 텍스트 등), 실행 가능한 Java 애플리케이션을 위한 메타데이터(예: MANIFEST.MF)를 포함할 수 있습니다.
    - 사용: JAR 파일은 Java 개발 시에 라이브러리로서 사용되거나, 독립 실행 가능한 Java 애플리케이션의 형태로 배포될 수 있습니다.
- WAR 파일
    - 목적: WAR 파일은 웹 애플리케이션을 패키징하고 배포하기 위해 사용됩니다. 이 포맷은 웹 서버나 애플리케이션 서버에서 실행되도록 설계되었습니다.
    - 내용: WAR 파일은 JSP(JavaServer Pages), 서블릿 클래스, 자바스크립트 파일, HTML 파일, CSS 파일, 이미지, XML 구성 파일, Java 클래스 파일 및 라이브러리 JAR 파일 등 웹 애플리케이션을 구성하는 모든 파일을 포함합니다. 또한, 웹 애플리케이션의 구성 정보를 담고 있는 WEB-INF 폴더(예: web.xml)를 포함합니다.
    - 사용: WAR 파일은 주로 웹 애플리케이션을 웹 서버나 애플리케이션 서버에 배포할 때 사용됩니다.
- 차이점 요약
    - 목적과 사용: JAR 파일은 일반 Java 애플리케이션 또는 라이브러리를 위한 것이며, WAR 파일은 웹 애플리케이션을 위한 것입니다.
    - 내용: WAR 파일은 JAR 파일보다 특화된 웹 애플리케이션 관련 파일들과 구성 정보를 포함합니다.
    - 배포 환경: JAR 파일은 다양한 환경에서 사용될 수 있지만, WAR 파일은 웹 서버나 애플리케이션 서버에서 실행될 목적으로 사용됩니다.

</div>
</details>

<br>

# 📍 Reference
