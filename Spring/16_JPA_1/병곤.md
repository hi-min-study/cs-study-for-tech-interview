## JPA 질문

### Hibernate
- **Hibernate가 무엇인지 설명해주세요**
	- Hibernate는 Java를 위한 객체 관계 매핑(Object-Relational Mapping, ORM) 라이브러리 중 하나로, 데이터베이스 테이블과 Java 객체 사이의 매핑을 쉽게 해주는 프레임워크입니다.
	- ORM 기술을 사용함으로써, 개발자는 복잡한 SQL 쿼리 없이도 데이터베이스에 저장되어 있는 데이터를 객체 형태로 쉽게 조회, 삽입, 수정, 삭제 등의 작업을 할 수 있습니다.
	- 이는 객체 지향 프로그래밍과 관계형 데이터베이스의 패러다임 불일치 문제를 해결해줍니다.
- JPA와 Hibernate 관계에 대해 설명해주세요
	- **JPA는 인터페이스**: JPA는 데이터베이스 작업을 위한 ORM 표준 명세입니다. 이는 어떤 구현체를 사용하든지 간에 일관된 프로그래밍 모델을 제공합니다.
	- **Hibernate는 구현체**: Hibernate는 JPA 명세를 구현한 구체적인 ORM 프레임워크입니다. 이는 JPA의 표준을 따르며, 추가적인 기능을 제공합니다.
### 영속성
- 영속성 컨텍스트에 대해 설명해주세요
	- 영속성 컨텍스트란 **엔티티를 영구 저장하는 환경**
	- 애플리케이션과 데이터베이스 사이에서 객체를 보관하는 가상의 데이터베이스 같은 역할을 한다.
	- 엔티티 매니저를 통해 엔티티를 저장하거나 조회하면 엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관하고 관리한다. 
- **영속성 컨텍스트의 장점**
	- 1. **성능 최적화**: 1차 캐시와 지연 로딩 기능을 통해 불필요한 데이터베이스 접근을 줄이고, 애플리케이션의 성능을 향상시킵니다.
	2. **데이터 접근의 추상화와 간결성**: 엔티티 매니저를 통해 데이터 접근을 추상화함으로써, 개발자는 복잡한 데이터베이스 연산을 신경 쓸 필요 없이 엔티티 객체를 통해 데이터를 쉽게 관리할 수 있습니다.
	3. **애플리케이션의 안정성 보장**: 동일성 보장과 변경 감지 기능은 애플리케이션의 안정성을 높이며, 데이터의 일관성을 유지합니다.
	4. **트랜잭션 관리 용이성**: 쓰기 지연과 변경 감지를 통해 트랜잭션 관리가 용이해지며, 데이터베이스와의 동기화 시점을 효율적으로 관리할 수 있습니다.
- **영속성 컨텍스트에서 flush와 clear는 언제 일어나나요?**
	- 1. **트랜잭션이 커밋(commit)되는 시점**: 트랜잭션의 커밋 과정에서 자동으로 `flush`가 발생하여 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영합니다.
	2. **명시적인 `flush` 호출**: 개발자가 `EntityManager.flush()` 메소드를 호출하여 직접 `flush`를 수행할 수 있습니다.
	3. **JPQL 쿼리 실행 시**: JPQL(Query Language) 또는 Criteria 쿼리를 실행하기 전에 영속성 컨텍스트의 변경 내용이 데이터베이스와 동기화되어야 할 필요가 있을 때 `flush`가 발생할 수 있습니다.
### 엔티티
- **엔티티 라이프 사이클에 대해 설명해주세요**
	- NEW
		-  엔티티가 생성되었지만, 아직 영속성 컨텍스트(Persistence Context)에 관리되지 않는 상태입니다.
		- `new` 키워드를 사용하여 인스턴스를 생성한 상태이며, 이 상태의 엔티티는 데이터베이스에 저장되지 않습니다.
	- Managed
		-  엔티티가 영속성 컨텍스트에 포함되어 관리되는 상태입니다.
		- `EntityManager`의 `persist()`, `merge()`, `find()`, `createQuery()` 등의 메소드를 통해 이 상태가 됩니다.
		- 이 상태의 엔티티는 영속성 컨텍스트에 의해 자동으로 관리되며, 트랜잭션이 커밋되는 시점에 데이터베이스에 반영됩니다.
	- Detached
		-  엔티티가 영속성 컨텍스트로부터 분리된 상태입니다.
		- 이 상태의 엔티티는 더 이상 영속성 컨텍스트에 의해 관리되지 않으며, 엔티티의 변경 사항이 자동으로 반영되지 않습니다.
		- `EntityManager`의 `detach()`, `clear()`, `close()` 메소드를 통해 엔티티를 분리할 수 있습니다.
	- Removed
		-  엔티티가 영속성 컨텍스트로부터 제거되어, 실제로 데이터베이스에서도 삭제될 예정인 상태입니다.
		- `EntityManager`의 `remove()` 메소드를 호출하여 이 상태가 되며, 트랜잭션이 커밋되는 시점에 데이터베이스에서도 해당 엔티티가 삭제됩니다.
- 즉시로딩과 지연로딩에 대해 설명해주세요
	- 즉시로딩
		- 즉시 로딩은 연관된 엔티티나 컬렉션을 최초의 엔티티 조회 시점에 함께 로딩하는 방법입니다.
		- 예를 들어, `User` 엔티티와 `Order` 엔티티가 있고, `User`가 여러 `Order`를 가질 수 있다고 할 때, 즉시 로딩을 사용하면 `User` 엔티티를 조회하는 순간 관련된 `Order` 엔티티들도 모두 데이터베이스에서 함께 조회됩니다.
		- 즉시 로딩은 `@ManyToOne`과 `@OneToOne` 관계에 기본으로 설정되어 있으며, `@OneToMany`와 `@ManyToMany` 관계에서도 설정할 수 있습니다.
		- 사용법: `@ManyToOne(fetch = FetchType.EAGER)`, `@OneToMany(fetch = FetchType.EAGER)`
		- 장점: 연관된 엔티티들을 사용해야 할 때 추가적인 쿼리 없이 즉시 사용할 수 있습니다.
		- 단점: 필요하지 않은 엔티티들까지 불러와 성능 저하 및 불필요한 메모리 사용이 발생할 수 있습니다.
	- 지연로딩
		- - 지연 로딩은 연관된 엔티티나 컬렉션을 실제로 사용하는 시점에 로딩하는 방법입니다.
		- 위의 예에서 지연 로딩을 사용하면, `User` 엔티티를 조회할 때는 `Order` 엔티티를 로드하지 않다가, 실제로 `Order` 엔티티에 접근할 때 해당 데이터를 로드합니다.
		- 지연 로딩은 `@ManyToOne`, `@OneToOne`, `@OneToMany`, `@ManyToMany` 관계에서 설정할 수 있으며, `@OneToMany`와 `@ManyToMany` 관계의 기본 설정입니다.
		- 사용법: `@ManyToOne(fetch = FetchType.LAZY)`, `@OneToMany(fetch = FetchType.LAZY)`
		- 장점: 실제로 필요한 시점에만 데이터를 로드하기 때문에 초기 로딩 성능이 개선되고 불필요한 메모리 사용을 줄일 수 있습니다.
		- 단점: 연관된 엔티티를 사용할 때마다 추가적인 쿼리가 발생할 수 있으며, 영속성 컨텍스트가 종료된 이후에 지연 로딩을 시도하면 `LazyInitializationException`이 발생할 수 있습니다.