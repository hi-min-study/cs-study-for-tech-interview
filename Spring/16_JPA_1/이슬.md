# 📍 키워드
- JPA
  - https://yozm.wishket.com/magazine/detail/2160/
  - https://dbjh.tistory.com/77
  - Hibernate
    - https://dev-coco.tistory.com/74
  - 영속성 컨텍스트
    - https://velog.io/@neptunes032/JPA-%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EB%9E%80
    - https://ittrue.tistory.com/254
    - https://ultrakain.gitbooks.io/jpa/content/chapter3/chapter3.4.html
    - https://incheol-jung.gitbook.io/docs/q-and-a/spring/persistence-context
  - 엔티티 라이프사이클
  - 즉시/지연 로딩
    - https://velog.io/@ddangle/%EC%A6%89%EC%8B%9C-%EB%A1%9C%EB%94%A9%EA%B3%BC-%EC%A7%80%EC%97%B0-%EB%A1%9C%EB%94%A9-%EB%B9%84%EA%B5%90

### 추가적으로 찾아본 키워드
- save() vs merge()
- 변경 감지 동작 원리
- flush()
- 쓰기 지연 저장소
- Hibernate 쿼리문 순서
- 자동 키 전략이 AUTO_INCREMENT일 때 DB 즉시 insert

<br>

# 📍 예상 질문
<details>
<summary>JPA란 무엇이며, 왜 사용하는지 설명해주세요.</summary>
<div markdown="1">

- JPA는 자바 진영에서 ORM(Object-Relational Mapping)을 위한 공식적인 표준 스펙입니다. ORM이란 객체 지향 프로그래밍과 관계형 데이터베이스를 연결하는 기술로, 개발자가 객체 지향적으로 데이터를 관리할 수 있게 해주며, 실제 데이터베이스 테이블과의 매핑을 처리해줍니다. JPA는 이러한 ORM을 위한 인터페이스를 제공하며, 개발자가 구체적인 구현체 없이도 데이터베이스 작업을 위한 표준 코드를 작성할 수 있게 돕습니다.
- JPA를 사용하는 이유는 다음과 같습니다:
  1. 객체-관계 매핑: JPA를 사용하면 객체를 데이터베이스에 저장하고 검색할 때 객체와 테이블 간의 매핑을 자동으로 처리할 수 있습니다. 이를 통해 개발자는 복잡한 SQL 쿼리 작성 없이도 객체를 데이터베이스에 영구적으로 저장할 수 있습니다.
  2. 생산성 향상: JPA는 ORM(Object-Relational Mapping) 기술을 사용하여 개발자가 데이터베이스에 접근하는 방법을 추상화합니다. 이는 개발자가 데이터베이스와의 상호작용을 단순화하고, 개발 시간을 단축시키며, 코드의 유지보수성을 높이는 데 도움이 됩니다.
  3. 데이터베이스 독립성: JPA는 다양한 데이터베이스에 대한 호환성을 제공하므로, 애플리케이션을 여러 종류의 데이터베이스에 손쉽게 이식할 수 있습니다.
  4. 성능 최적화: JPA는 영속성 컨텍스트를 통해 객체의 상태를 관리하고, 캐싱과 지연 로딩 등의 기능을 제공하여 성능을 최적화할 수 있습니다.
- 따라서 JPA를 사용하면 개발자는 데이터베이스와의 상호작용을 단순화하고 생산성을 향상시킬 수 있으며, 유연성과 성능을 유지할 수 있습니다.

</div>
</details>
<details>
<summary>JPA를 사용하면 어떤 이점이 있나요?</summary>
<div markdown="1">

- 객체-관계 매핑(ORM) 지원: JPA는 객체와 관계형 데이터베이스 간의 매핑을 지원하여 개발자가 객체를 데이터베이스에 저장하고 검색할 때 복잡한 SQL 쿼리를 작성할 필요 없이 자동으로 매핑할 수 있습니다.
- 객체 지향 프로그래밍과의 높은 일치도: JPA는 객체 지향 프로그래밍 언어인 자바와 관계형 데이터베이스 간의 불일치를 해결합니다. 이는 객체와 테이블 간의 매핑을 통해 객체 지향 설계를 유지하고 데이터베이스를 효과적으로 사용할 수 있도록 돕습니다.
- 데이터베이스 독립성: JPA는 다양한 데이터베이스에 대한 호환성을 제공하므로, 애플리케이션을 여러 종류의 데이터베이스에 손쉽게 이식할 수 있습니다. 이는 개발자가 특정 데이터베이스에 종속되지 않고 다른 데이터베이스로 마이그레이션하는 데 용이합니다.
- CRUD 작업의 단순화: JPA는 객체를 데이터베이스에 저장, 업데이트, 검색 및 삭제하는 일반적인 작업을 간단하게 만듭니다. 이를 통해 개발자는 데이터베이스와의 상호작용을 추상화하여 생산성을 높일 수 있습니다.
- 영속성 컨텍스트: JPA는 영속성 컨텍스트를 통해 엔티티의 상태를 관리하고, 트랜잭션 범위 내에서 변경된 엔티티를 자동으로 감지하여 데이터베이스에 동기화합니다. 이는 성능을 향상시키고, 데이터베이스 액세스를 줄여줍니다.
- 캐싱과 지연 로딩을 통한 성능 최적화: JPA는 1차 캐시와 지연 로딩 기능을 통해 애플리케이션의 성능을 최적화할 수 있는 여러 방법을 제공합니다. 이는 네트워크 비용과 데이터베이스 부하를 줄이는 데 도움이 됩니다.
- 쿼리 언어(JPQL) 지원: JPA는 SQL과 유사한 JPQL(Java Persistence Query Language)을 제공합니다. JPQL은 타입-세이프하며, 데이터베이스 테이블이 아닌 엔티티 객체를 대상으로 쿼리를 작성할 수 있게 해줍니다. 이는 쿼리의 가독성과 유지보수성을 향상시킵니다.

</div>
</details>
<details>
<summary>Hibernate와 JPA의 관계에 대해 설명해주세요.</summary>
<div markdown="1">


- Hibernate는 JPA의 구현체 중 하나입니다. JPA는 Java Persistence API의 약자로서, 자바 언어를 위한 ORM(객체 관계 매핑) 표준 스펙입니다. 이 표준을 따르는 여러 ORM 프레임워크 중 하나가 Hibernate입니다.
- Hibernate는 JPA의 스펙을 구현한 하나의 구현체입니다. 즉, JPA가 제공하는 인터페이스와 애노테이션, 쿼리 언어 등의 표준 스펙을 실제로 동작하게 만드는 라이브러리 중 하나입니다. Hibernate는 JPA를 포함하여 더 많은 기능과 유연성을 제공하여, 개발자가 보다 쉽게 데이터베이스 작업을 할 수 있도록 돕습니다. Hibernate는 JPA 이전부터 존재했으며, JPA가 등장한 후에는 JPA의 구현체로서 자리 잡게 되었습니다.
- 결론적으로, Hibernate와 JPA는 '표준 스펙과 그 구현체'라는 관계에 있으며, 이를 통해 자바 애플리케이션에서 데이터를 보다 효율적으로 관리하고, 데이터베이스 작업을 보다 쉽게 수행할 수 있도록 돕습니다.

</div>
</details>
<details>
<summary>영속성 컨텍스트에 대해 설명해주세요.</summary>
<div markdown="1">

- 영속성 컨텍스트(Persistence Context)는 엔티티(Entity) 객체를 관리하는 환경을 의미하며, 엔티티의 상태를 추적하고 관리합니다. 영속성 컨텍스트는 엔티티 매니저(Entity Manager)를 통해 사용됩니다.

</div>
</details>
<details>
<summary>영속성 컨텍스트 이점(5가지)에는 어떤 것들이 있나요?</summary>
<div markdown="1">

1. 1차 캐시: 영속성 컨텍스트는 조회된 엔티티를 내부 캐시에 보관합니다. 이후 같은 트랜잭션 내에서 해당 엔티티를 다시 조회하면, 데이터베이스가 아닌 1차 캐시에서 바로 엔티티를 가져옵니다. 이로 인해 성능이 향상됩니다.
2. 동일성 보장: 같은 영속성 컨텍스트 안에서는, 같은 엔티티에 대한 동일성이 보장됩니다. 즉, 동일한 데이터베이스 레코드에 해당하는 엔티티 인스턴스는 항상 같습니다.
3. 트랜잭션 지원의 쓰기 지연: 영속성 컨텍스트는 엔티티의 변경사항을 즉시 데이터베이스에 반영하지 않고, 트랜잭션이 끝날 때까지 모아둡니다. 트랜잭션을 커밋할 때 모아둔 변경사항들을 한 번에 데이터베이스에 반영합니다.
4. 변경 감지(Dirty Checking): 영속성 컨텍스트는 엔티티의 상태를 관리하며, 트랜잭션이 끝날 때 엔티티의 초기 상태와 비교하여 변경된 사항이 있는지 확인합니다. 변경이 감지되면, 해당 변경사항을 데이터베이스에 자동으로 반영합니다.
5. 지연 로딩(Lazy Loading): 엔티티의 연관된 엔티티를 즉시 로딩하지 않고, 실제로 사용될 때 로딩하는 방식을 지원합니다. 이를 통해 불필요한 데이터베이스 접근을 줄일 수 있습니다.

</div>
</details>
<details>
<summary>영속성 컨텍스트에서 엔티티의 생명주기를 설명해주세요.</summary>
<div markdown="1">

- 비영속 (New/Transient):
  - 엔티티가 생성되었지만 아직 영속성 컨텍스트에 저장되지 않은 상태입니다.
  - 이 상태의 엔티티는 데이터베이스에 존재하지 않으며, 영속성 컨텍스트와는 전혀 관련이 없습니다.
- 영속 (Managed/Persistent):
  - 엔티티가 영속성 컨텍스트에 저장된 상태입니다. 이 상태가 되려면, 엔티티 매니저를 통해 엔티티를 저장해야 합니다 (예: persist, merge, find 등의 메소드 사용).
  - 엔티티는 영속성 컨텍스트 내에서 관리되며, 데이터베이스와의 동기화가 이루어집니다. 트랜잭션이 커밋되는 시점에 변경사항이 데이터베이스에 반영됩니다.
- 준영속 (Detached):
  - 엔티티가 영속성 컨텍스트에서 분리된 상태입니다. 영속 상태였던 엔티티가 어떤 이유로 영속성 컨텍스트의 관리를 받지 않게 됩니다 (예: detach, clear, close 메소드 사용).
  - 준영속 상태의 엔티티는 영속성 컨텍스트와의 연결이 끊어졌지만, 엔티티의 데이터는 여전히 존재합니다. 데이터베이스와의 동기화는 더 이상 자동으로 이루어지지 않습니다.
- 삭제 (Removed):
  - 엔티티가 영속성 컨텍스트로부터 삭제되어, 더 이상 데이터베이스에 존재하지 않는 상태입니다.
  - remove 메소드를 사용하여 엔티티를 삭제 상태로 만들 수 있습니다. 트랜잭션이 커밋되는 시점에, 삭제 상태로 표시된 엔티티는 데이터베이스에서도 삭제됩니다.


</div>
</details>
<details>
<summary>준영속 상태란 무엇이며, 어떻게 발생하나요?</summary>
<div markdown="1">

- 준영속 상태(detached)는 JPA에서 사용되는 엔티티의 생명주기 상태 중 하나입니다. 엔티티가 영속성 컨텍스트에서 분리되어 더 이상 영속성 컨텍스트의 관리를 받지 않는 상태를 말합니다. 이 상태의 엔티티는 변경 감지의 대상이 아니며, 영속성 컨텍스트의 도움으로 데이터베이스와 동기화되지 않습니다.
- 명시적 분리(detach)
  - 개발자가 EntityManager의 detach() 메소드를 사용하여 명시적으로 엔티티를 영속성 컨텍스트에서 분리할 때 발생합니다. 이 메소드는 특정 엔티티를 준영속 상태로 만들어, 더 이상 영속성 컨텍스트에 의한 관리를 받지 않게 합니다.
- 트랜잭션 커밋
  - 트랜잭션이 성공적으로 커밋되면, 트랜잭션 범위에 있는 영속성 컨텍스트가 종료됩니다. 이 과정에서 영속성 컨텍스트가 관리하던 엔티티들은 준영속 상태가 됩니다.
- EntityManager 종료
  - EntityManager를 종료(close)하면, 해당 EntityManager가 관리하던 모든 엔티티들은 준영속 상태가 됩니다. EntityManager가 종료되면, 그와 연결된 영속성 컨텍스트도 함께 종료되기 때문입니다.
- 영속성 컨텍스트 초기화
  - EntityManager의 clear() 메소드를 호출하여 영속성 컨텍스트를 초기화하면, 영속성 컨텍스트가 관리하던 모든 엔티티들이 준영속 상태가 됩니다. 이는 영속성 컨텍스트를 완전히 비우는 행위입니다.
- 준영속 상태의 엔티티를 다시 영속 상태로 만들고 싶다면, EntityManager의 merge() 메소드를 사용하여 해당 엔티티를 영속성 컨텍스트에 다시 관리하도록 할 수 있습니다. 이 과정에서 변경된 사항이 있다면 데이터베이스와 동기화됩니다.

</div>
</details>
<details>
<summary>영속성 컨텍스트에서 엔티티의 상태 변화를 어떻게 감지하나요?</summary>
<div markdown="1">

1. 트랜잭션 시작과 엔티티 조회
  - 트랜잭션이 시작되고, 엔티티를 조회하여 영속성 컨텍스트에 저장할 때, 해당 엔티티의 스냅샷(원본 상태)을 함께 저장합니다. 이 스냅샷은 엔티티의 속성 값들의 복사본으로, 엔티티의 초기 상태를 나타냅니다.
2. 엔티티 상태의 변경
  - 애플리케이션에서 엔티티의 상태를 변경하는 작업을 수행합니다. 이 때, 영속성 컨텍스트는 엔티티의 상태 변경을 자동으로 감지하지 않습니다. 상태 변경 감지는 트랜잭션 커밋 시점에서 수행됩니다.
3. 변경 감지 (Dirty Checking)
  - 트랜잭션 커밋 과정에서 영속성 컨텍스트는 각 영속 상태의 엔티티에 대해 변경 감지를 수행합니다. 이를 위해 엔티티의 현재 상태와 저장된 스냅샷을 비교합니다.
  - 만약 엔티티의 현재 상태와 스냅샷이 다르면, 즉 엔티티가 변경되었다면, JPA는 해당 엔티티를 "더티" 상태로 판단하고 업데이트 쿼리를 생성하여 데이터베이스에 반영합니다.
4.  데이터베이스와의 동기화
  - 변경된 엔티티에 대한 업데이트 쿼리가 생성되면, 이 쿼리들은 트랜잭션 커밋 시점에 데이터베이스로 전송되어 엔티티의 변경 사항을 데이터베이스에 반영합니다.
- 이러한 과정을 통해, JPA는 개발자가 엔티티의 상태 변화에 대해 직접 쿼리를 작성하거나 업데이트 메소드를 호출하지 않아도, 데이터베이스의 상태를 자동으로 최신 상태로 유지할 수 있도록 합니다. 이는 JPA를 사용하는 중요한 이점 중 하나로, 애플리케이션 개발의 생산성과 유지 보수성을 크게 향상시킵니다.

</div>
</details>
<details>
<summary>즉시 로딩과 지연 로딩의 차이는 무엇인가요?</summary>
<div markdown="1">

- 즉시 로딩(Eager Loading)과 지연 로딩(Lazy Loading)은 JPA나 Hibernate 같은 ORM(Object-Relational Mapping) 프레임워크에서 엔티티의 연관 관계를 어떻게 처리할지 결정하는 두 가지 전략입니다. 이 두 로딩 전략의 차이점을 이해하는 것은 애플리케이션의 성능과 메모리 사용에 큰 영향을 미칠 수 있습니다.
- 즉시 로딩(Eager Loading)
  - 즉시 로딩은 엔티티를 조회할 때 연관된 엔티티들을 즉시 함께 조회하는 전략입니다. 예를 들어, User 엔티티와 User가 가지고 있는 Order 엔티티 리스트가 있을 때, 즉시 로딩 전략을 사용하면 User 엔티티를 조회하는 순간 연관된 Order 엔티티들도 함께 데이터베이스에서 조회됩니다. 이는 복잡한 연관 관계를 가진 엔티티를 다룰 때 초기 조회 시간은 늘어날 수 있지만, 후에 연관된 엔티티에 접근할 때 추가적인 쿼리를 실행할 필요가 없어 성능상 이점을 가질 수 있습니다.
- 지연 로딩(Lazy Loading)
  - 반면, 지연 로딩은 엔티티를 조회할 때 연관된 엔티티들을 즉시 조회하지 않고, 실제로 그 연관 엔티티에 접근할 때까지 로딩을 지연시키는 전략입니다. 이는 초기 조회 시에는 필요한 데이터만 로딩하여 성능을 향상시키고, 메모리 사용을 최적화할 수 있습니다. 하지만 실제로 연관 엔티티에 접근할 때마다 추가적인 쿼리가 실행되어, 전체적인 성능에 영향을 줄 수 있습니다.
- 차이점 요약
  - 즉시 로딩(Eager Loading)
    - 연관된 엔티티들을 처음 엔티티를 로드할 때 함께 로드함.
    - 초기 조회 시 데이터베이스로부터 모든 관련 데이터를 한 번에 가져옴.
    - 추가적인 쿼리 없이 연관 엔티티에 바로 접근 가능.
    = 복잡한 모델에서 초기 로드 시간이 길어질 수 있음.
  - 지연 로딩(Lazy Loading)
    - 연관된 엔티티들을 실제로 접근하는 시점에 로드함.
    - 초기 조회 시 최소한의 데이터만 로드하여 성능과 메모리 사용 최적화.
    - 연관 엔티티에 접근할 때마다 추가적인 쿼리 실행 필요.
    - 사용자 경험에 따라 적절한 시점에 데이터를 로드하여 전체 성능 최적화 가능.

</div>
</details>
