## 내용 정리
### Hibernate

- JPA의 구현체로, JPA 인터페이스를 구현하며, 내부적으로 JDBC API를 사용

## 장점

### 생산성

- Hibernate는 SQL을 직접 사용하지 않고, 메서드 호출만으로 쿼리가 수행돼요. 즉, SQL 반복 작업을 하지 않음으로 생산성이 높아져요
- SQL을 몰라도 되는 건 아니에요. (내부 동작에 대해 알아야 하기 때문)

### 유지보수

- 테이블 컬럼이 변경되었을 때, 테이블과 관련된 DAO의 파라미터, 결과, SQL 등을 대신 수행해줘요.
- 이로 인해 유지보수 측면에서 높아져요

### 특정 벤더에 종속적이지 않음

- JPA는 추상화된 데이터 접근 계층을 제공하기 때문에 특정 벤더에 종속적이지 않아요.
- 설정 파일에서 JPA에게 어떤 DB를 사용하고 있는지를 알려주기만 하면 얼마든지 DB를 바꿀 수 있어요.

### 패러다임 불일치 해결

- 상속, 연관 관계, 객체 그래프 탐색, 비교 등 객체와 관계형 데이터베이스와의 패러다임 불일치를 해결할 수 있어요.

## 단점

### 성능

- 메서드 호출만으로 쿼리를 수행하는 것은 직접 SQL을 작성하는 것보다는 성능상 좋지 않아요

### 세밀함

- 메서드 호출만으로 DB 데이터를 조작하기에는 한계가 있어요. 이를 보완하기 위해 JPQL을 지원해요
- NativeQuery를 지원하여 SQL 자체 쿼리도 작성할 수 있어요

### 영속성 컨텍스트

- Server side와 Database 사이에 엔티티를 저장하는 논리적인 영역

### 특징

- 엔티티를 **식별자 값(@id로 테이블의 기본 키와 매핑한 값)으로 구분**영속 상태는 식별자 값이 반드시 있어야 한다.식별자 값이 없으면 예외 발생.

### 장점

- 1차 캐시
    - 1차 캐시에 찾는 데이터가 있으면 데이터베이스 조회 필요 x
- 동일성 보장
    - 1차캐시에 존재하는 엔티티는 언제나 늘 동일한 엔티티이다.
- 트랜잭션을 지원하는 쓰기 지연
    - 한 트랜잭션 안에서 DB에 보낼 쿼리문을 모았다가 한번에 보냄 → 네트워크 부하가 줄어듦.
- 변경 감지
    - 값 변경 후 update 쿼리문 날릴 코드가 필요 없음
- 지연 로딩
    - 연관된 엔티티를 조회하지 않아도 되는 상황에서는 조회하지 않기 때문에 성능상 이점

### commit

트랜잭션을 종료한다. 커밋을 수행하게 되면 내부적으로 `EntityManager` 의 `flush()` 메서드를 호출한 후 트랜잭션을 닫습니다.

### flush

영속성 컨텍스트의 변경 내용을 데이터베이스에 반영한다. 영속성 컨텍스트의 엔티티를 지우는게 아니라 변경 내용을 데이터베이스에 동기화하는 것이다.

### flush 시점

1. em.clush() 를 직접 호출한다.
2. 트랜잭션 커밋 시 플러시가 자동 호출된다.
3. JPQL 쿼리 실행 시 플러시가 자동 호출된다.

### Commit vs Flush

flush는 쿼리를 전송하는 역할이고 commit은 내부적으로 flush를 수행한 뒤 트랜잭션을 끝내는 역할입니다.**즉 flush로 전송된 쿼리는 rollback할 수 있지만 commit은 트랜잭션을 끝내므로 rollback 할 수 없습니다.**

### 엔티티 라이프사이클

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/f161c15f-c5f0-4683-9793-c7551a62792f/15667765-3416-406e-b10e-e8411c1cefa7/Untitled.png)

- 비영속(new/transient): 영속성 컨텍스트와 전혀 관계가 없는 상태
- 영속(managed): 영속성 컨텍스트에 저장된 상태
- 준영속(detached): 영속성 컨텍스트에 저장되었다가 분리된 상태
- 삭제(removed): 삭제된 상태

### 비영속

엔티티 객체를 생성했지만 아직 영속성 컨텍스트에 저장하지 않은 상태를 비영속(new/transient)라 한다.

```java
Member member = new Member();
```

### 영속

엔티티 매니저를 통해서 엔티티를 영속성 컨텍스트에 저장한 상태를 말하며 영속성 컨텍스트에 의해 관리된다는 뜻이다.

```java
em.persist(member);
```

### 준영속

영속성 컨텍스트가 관리하던 영속 상태의 엔티티 더이상 관리하지 않으면 준영속 상태가 된다. 특정 엔티티를 준영속 상태로 만드려면 `em.datach()`를 호출하면 된다.

```java
// 엔티티를 영속성 컨텍스트에서 분리해 준영속 상태로 만든다.
em.detach(member);
// 영속성 콘텍스트를 비워도 관리되던 엔티티는 준영속 상태가 된다.
em.claer();
// 영속성 콘텍스트를 종료해도 관리되던 엔티티는 준영속 상태가 된다.
em.close();
```

### 준영속 상태의 특징

- 1차 캐시, 쓰기 지연, 변경 감지, 지연 로딩을 포함한 영속성 컨텍스트가 제공하는 어떠한 기능도 동작하지 않는다.
- 식별자 값을 가지고 있다.

### 삭제

엔티티를 영속성 컨텍스트와 데이터베이스에서 삭제한다.

```java
em.remove(member);
```

### 즉시/지연로딩

### 즉시로딩

- 특정 엔티티를 조회할 때 연관된 모든 엔티티를 같이 로딩하는 것
- '즉시 로딩'은 항상 외부 조인(OUTER JOIN)을 사용한다. ( 외부 조인보다 내부 조인(INNER JOIN)이 성능 최적화에 더 유리하다. )

### 지연로딩

- 특정 엔티티를 조회할 때 연관된 엔티티를 같이 조회하는 것이 아닌, 연관된 엔티티의 정보가 필요할때 로딩하는 것

### 즉시로딩을 삼가는 이유

- 예상치 못한 N+1문제,sql발생 가능
    - 특히나 실무에서는 테이블의 연관관계가 3~4개가 되는 경우도 빈번하기 때문에, N+1문제가 일어나면 join연산에도 큰 비용이 소모된다
- 지연로딩은 연관된 엔티티를 조회하지 않아도 되는 상황에서는 조회하지 않기 때문에 성능상 이점

### JPQL vs Native Query

# **JPQL (Java Persistence Query Language)**

- JPQL은 도메인 모델과 일치하는 방식으로 엔티티를 쿼리하도록 설계되었다고 한다.
- JPQL은 데이터베이스에 직접적인 쿼리를 실행하지 않으며 Entity 테이블에 매핑하여 사용한다.
- Query, TypedQuery 두 가지 유형을 사용할 수 있다.

### **장점**

1. 객체 지향적인 쿼리로 DB 테이블 조인이 아닌 java에서 엔티티관계 및 상속 개념으로 봐야한다.
2. 반환 유형을 지정할 수 있다.
3. 특정 유형의 DB(MySQL, Oracle)에 연결된 것이 아니기에 데이터베이스 변경 시에도 유지, 보수 부분에서 유연하며 쿼리를 다시 작성할 필요가 없다.
4. 코드 실행 단계가 아닌 코드를 작성하는 시점에서 빠르게 오류를 발견할 수 있다.

### **단점**

1. 모든 SQL 기능을 지원하지 않아 쿼리 작성에 유연하지 않다
2. 여러 조인이나 복잡한 쿼리를 작성해야 할 때 어렵다.
3. 매핑하여 사용하는 만큼 DB에 직접적으로 쿼리를 실행하는 NativeQuery보다 속도적인 부분에서 차이가 있다.

---

# **Native Query**

- 데이터베이스에 직접적인 쿼리를 실행한다.

### **장점**

1. DB에 직접적으로 쿼리를 실행시켜 속도가 빠르다.
2. SQL 언어를 전체적으로 사용 가능하다.
3. 여러 조인이나 복잡한 쿼리를 작성할 때 직관적이며 이해하기 쉽다.

### **단점**

1. 특정 DB에대해 쿼리를 작성하기에 종속성이 높아질 수 있고 DB가 수정되면 쿼리를 다시 만들어야 한다.. (MySQL에서는 LIMIT / Oracle에서는 ROWNUM 등)
2. 결과를 Object 리스트로 반환 하기에 JPQL의 TypedQuery보다 안정성 부분에서 미흡하다.
3. 주의할 점으로 사용자에게 입력된 값을 매개변수로 바인딩하거나 따로 유효성 검사가 필요할 수 있다.

### ref

- Hibernate : https://livenow14.tistory.com/70
- 영속성 컨텍스트 : https://ultrakain.gitbooks.io/jpa/content/chapter3/chapter3.4.html
- Entity lifecycle : [https://velog.io/@neptunes032/JPA-영속성-컨텍스트란](https://velog.io/@neptunes032/JPA-%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EB%9E%80), https://gmlwjd9405.github.io/2019/08/08/jpa-entity-lifecycle.html
- jpql vs native query : https://rhdqors.tistory.com/51


## 질문 정리
### Hibernate가 무엇인지 설명해 주세요.

- JPA의 구현체로, JPA 인터페이스를 구현하며, 내부적으로 JDBC API를 사용합니다.

### Hibernate의 장단점은 무엇일까요?

## 장점

### 생산성

- Hibernate는 SQL을 직접 사용하지 않고, 메서드 호출만으로 쿼리가 수행돼요. 즉, SQL 반복 작업을 하지 않음으로 생산성이 높아져요
- SQL을 몰라도 되는 건 아니에요. (내부 동작에 대해 알아야 하기 때문)

### 유지보수

- 테이블 컬럼이 변경되었을 때, 테이블과 관련된 DAO의 파라미터, 결과, SQL 등을 대신 수행해줘요.
- 이로 인해 유지보수 측면에서 높아져요

### 특정 벤더에 종속적이지 않음

- JPA는 추상화된 데이터 접근 계층을 제공하기 때문에 특정 벤더에 종속적이지 않아요.
- 설정 파일에서 JPA에게 어떤 DB를 사용하고 있는지를 알려주기만 하면 얼마든지 DB를 바꿀 수 있어요.

### 패러다임 불일치 해결

- 상속, 연관 관계, 객체 그래프 탐색, 비교 등 객체와 관계형 데이터베이스와의 패러다임 불일치를 해결할 수 있어요.

## 단점

### 성능

- 메서드 호출만으로 쿼리를 수행하는 것은 직접 SQL을 작성하는 것보다는 성능상 좋지 않아요
- RM 내부적으로 SQL 로 변환하는 과정을 거치며, 조인이 많아질수록 성능은 기하 급수적 으로 감소합니다

### 세밀함

- 메서드 호출만으로 DB 데이터를 조작하기에는 한계가 있어요. 이를 보완하기 위해 JPQL을 지원해요
- NativeQuery를 지원하여 SQL 자체 쿼리도 작성할 수 있어요

### 영속성 컨텍스트에 대해서 설명해 주세요.

- Server side와 Database 사이에 엔티티를 저장하는 논리적인 영역

### 영속성 컨텍스트의 장점은 무엇이 있을까요?

- 1차 캐시
    - 1차 캐시에 찾는 데이터가 있으면 데이터베이스 조회 필요 x
- 동일성 보장
    - 1차캐시에 존재하는 엔티티는 언제나 늘 동일한 엔티티이다.
- 트랜잭션을 지원하는 쓰기 지연
    - 한 트랜잭션 안에서 DB에 보낼 쿼리문을 모았다가 한번에 보냄 → 네트워크 부하가 줄어듦.
- 변경 감지
    - 값 변경 후 update 쿼리문 날릴 코드가 필요 없음
- 지연 로딩
    - 연관된 엔티티를 조회하지 않아도 되는 상황에서는 조회하지 않기 때문에 성능상 이점

### jpa의 commit과 flush에 대해 설명해 주시고, 두개의 차이점을 설명해 주세요

### commit

트랜잭션을 종료한다. 커밋을 수행하게 되면 내부적으로 `EntityManager` 의 `flush()` 메서드를 호출한 후 트랜잭션을 닫습니다.

### flush

영속성 컨텍스트의 변경 내용을 데이터베이스에 반영한다. 영속성 컨텍스트의 엔티티를 지우는게 아니라 변경 내용을 데이터베이스에 동기화하는 것이다.

### Commit vs Flush

flush는 쿼리를 전송하는 역할이고 commit은 내부적으로 flush를 수행한 뒤 트랜잭션을 끝내는 역할입니다.**즉 flush로 전송된 쿼리는 rollback할 수 있지만 commit은 트랜잭션을 끝내므로 rollback 할 수 없습니다.**

### flush가 되는 시점은 언제인가요?

1. em.clush() 를 직접 호출한다.
2. 트랜잭션 커밋 시 플러시가 자동 호출된다.
3. JPQL 쿼리 실행 시 플러시가 자동 호출된다.

### 엔티티 라이프사이클에 대해 설명해 주세요.

### 비영속

엔티티 객체를 생성했지만 아직 영속성 컨텍스트에 저장하지 않은 상태를 비영속(new/transient)라 한다.

```java
Member member = new Member();
```

### 영속

엔티티 매니저를 통해서 엔티티를 영속성 컨텍스트에 저장한 상태를 말하며 영속성 컨텍스트에 의해 관리된다는 뜻이다.

```java
em.persist(member);
```

### 준영속

영속성 컨텍스트가 관리하던 영속 상태의 엔티티 더이상 관리하지 않으면 준영속 상태가 된다. 특정 엔티티를 준영속 상태로 만드려면 `em.datach()`를 호출하면 된다.

```java
// 엔티티를 영속성 컨텍스트에서 분리해 준영속 상태로 만든다.
em.detach(member);
// 영속성 콘텍스트를 비워도 관리되던 엔티티는 준영속 상태가 된다.
em.claer();
// 영속성 콘텍스트를 종료해도 관리되던 엔티티는 준영속 상태가 된다.
em.close();
```

### 준영속 상태의 특징

- 1차 캐시, 쓰기 지연, 변경 감지, 지연 로딩을 포함한 영속성 컨텍스트가 제공하는 어떠한 기능도 동작하지 않는다.
- 식별자 값을 가지고 있다.

### 삭제

엔티티를 영속성 컨텍스트와 데이터베이스에서 삭제한다.

```java
em.remove(member);
```

### 즉시/지연로딩에 대해 설명해 주세요.

### 즉시로딩

- 특정 엔티티를 조회할 때 연관된 모든 엔티티를 같이 로딩하는 것
- '즉시 로딩'은 항상 외부 조인(OUTER JOIN)을 사용한다. ( 외부 조인보다 내부 조인(INNER JOIN)이 성능 최적화에 더 유리하다. )

### 지연로딩

- 특정 엔티티를 조회할 때 연관된 엔티티를 같이 조회하는 것이 아닌, 연관된 엔티티의 정보가 필요할때 로딩하는 것

### 실무에서는 즉시로딩을 지양합니다. 이유가 무엇일까요?

- 예상치 못한 N+1문제,sql발생 가능
    - 특히나 실무에서는 테이블의 연관관계가 3~4개가 되는 경우도 빈번하기 때문에, N+1문제가 일어나면 join연산에도 큰 비용이 소모된다
- 지연로딩은 연관된 엔티티를 조회하지 않아도 되는 상황에서는 조회하지 않기 때문에 성능상 이점
