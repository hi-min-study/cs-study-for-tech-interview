## 내용 정리
### Spring vs Spring MVC vs Spring Boot

- **Spring**

  **`Java 기반의 웹 애플리케이션 개발을 위한 오픈소스 프레임워크`**

- **Spring MVC**

  **`웹 애플리케이션 개발에 있어 MVC 패턴을 적용할 수 있도록 Spring에서 제공하는 프레임워크`**

- **Spring Boot**

  **`Spring 설정들을 자동화하는 Spring 기반의 프레임워크`**

1. 스프링 프레임워크는 DI, IoC를 통하여 느슨하게 결합된 어플리케이션을 개발할 수 있도록 한다.
2. 다음과 같은 모듈을 기본적으로 제공하여 추상을 통해 반복적인 코드를 줄여준다.
    - Spring JDBC
    - Spring MVC
    - Spring AOP
    - Spring ORM
    - Spring JMS
    - Spring Test

### Spring vs Spring Boot

Spring은 IoC, DI, AOP등을 지원하여 애플리케이션을 더 유연하고 모듈화된 구조로 개발하고 관리할 수 있도록 돕습니다. 하지만, 스프링이 제공하는 많은 장점에도, 몇 가지 문제점을 가지고 있습니다.

스프링은 강력한 기능을 제공하기 위해 많은 설정과 구성이 필요합니다. 이는 초기 설정의 복잡성을 증가시킬 수 있고, 초보자에게는 어렵게 느껴질 수 있습니다. 개발자들이 애플리케이션 컨텍스트 설정, 빈 정의, 다양한 컴포넌트 구성 등을 위해 많은 설정 코드를 작성해야 합니다.

## Spring 단점

### 높은 초기 학습 난이도

스프링은 다른 프레임워크에 비해 학습이 필요한 부분이 많습니다. 다양한 개념과 기능을 이해하고 사용하기 위해 시간과 노력이 필요할 수 있습니다.

### 의존성 관리 문제

전통적인 스프링 프레임워크에서는 여러 의존성과 그들의 버전을 관리하는 것이 복잡할 수 있습니다. 스프링 레거시에서는 의존성 주입(Dependency Injection)을 구현하기 위해 XML 설정 파일에 많은 수의 빈(Bean)을 등록해야 합니다. 이는 코드의 가독성을 떨어뜨리고, 의존성 관리가 어려워질 수 있습니다

### 별도 WAS 서버 구성의 번거로움

스프링을 웹상에서 사용하기 위해서는 별도의 Web Application Server(WAS)를 설치하고, 설정해야 합니다. 또한, 애플리케이션을 서비스하기 위해서 별도의 서버에 수동으로 배포해야 하는 번거로움이 있습니다.

이와 같은 스프링의 문제점을 해결해 주기 위해 스프링의 프레임워크들이 개발되었습니다.

스프링 프레임워크 중 대표적인 Spring Boot에 대해 알아보겠습니다.

## Spring Boot 장점

### AutoConfiguration

개발자의 입장에서는 사용할 라이브러리의 의존성만 추가하게 되면 autoconfigure를 통해서 해당 라이브러리에 대한 구성*(필요한 빈 설정과 생성)*이 자동으로 이루어지기 때문에 Spring에서 처럼 수동으로 빈 등록 및 설정을 하지 않아도 된다는 장점이 있습니다.

### 내장 서버

스프링 부트는 내장된 서버(내장 Tomcat, Jetty, Undertow)를 제공하여 별도의 서버 설정 없이 애플리케이션을 실행할 수 있습니다. 배포를 위해 War 파일을 생성해서 Tomcat에 배포할 필요 없으며, JAR 파일에는 모든 의존성 라이브러리가 포함되어 있어 외부 서버 없이도 애플리케이션을 실행할 수 있습니다. 이는 애플리케이션의 배포와 관리를 간편하게 만들어 줍니다.

### 의존성 관리 간소화

스프링 부트는 여러 3rd party 라이브러리를 사용할 때, 발생하는 라이브러리 버전 충돌로 인한 문제를 해결하기 위해서, 이미 테스트된 여러 라이브러리들의 묶음 패키지를 제공합니다.

3rd party 의존성 관리를 용이하게 하기 위한 ‘starter’ 의존성 통합 모듈을 제공하여 Maven/Gradel 설정 시 버전 관리가 간편합니다. 스프링 부트에서 제공하는 의존성 세트를 통해 개발자는 버전 충돌이나 복잡한 의존성 설정에 대해 걱정하지 않고 필요한 의존성을 쉽게 지정할 수 있습니다.

### 운영 편의성

스프링 부트는 애플리케이션의 상태 모니터링, 로깅, 보안 설정 등 운영에 필요한 기능들을 제공합니다. 이를 통해 애플리케이션의 운영과 관리가 편리해지고 안정성이 향상됩니다.

스프링 부트는 스프링(Spring Legacy)의 장점은 그대로 계승하면서, 기존의 문제가 되는 부분을 보완하여 기업용 애플리케이션의 개발 생산성 및 서비스 운영, 성능을 모두 해결해 줄 수 있습니다.

### Spring Boot vs Spring MVC

`스프링 부트`가 Auto-Configuration 등의 기능으로 스프링 프레임워크의 사용을 돕는 모듈이라면, `스프링 MVC`는 웹 애플리케이션 개발의 방식을 제공하는 모듈이다.

즉, `스프링 MVC` 는 Dispatcher Servlet, ModelAndView 및 View Resolver와 같은 간단한 개념으로 웹 애플리케이션을 쉽게 개발할 수 있도록 돕는 프레임워크다.

또한 Spring MVC는 Spring과 마찬가지로 초기에 필요한 빈들을 수동 등록해 주어야 한다.

### MVC1 vs MVC2

## **MVC1**

!https://i.imgur.com/rzhzcZc.png

MVC1 패턴의 경우 View와 Controller를 모두 JSP가 담당하는 형태를 가집니다. 즉 JSP 하나로 유저의 요청을 받고 응답을 처리하므로 **구현 난이도는 쉽습니다.**

단순한 프로젝트에는 괜찮겠지만 내용이 복잡하고 거대해질수록 이 패턴은 힘을 잃습니다. **JSP 하나에서 MVC 가 모두 이루어지다보니 재사용성도 매우 떨어지고, 읽기도 힘들어집니다.** 즉 **유지보수에 있어서 문제가 발생합니다.**

## **MVC2**

!https://i.imgur.com/keastvz.png

MVC2 패턴은 널리 표준으로 사용되는 패턴입니다. **요청을 하나의 컨트롤러(Servlet)가 먼저 받습니다.** 즉 MVC1과는 다르게 **Controller, View가 분리되어 있습니다.** 따라서 역할이 분리되어 MVC1패턴에서의 단점을 보완할 수 있습니다. 그러므로 개발자는 M, V, C 중에서 수정해야 할 부분이 있다면, 그것만 꺼내어 수정하면 됩니다. 따라서 유지보수에 있어서도 큰 이점을 가집니다.

MV2는 MVC1 패턴보다 구조가 복잡해질 수 있지만, 개발자가 이러한 세부적인 구성까지 신경쓰지 않을 수 있도록 **각종 프레임워크들이 지금까지 잘 발전되어 왔습니다.** 그 중에서 대표적인 것이 바로 **스프링 프레임워크**입니다.

### Spring Boot 동작과정

스프링 부트 어플리케이션은 Bean을 두 단계에 걸쳐 등록한다.

1. @SpringBootApplication이 붙은 어플리케이션을 실행
2. @Component 어노테이션이 있는 클래스들을 스캔해서 Bean으로 등록 (Bean 등록 1단계)
3. @EnableAutoConfiguration에 의해 `spring.factories` 안에 들어있는 수많은 자동 설정이 조건에 따라 적용 (Bean 등록 2단계)
4. 많은 Bean들이 자동으로 생성되고 어플리케이션이 구동되게 된다.

@ComponentScan은 자기 자신부터 시작해서, 하위 패키지를 싹 훑어서 @Component라는 어노테이션을 붙인 클래스들을 찾아서 Bean으로 등록한다. 구체적인 검색 대상은 아래와 같다.

- @Configuration @Repository @Service @Controller @RestController

### DispatcherServlet

Spring MVC에서 프론트 컨트롤러로써 동작하는 서블릿.

### 프론트 컨트롤러

HTTP 요청을 받아서 적합한 컨트롤러에 위임하는 역할

기존에 프론트 컨트롤러 없이는 요청 경로마다 서블릿을 정의해주는 것은 핸들러마다 **공통된 로직을 중복 작성**한다는 비효율적인 측면이 있다. (공통된 로직이라 하면 한글인코딩처리 등등이 있다)

### IoC

**메소드나 객체의 호출작업을 개발자가 결정하는 것이 아니라, 외부에서 결정되는 것을 의미**한다.

`IoC`는 **제어의 역전이라고 말하며, 간단히 말해 "제어의 흐름을 바꾼다"**라고 한다.

객체의 **의존성을 역전시켜 객체 간의 결합도를 줄이고 유연한 코드를 작성**할 수 있게 하여 **가독성 및 코드 중복, 유지 보수를 편하게** 할 수 있게 한다.

기존에는 다음과 순서로 객체가 만들어지고 실행되었다.

1. 객체 생성
2. 의존성 객체 생성

   *클래스 내부에서 생성*

3. 의존성 객체 메소드 호출

하지만, 스프링에서는 다음과 같은 순서로 객체가 만들어지고 실행된다.

1. 객체 생성
2. 의존성 객체 주입

   *스스로가 만드는것이 아니라 제어권을 **스프링에게 위임하여 스프링이 만들어놓은 객체를 주입**한다.*

3. 의존성 객체 메소드 호출

**스프링이 모든 의존성 객체를 스프링이 실행될때 다 만들어주고 필요한곳에 주입**시켜줌으로써 **Bean들은 `싱글턴 패턴`의 특징**을 가지며,

**제어의 흐름을 사용자가 컨트롤 하는 것이 아니라 스프링에게 맡겨 작업을 처리**하게 된다.

### DI

객체를 직접 생성하는 게 아니라 외부에서 생성한 후 주입 시켜주는 방식이다.

DI(의존성 주입)를 통해서 모듈 간의 결합도가 낮아지고 유연성이 높아진다.

### 생성자 주입 vs setter주입 vs 필드주입

### 생성자 주입

생성자 주입은 생성자의 호출 시점에 1회 호출 되는 것이 보장된다. 그렇기 때문에 주입받은 객체가 변하지 않거나, 반드시 객체의 주입이 필요한 경우에 강제하기 위해 사용할 수 있다. 또한 Spring 프레임워크에서는 생성자 주입을 적극 지원하고 있기 때문에, 생성자가 1개만 있을 경우에 @Autowired를 생략해도 주입이 가능하도록 편의성을 제공하고 있다.

### Setter 주입

수정자 주입(Setter 주입, Setter Injection)은 필드 값을 변경하는 Setter를 통해서 의존 관계를 주입하는 방법이다. Setter 주입은 생성자 주입과 다르게 주입받는 객체가 변경될 가능성이 있는 경우에 사용한다. (실제로 변경이 필요한 경우는 극히 드물다.)

### 필드 주입

필드 주입(Field Injection)은 필드에 바로 의존 관계를 주입하는 방법이다.
필드 주입을 이용하면 코드가 간결해져서 과거에 상당히 많이 이용되었던 주입 방법이다. 하지만 필드 주입은 외부에서 접근이 불가능하다는 단점이 존재하는데, 테스트 코드의 중요성이 부각됨에 따라 필드의 객체를 수정할 수 없는 필드 주입은 거의 사용되지 않게 되었다. 또한 필드 주입은 반드시 DI 프레임워크가 존재해야 하므로 반드시 사용을 지양해야 한다. 그렇기에 애플리케이션의 실제 코드와 무관한 테스트 코드나 설정을 위해 불가피한 경우에만 이용하도록 하자.

### 메소드 주입

일반 메소드를 통해 의존 관계를 주입하는 방법이다. 수정자 주입과 동일하며 마찬가지로 거의 사용할 필요가 없는 주입 방법이다. 수정자 주입을 사용하면 한 번에 여러 필드를 주입 받을 수 있도록 메소드를 작성할수도 있다.

Setter, Field 주입 :객체의 생성 ㅡ> 의존관계 주입으로 라이프 사이클이 나누어져 있음

### 생성자 주입 권장하는 이유

최근에는 Spring을 포함한 DI 프레임워크의 대부분이 생성자 주입을 권장하고 있는데, 자세한 이유를 살펴보도록 하자.

1. 객체의 불변성 확보
2. 테스트 코드의 작성
3. final 키워드 작성 및 Lombok과의 결합
4. 스프링에 비침투적인 코드 작성
5. 순환 참조 에러 방지

### 1. 객체의 불변성 확보

- 실제로 개발을 하다 보면 의존 관계의 변경이 필요한 상황은 거의 없다. 하지만 수정자 주입이나 일반 메소드 주입을 이용하면 불필요하게 수정의 가능성을 열어두어 유지보수성을 떨어뜨린다. 그러므로 생성자 주입을 통해 변경의 가능성을 배제하고 불변성을 보장하는 것이 좋다.

### 2. 테스트코드의 작성

- 테스트가 특정 프레임워크에 의존하는 것은 침투적이므로 좋지 못하다. 그러므로 가능한 순수 자바로 테스트를 작성하는 것이 가장 좋은데, 생성자 주입이 아닌 다른 주입으로 작성된 코드는 순수한 자바 코드로 단위 테스트를 작성하는 것이 어렵다.

```java
@Service
public class UserService {

    @Autowired
    private UserRepository userRepository;
    @Autowired
    private MemberService memberService;

    public void register(String name) {
        userRepository.add(name);
    }

} 

```

예를 들어 위와 같은 코드에 대해 순수 자바 테스트 코드를 작성하면 다음과 같이 작성할 수 있다.

```java
public class UserServiceTest {

    @Test
    public void addTest() {
        UserService userService = new UserService();
        userService.register("MangKyu");
    }

}
```

- 위의 테스트 코드는 Spring 위에서 동작하지 않으므로 의존 관계 주입이 되지 않을 것이고, userRepository가 null이 되어 add 호출 시 NPE가 발생할 것이다. 이를 해결하기 위해 Setter를 사용하면 변경가능성을 열어두게 되는 단점을 갖게 된다.반대로 테스트 코드에서 @Autowired를 사용하기 위해 스프링을 사용하면 단위 테스트가 아닐 뿐만 아니라, 컴포넌트들을 등록하고 초기화하는 시간 때문에 테스트 비용이 증가하게 된다. 그렇다고 대안으로 리플렉션을 사용하면 깨지기 쉬운 테스트가 된다.반면에 생성자 주입을 사용하면 컴파일 시점에 객체를 주입받아 테스트 코드를 작성할 수 있으며, 주입하는 객체가 누락된 경우 컴파일 시점에 오류를 발견할 수 있다. 심지어 우리가 테스트를 위해 만든 Test객체를 생성자로 넣어 편리함을 얻을 수도 있다.

### 3. final 키워드 작성 및 Lombok과의 결합

생성자 주입을 사용하면 필드 객체에 final 키워드를 사용할 수 있으며, 컴파일 시점에 누락된 의존성을 확인할 수 있다. 반면에 다른 주입 방법들은 객체의 생성(생성자 호출) 이후에 호출되므로 final 키워드를 사용할 수 없다.또한 final 키워드를 붙이면 Lombok과 결합되어 코드를 간결하게 작성할 수 있다. Lombok에는 final 변수를 위한 생성자를 대신 생성해주는 @RequiredArgsConstructor를여기 에서 살펴보았다. Spring과 같은 DI 프레임워크는 Lombok과 환상적인 궁합을 보여주는데, 위에서 작성했던 생성자 주입 코드를 Lombok과 결합시키면 다음과 같이 간편하게 작성할 수 있다.

```java
@Service
@RequiredArgsConstructor
public class UserService {

    private final UserRepository userRepository;
    private final MemberService memberService;

    public void register(String name) {
        userRepository.add(name);
    }

}
```

이러한 코드가 가능한 이유는 앞서 설명하였듯 Spring에서는 생성자가 1개인 경우 @Autowired를 생략할 수 있도록 도와주고 있으며, 해당 생성자를 Lombok으로 구현하였기 때문이다.

### 4. 스프링에 비침투적인 코드 작성

필드 주입을 사용하려면 @Autowired를 이용해야 하는데, 이것은 스프링이 제공하는 어노테이션이다. 그러므로 @Autowired를 사용하면 다음과 같이 UserService에 스프링 의존성이 침투하게 된다.

```java
import org.springframework.beans.factory.annotation.Autowired;
// 스프링 의존성이 UserService에 import되어 코드로 박혀버림

@Service
public class UserService {

    @Autowired
    private UserRepository userRepository;
    @Autowired
    private MemberService memberService;

}
```

우리가 사용하는 프레임워크는 언제 바뀔지도 모를 뿐만 아니라, 사용자와 관련된 책임을 지는 UserService에 스프링 코드가 박혀버리는 것은 바람직하지 않다. 프레임워크는 비즈니스 로직을 작성하는 서비스 계층에서 알아야 할 대상이 아니다. 물론 이는 필요한 자바 파일을 임포트해야 하는 정적 언어인 자바의 한계이기도 하다. 그래도 가능하다면 스프링이 없이 코드가 작성되면 더욱 유연한 코드를 확보하게 된다. 프레임워크가 자주 바뀌는 것도 아니므로 비록 스프링 코드가 침투하는게 치명적인 문제는 아니긴하다. 하지만 그래도 더 좋은 방법(생성자 주입)이 있는데, 굳이 사용할 필요는 없다.

### 5. 순환 참조 에러 방지

생성자 주입을 사용하면 애플리케이션 구동 시점(객체의 생성 시점)에 순환 참조 에러를 예방할 수 있다.

### Bean vs Component

@Bean의 경우 개발자가 컨트롤이 불가능한 **외부 라이브러리들을 Bean으로 등록하고 싶은 경우**에 사용된다.

(예를 들면 ObjectMapper의 경우 ObjectMapper Class에 @Component를 선언할수는 없으니 ObjectMapper의 인스턴스를 생성하는 메소드를 만들고 해당 메소드에 @Bean을 선언하여 Bean으로 등록한다.)

반대로 개발자가 **직접 컨트롤이 가능한 Class들의 경우**엔 @Component를 사용한다.

또한 Bean은 target이 METHOD라 메소드단에, Component는 target이 TYPE이라 클래스단에 붙인다.

### @Service @Controller @Repository

공통점은 @Controller, @Service, @Repository은 @Component의 구체화된 형태로 해당 어노테이션이 사용된 곳은 **@Component와 마찬가지로 자동으로 스프링 빈으로 등록됩니다.** 따라서 @Controller 자리에 @Component를, @Service와 @Repository 자리에도 마찬가지로 @Component를 사용할 수 있습니다. 각 클래스의 역할을 명확하게 구분 지을 수 있어서 좋습니다.

**@Repository**

특정 예외를 잡아, 스프링의 unchecked 예외로 다시 던집니다. PersistenceExceptionTranslationPostProcessor를 구현하여야 합니다. 따라서 플랫폼 상세 예외를 잡으면, 스프링의 DataAccessException로 다시 던질 수 있습니다.

**@Service**

비지니스 로직이 있으며 저장소 계층을 사용합니다. 이외에 별다른 특징 사항은 없습니다. (Component와 완전히 동일한 기능을 갖고 있습니다.)

**@Controller**

Dispatcher는 @Controller가 있는 클래스들을 확인해서 @RequestMapping이 있는 메서드들을 확인합하여 요청을 처리합니다. 해당 어노테이션은 @Service, @Repository와는 구분되어 사용됩니다.

### Bean 생명주기

- 스프링 빈은 스프링 컨테이너 내부에서 생성되고, 스프링이 종료되기 전까지 생명주기(Life-Cycle)을 가지고 있다.
- 이때, 스프링은 객체 생성 → 의존관계 주입의 라이프사이클을 가진다.

### 생명주기

스프링 컨테이너 생성 → 스프링 빈 생성 → 의존관계 주입 → 초기화 콜백(EVENT) → 앱 본연의 동작 수행 → 소멸전 콜백(EVENT) → 스프링 종료

### 콜백 구현

1. 클래스가 InitializingBean과 DisposalBean을 상속받고 각각 afterPropertiesSet과 destroy 메서드를 구현하는 방식이다. 이때 초기화 콜백시 afterPropertiesSet이, 소멸전 콜백색 destroy가 호출된다.
2. @Bean 애노테이션에 내장된 설정방식으로 각각 initMethod 필드와 destroyMethod필드의 생성과 소멸시 적용될 메서드명을 정해주면 된다. → @Bean(initMethod="start", destroyMethod="end")
3. @PostConstruct, @Predestroy 가 일반적으로 가장많이 사용하는 방식이다.

### 스프링 빈 라이프 사이클을 압축시키기 위해 생성자 주입을 통해 빈 생성과 초기화를 동시에 진행하면 되지 않을까?

생성자는 파라미터를 받고, 메모리를 할당해서 객체를 생성하는 책임을 가진다.
반면에 초기화는 이렇게 생성된 값들을 활용해서 외부 커넥션을 연결하는 등 무거운 동작을 수행한다.

따라서 생성자 안에서 무거운 초기화 작업을 함께 하는 것보다는 객체를 생성하는 부분과 초기화 하는 부분을 명확하게 나누는 것이 메모리 관리 관점에서 좋다.
물론, 초기화 작업이 내부 값들만 약간 변경하는 정도로 단순한 경우에는 생성자에서 한번에 처리하는게 나을 수 있다.

### IoC Container

- IoC 컨테이너는 객체의 생성을 책임지고, 의존성을 관리한다.
- POJO의 생성, 초기화, 서비스, 소멸에 대한 권한을 가진다.
- 개발자들이 직접 POJO를 생성할 수 있지만 컨테이너에게 맡긴다.

### Beanfactory vs ApplicationContext

- Bean을 등록, 생성, 조회, 반환 관리하는 기능은 BeanFactory와 같다.
- 스프링의 각종 부가 기능을 추가로 제공한다.
- BeanFactory 보다 더 추가적으로 제공하는 기능
    - 국제화가 지원되는 텍스트 메시지를 관리 해준다.
    - 이미지같은 파일 자원을 로드할 수 있는 포괄적인 방법을 제공해준다.
    - 리스너로 등록된 빈에게 이벤트 발생을 알려준다.

### VO vs DTO vs DAO

### 1) DAO(Data Access Object)

DAO는 DB의 data에 접근하기 위한 객체로 직접 DB에 접근하여 데이터를 삽입, 삭제, 조회 등 조작할 수 있는 기능을 수행한다.

DataBase 접근을 하기 위한 로직과 비지니스 로직을 분리하기 위해 사용한다.

DAO의 경우는 DB와 연결할 Connection 까지 설정되어 있는 경우가 많다.

현재 많이 쓰이는 Mybatis 등을 사용할 경우 커넥션풀까지 제공되고 있기 때문에 DAO를 별도로 만드는 경우는 드물다.

### 2) DTO(Data Transfer Object)

DTO는 계층간(Controller, View, Business Layer) 데이터 교환을 위한 자바 빈즈(Java Beans)를 의미한다.

DTO는 로직을 가지지 않는 데이터 객체이고 getter메소드만 가진 클래스를 의미한다.

### 3) VO(Value Object)

VO는 값 그 자체를 나태는 객체이다.DTO와 반대로 로직을 포함할 수 있으며,

VO는 서로 다른 이름을 갖는 VO 인스턴스라도 모든 속성 값이 같다면 두 인스턴스는 같은 객체인 것이 핵심이다.예를 들어 모두 똑같은 자동차가 색깔만 다르다고 하더라도 이를 별개의 객체로 보는 것이 아니라 하나의 객체(자동차)로 보는것과 같다.

동등성을 비교하기 위해 equals & hashcode를 따로 구현한다.

### @Configuration

### 역할

- @Configuration또한 @Component이기 때문에 컴포넌트 스캔의 대상이 되고,
- 이후에 해당 클래스의 본문을 파싱 해서 @Bean이 붙어있는 메서드를 찾아서 빈을 생성해준다.
- Cglib을 통하여 Bean을 등록할 때 싱글톤(singleton)이 되도록 보장해준다.
- 스프링 컨테이너에서 Bean을 관리할 수 있게 됨.

### ref

- Spring vs Spring Boot : https://www.elancer.co.kr/blog/view?seq=158, https://programforlife.tistory.com/68
- MVC1 vs MVC2 : https://chanhuiseok.github.io/posts/spring-3/
- AutoConfiguration 동작과정 : https://zion830.tistory.com/112
- IoC, DI : https://velog.io/@gillog/Spring-DIDependency-Injection#iocinversion-of-control
- 생성자주입, setter주입, 필드주입 : https://velog.io/@gillog/Spring-DIDependency-Injection#iocinversion-of-control
- Component, Service, Repository : https://escapefromcoding.tistory.com/732
- Bean 생명주기 : https://dev-coco.tistory.com/170
- IoC Container : https://dev-coco.tistory.com/80

## 질문 정리
### Spring과 Spring Boot의 차이점은 무엇이 있나요?

### AutoConfiguration

개발자의 입장에서는 사용할 라이브러리의 의존성만 추가하게 되면 autoconfigure를 통해서 해당 라이브러리에 대한 구성*(필요한 빈 설정과 생성)*이 자동으로 이루어지기 때문에 Spring에서 처럼 수동으로 빈 등록 및 설정을 하지 않아도 된다는 장점이 있습니다.

### 내장 서버

스프링 부트는 내장된 서버(내장 Tomcat, Jetty, Undertow)를 제공하여 별도의 서버 설정 없이 애플리케이션을 실행할 수 있습니다. 배포를 위해 War 파일을 생성해서 Tomcat에 배포할 필요 없으며, JAR 파일에는 모든 의존성 라이브러리가 포함되어 있어 외부 서버 없이도 애플리케이션을 실행할 수 있습니다. 이는 애플리케이션의 배포와 관리를 간편하게 만들어 줍니다.

### 의존성 관리 간소화

스프링 부트는 여러 3rd party 라이브러리를 사용할 때, 발생하는 라이브러리 버전 충돌로 인한 문제를 해결하기 위해서, 이미 테스트된 여러 라이브러리들의 묶음 패키지를 제공합니다.

3rd party 의존성 관리를 용이하게 하기 위한 ‘starter’ 의존성 통합 모듈을 제공하여 Maven/Gradel 설정 시 버전 관리가 간편합니다. 스프링 부트에서 제공하는 의존성 세트를 통해 개발자는 버전 충돌이나 복잡한 의존성 설정에 대해 걱정하지 않고 필요한 의존성을 쉽게 지정할 수 있습니다.

### 운영 편의성

스프링 부트는 애플리케이션의 상태 모니터링, 로깅, 보안 설정 등 운영에 필요한 기능들을 제공합니다. 이를 통해 애플리케이션의 운영과 관리가 편리해지고 안정성이 향상됩니다.

스프링 부트는 스프링(Spring Legacy)의 장점은 그대로 계승하면서, 기존의 문제가 되는 부분을 보완하여 기업용 애플리케이션의 개발 생산성 및 서비스 운영, 성능을 모두 해결해 줄 수 있습니다.

### MVC1과 MVC2를 비교해주세요.

MVC1 패턴의 경우 View와 Controller를 모두 JSP가 담당하는 형태를 가집니다. 즉 JSP 하나로 유저의 요청을 받고 응답을 처리하므로 **구현 난이도는 쉽습니다.**

단순한 프로젝트에는 괜찮겠지만 내용이 복잡하고 거대해질수록 이 패턴은 힘을 잃습니다. **JSP 하나에서 MVC 가 모두 이루어지다보니 재사용성도 매우 떨어지고, 읽기도 힘들어집니다.** 즉 **유지보수에 있어서 문제가 발생합니다.**

MVC2 패턴은 널리 표준으로 사용되는 패턴입니다. **요청을 하나의 컨트롤러(Servlet)가 먼저 받습니다.** 즉 MVC1과는 다르게 **Controller, View가 분리되어 있습니다.** 따라서 역할이 분리되어 MVC1패턴에서의 단점을 보완할 수 있습니다. 그러므로 개발자는 M, V, C 중에서 수정해야 할 부분이 있다면, 그것만 꺼내어 수정하면 됩니다. 따라서 유지보수에 있어서도 큰 이점을 가집니다.

MV2는 MVC1 패턴보다 구조가 복잡해질 수 있지만, 개발자가 이러한 세부적인 구성까지 신경쓰지 않을 수 있도록 **각종 프레임워크들이 지금까지 잘 발전되어 왔습니다.** 그 중에서 대표적인 것이 바로 **스프링 프레임워크**입니다.

### @SpringBootApplication이 붙은 클래스의 main메소드를 실행하면 어떤 일이 일어나나요?

1. @SpringBootApplication이 붙은 어플리케이션을 실행
2. @Component 어노테이션이 있는 클래스들을 스캔해서 Bean으로 등록 (Bean 등록 1단계)
3. @EnableAutoConfiguration에 의해 `spring.factories` 안에 들어있는 수많은 자동 설정이 조건에 따라 적용 (Bean 등록 2단계)
4. 많은 Bean들이 자동으로 생성되고 어플리케이션이 구동되게 된다.

### DispatcherServlet이 무엇인가요?

Spring MVC에서 프론트 컨트롤러로써 동작하는 서블릿.

### 프론트 컨트롤러

HTTP 요청을 받아서 적합한 컨트롤러에 위임하는 역할

기존에 프론트 컨트롤러 없이는 요청 경로마다 서블릿을 정의해주는 것은 핸들러마다 **공통된 로직을 중복 작성**한다는 비효율적인 측면이 있다. (공통된 로직이라 하면 한글인코딩처리 등등이 있다)

### IoC가 무엇이고 왜 사용하나요?

`IoC`는 **제어의 역전이라고 말하며, 간단히 말해 "제어의 흐름을 바꾼다"**라고 한다.

**메소드나 객체의 호출작업을 개발자가 결정하는 것이 아니라, 외부에서 결정되는 것을 의미**한다.

객체의 **의존성을 역전시켜 구체클래스를 의존하지 않기 때문에 객체 간의 결합도를 줄이고 유연한 코드를 작성**할 수 있게 하여 **가독성 및 코드 중복, 유지 보수를 편하게** 할 수 있게 한다.

### DI가 무엇이고 왜 사용하나요?

객체를 직접 생성하는 게 아니라 외부에서 생성한 후 주입 시켜주는 방식이다.

DI(의존성 주입)를 통해서 모듈 간의 결합도가 낮아지고 유연성이 높아진다.

### DI의 방식 3가지에 대해 설명해 주시고 무엇이 제일 좋은지, 왜 좋은지 말씀해 주세요.

### 생성자 주입

생성자 주입은 생성자의 호출 시점에 1회 호출 되는 것이 보장된다. 그렇기 때문에 주입받은 객체가 변하지 않거나, 반드시 객체의 주입이 필요한 경우에 강제하기 위해 사용할 수 있다. 또한 Spring 프레임워크에서는 생성자 주입을 적극 지원하고 있기 때문에, 생성자가 1개만 있을 경우에 @Autowired를 생략해도 주입이 가능하도록 편의성을 제공하고 있다.

### Setter 주입

수정자 주입(Setter 주입, Setter Injection)은 필드 값을 변경하는 Setter를 통해서 의존 관계를 주입하는 방법이다. Setter 주입은 생성자 주입과 다르게 주입받는 객체가 변경될 가능성이 있는 경우에 사용한다. (실제로 변경이 필요한 경우는 극히 드물다.)

### 필드 주입

필드 주입(Field Injection)은 필드에 바로 의존 관계를 주입하는 방법이다.
필드 주입을 이용하면 코드가 간결해져서 과거에 상당히 많이 이용되었던 주입 방법이다. 하지만 필드 주입은 외부에서 접근이 불가능하다는 단점이 존재하는데, 테스트 코드의 중요성이 부각됨에 따라 필드의 객체를 수정할 수 없는 필드 주입은 거의 사용되지 않게 되었다. 또한 필드 주입은 반드시 DI 프레임워크가 존재해야 하므로 반드시 사용을 지양해야 한다. 그렇기에 애플리케이션의 실제 코드와 무관한 테스트 코드나 설정을 위해 불가피한 경우에만 이용하도록 하자.

### 생성자 주입 권장하는 이유

1. 객체의 불변성 확보
2. 테스트 코드의 작성
3. final 키워드 작성 및 Lombok과의 결합
4. 스프링에 비침투적인 코드 작성
5. 순환 참조 에러 방지

### @Bean과 @Component의 차이점에 대해서 설명해 주세요.

@Bean의 경우 개발자가 컨트롤이 불가능한 **외부 라이브러리들을 Bean으로 등록하고 싶은 경우**에 사용된다.

(예를 들면 ObjectMapper의 경우 ObjectMapper Class에 @Component를 선언할수는 없으니 ObjectMapper의 인스턴스를 생성하는 메소드를 만들고 해당 메소드에 @Bean을 선언하여 Bean으로 등록한다.)

반대로 개발자가 **직접 컨트롤이 가능한 Class들의 경우**엔 @Component를 사용한다.

또한 Bean은 target이 METHOD라 메소드단에, Component는 target이 TYPE이라 클래스단에 붙인다.

### @Service @Controller @Repository를 비교해 주세요.

공통점은 @Controller, @Service, @Repository은 @Component의 구체화된 형태로 해당 어노테이션이 사용된 곳은 **@Component와 마찬가지로 자동으로 스프링 빈으로 등록됩니다.** 따라서 @Controller 자리에 @Component를, @Service와 @Repository 자리에도 마찬가지로 @Component를 사용할 수 있습니다. 각 클래스의 역할을 명확하게 구분 지을 수 있어서 좋습니다.

**@Repository**

특정 예외를 잡아, 스프링의 unchecked 예외로 다시 던집니다. PersistenceExceptionTranslationPostProcessor를 구현하여야 합니다. 따라서 플랫폼 상세 예외를 잡으면, 스프링의 DataAccessException로 다시 던질 수 있습니다.

**@Service**

비지니스 로직이 있으며 저장소 계층을 사용합니다. 이외에 별다른 특징 사항은 없습니다. (Component와 완전히 동일한 기능을 갖고 있습니다.)

**@Controller**

Dispatcher는 @Controller가 있는 클래스들을 확인해서 @RequestMapping이 있는 메서드들을 확인합하여 요청을 처리합니다. 해당 어노테이션은 @Service, @Repository와는 구분되어 사용됩니다.

### Bean의 생명주기에 대해 설명해 주세요.

스프링 컨테이너 생성 → 스프링 빈 생성 → 의존관계 주입 → 초기화 콜백(EVENT) → 앱 본연의 동작 수행 → 소멸전 콜백(EVENT) → 스프링 종료

(꼬리질문)스프링 빈 라이프 사이클을 압축시키기 위해 생성자 주입을 통해 빈 생성과 초기화를 동시에 진행하면 되지 않을까요?

생성자는 파라미터를 받고, 메모리를 할당해서 객체를 생성하는 책임을 가진다.
반면에 초기화는 이렇게 생성된 값들을 활용해서 외부 커넥션을 연결하는 등 무거운 동작을 수행한다.

따라서 생성자 안에서 무거운 초기화 작업을 함께 하는 것보다는 객체를 생성하는 부분과 초기화 하는 부분을 명확하게 나누는 것이 메모리 관리 관점에서 좋다.
물론, 초기화 작업이 내부 값들만 약간 변경하는 정도로 단순한 경우에는 생성자에서 한번에 처리하는게 나을 수 있다.

### IoC Container에 대해서 설명해 주세요.

- IoC 컨테이너는 Bean객체의 생성을 책임지고, 의존성을 관리한다.
- POJO의 생성, 초기화, 서비스, 소멸에 대한 권한을 가진다.
- 개발자들이 직접 POJO를 생성할 수 있지만 컨테이너에게 맡긴다.

(꼬리질문) Beanfactory와 ApplicationContext를 비교해주세요.

- ApplicationContext의 Bean을 등록, 생성, 조회, 반환 관리하는 기능은 BeanFactory와 같다.
- 스프링의 각종 부가 기능을 추가로 제공한다.
- BeanFactory 보다 더 추가적으로 제공하는 기능
    - 국제화가 지원되는 텍스트 메시지를 관리 해준다.
    - 이미지같은 파일 자원을 로드할 수 있는 포괄적인 방법을 제공해준다.
    - 리스너로 등록된 빈에게 이벤트 발생을 알려준다.

### DAO, VO, DTO의 차이점에 대해 설명해 주세요.

### 1) DAO(Data Access Object)

DAO는 DB의 data에 접근하기 위한 객체로 직접 DB에 접근하여 데이터를 삽입, 삭제, 조회 등 조작할 수 있는 기능을 수행한다.

DataBase 접근을 하기 위한 로직과 비지니스 로직을 분리하기 위해 사용한다.

DAO의 경우는 DB와 연결할 Connection 까지 설정되어 있는 경우가 많다.

현재 많이 쓰이는 Mybatis 등을 사용할 경우 커넥션풀까지 제공되고 있기 때문에 DAO를 별도로 만드는 경우는 드물다.

### 2) DTO(Data Transfer Object)

DTO는 계층간(Controller, View, Business Layer) 데이터 교환을 위한 자바 빈즈(Java Beans)를 의미한다.

DTO는 로직을 가지지 않는 데이터 객체이고 getter메소드만 가진 클래스를 의미한다.

### 3) VO(Value Object)

VO는 값 그 자체를 나태는 객체이다.DTO와 반대로 로직을 포함할 수 있으며,

VO는 서로 다른 이름을 갖는 VO 인스턴스라도 모든 속성 값이 같다면 두 인스턴스는 같은 객체인 것이 핵심이다.예를 들어 모두 똑같은 자동차가 색깔만 다르다고 하더라도 이를 별개의 객체로 보는 것이 아니라 하나의 객체(자동차)로 보는것과 같다.

동등성을 비교하기 위해 equals & hashcode를 따로 구현한다.

### @Configuration의 역할에 대해 설명해 주세요.

- @Configuration또한 @Component이기 때문에 컴포넌트 스캔의 대상이 되고,
- 이후에 해당 클래스의 본문을 파싱 해서 @Bean이 붙어있는 메서드를 찾아서 빈을 생성해준다.
- Cglib을 통하여 Bean을 등록할 때 싱글톤(singleton)이 되도록 보장해준다.
- 스프링 컨테이너에서 Bean을 관리할 수 있게 됨.
