# 📍 키워드

- Spring 심화
    - AOP
        - Spring AOP 어노테이션
        - JDK Dynamic Proxy
        - CGLIB
    - @Transactional
    - interceptor
        - filter와 차이점
    - 직렬화, 역직렬화
    - Spring 전체 동작과정

<br>

# 📍 예상 질문
<details>
<summary>Spring AOP란 무엇인가요?</summary>
<div markdown="1">

Spring AOP(Aspect-Oriented Programming)은 관점 지향 프로그래밍의 한 형태로, 애플리케이션의 여러 부분에서 공통 관심사(Concern)를 분리하고 모듈화하는 기술입니다. 이는 횡단 관심사(Cross-cutting Concerns)를 효과적으로 다룰 수 있게 해주며, 코드의 재사용성과 유지보수성을 향상시킵니다.

AOP는 주로 메서드 호출, 예외 처리, 로깅, 보안, 트랜잭션 관리 등과 같은 관심사를 다룰 때 유용합니다. Spring AOP는 프록시를 사용하여 기능을 주입하고, 특정 메서드의 호출 전, 후 또는 예외 발생 시에 추가 동작을 수행할 수 있습니다.

</div>
</details>
<details>
<summary>AOP 동작 원리에 대해 설명해 주세요.</summary>
<div markdown="1">


AOP(Aspect-Oriented Programming)의 동작 원리는 핵심 로직과 횡단 관심사(Cross-cutting Concerns)를 분리하고, 이 두 가지를 모듈화하여 코드의 재사용성과 유지보수성을 향상시키는 데에 있습니다. Spring AOP는 프록시 기반의 AOP를 제공하며, 다음은 간단한 AOP의 동작 원리를 설명합니다.

Target Object (핵심 로직 객체): AOP가 적용되는 대상인 핵심 로직이 담긴 객체입니다.

Aspect (관점): 횡단 관심사를 정의한 모듈로서, 특정 시점에서 실행될 코드를 정의합니다. Aspect는 Advice(조언)와 Pointcut(어디에 적용할지 결정)으로 구성됩니다.

Advice (조언): 횡단 관심사에서 수행될 동작을 정의한 코드 블록입니다. Advice에는 다섯 가지 유형이 있습니다.

Before advice: 핵심 로직 실행 전에 실행됩니다.
After returning advice: 핵심 로직이 예외 없이 정상적으로 반환된 후에 실행됩니다.
After throwing advice: 핵심 로직이 예외를 던진 후에 실행됩니다.
After (finally) advice: 핵심 로직 실행 후 항상 실행됩니다.
Around advice: 핵심 로직을 감싸서 전/후에 실행됩니다.
Pointcut (적용 지점): 어떤 메서드에 어떤 Advice를 적용할지 결정하는 규칙이나 표현식입니다. Pointcut은 정규 표현식과 유사하게 동작하며, 특정 메서드나 패키지 등을 선택할 수 있습니다.

Proxy (프록시): AOP가 적용된 객체를 감싸는 래퍼입니다. 프록시는 핵심 로직이 실행되기 전에, 후에, 예외 발생 시에 Aspect의 Advice를 호출합니다. Spring AOP에서는 자바 프록시 또는 CGLIB(Code Generation Library)을 사용하여 프록시를 생성합니다.

AOP의 동작 원리를 통해, 핵심 로직과 횡단 관심사를 분리함으로써 코드의 모듈화를 촉진하고, 특정 기능을 중앙에서 효과적으로 관리할 수 있습니다.

</div>
</details>
<details>
<summary>JDK Dynamic Proxy와 CGLIB를 사용하는 경우의 차이점은 무엇인가요?</summary>
<div markdown="1">


JDK Dynamic Proxy와 CGLIB(Code Generation Library)은 둘 다 자바에서 동적으로 프록시 객체를 생성하는 데 사용되는 기술이지만, 사용되는 상황과 동작 방식에는 몇 가지 차이가 있습니다.

인터페이스 구현 여부:

JDK Dynamic Proxy: 인터페이스를 구현한 클래스에 대해서만 프록시를 생성할 수 있습니다. 따라서, 대상 클래스가 인터페이스를 구현하고 있어야 합니다.
CGLIB: 인터페이스를 구현하지 않은 클래스에 대해서도 프록시를 생성할 수 있습니다. CGLIB는 클래스를 직접적으로 상속받아 프록시 객체를 생성하기 때문에, 인터페이스 구현 여부에 제약이 없습니다.
프록시 객체 생성 방법:

JDK Dynamic Proxy: 자바의 표준 라이브러리에 포함되어 있으며, java.lang.reflect.Proxy 클래스를 사용하여 인터페이스에 대한 프록시를 생성합니다.
CGLIB: 외부 라이브러리로, 클래스의 상속을 기반으로 바이트 코드를 생성하여 프록시 객체를 생성합니다.
성능:

JDK Dynamic Proxy: 일반적으로 CGLIB에 비해 성능이 떨어질 수 있습니다. 특히 인터페이스를 구현한 경우에만 사용 가능하며, 리플렉션을 사용하여 메서드 호출을 처리하기 때문에 오버헤드가 발생할 수 있습니다.
CGLIB: 클래스의 상속을 통해 프록시를 생성하므로, 메서드 호출 시에 인터페이스 리플렉션이 필요하지 않아 성능이 더 우수합니다.
Final 클래스와 메서드:

JDK Dynamic Proxy: 대상 클래스나 메서드 중에서 final 키워드가 사용된 경우에는 프록시를 생성할 수 없습니다.
CGLIB: final 키워드가 사용된 클래스나 메서드에 대해서도 프록시를 생성할 수 있습니다.
일반적으로는 인터페이스를 사용하는 경우에는 JDK Dynamic Proxy를 고려하고, 클래스를 대상으로 하는 경우나 final 키워드가 사용된 경우에는 CGLIB를 사용하는 것이 적합합니다. Spring AOP는 이러한 차이를 고려하여 상황에 맞게 적절한 프록시 생성 기술을 선택해 사용하고 있습니다.

</div>
</details>
<details>
<summary>Spring에서는 JDK Dynamic Proxy와 CGLIB 중 어떤 것을 사용하나요?</summary>
<div markdown="1">


</div>
</details>
<details>
<summary>@Transactional의 역할은 무엇인가요?</summary>
<div markdown="1">


@Transactional은 Spring 프레임워크에서 제공하는 어노테이션으로, 트랜잭션 관리를 지원하는 데 사용됩니다. 이 어노테이션을 특정 메서드 또는 클래스에 적용함으로써 해당 메서드 또는 클래스의 메서드들이 트랜잭션 내에서 실행되도록 설정할 수 있습니다.

@Transactional 어노테이션의 주요 역할은 다음과 같습니다:

트랜잭션의 시작 및 종료 관리:

@Transactional이 적용된 메서드가 호출될 때 트랜잭션이 시작되며, 메서드 실행이 완료되면 트랜잭션이 종료됩니다.
만약 메서드에서 예외가 발생하면 롤백될 수 있습니다.
트랜잭션 속성 설정:

@Transactional 어노테이션은 다양한 속성을 가지고 있어, 트랜잭션의 동작을 세밀하게 조절할 수 있습니다. 몇 가지 주요 속성에는 isolation, propagation, readOnly, timeout, rollbackFor, noRollbackFor 등이 있습니다.
PlatformTransactionManager 사용:

Spring은 트랜잭션 관리를 위해 PlatformTransactionManager를 사용합니다. @Transactional이 적용되면 해당 어노테이션은 PlatformTransactionManager를 사용하여 트랜잭션을 시작하고 관리합니다.
커밋 및 롤백 처리:

@Transactional이 적용된 메서드에서 예외가 발생하지 않으면 트랜잭션은 커밋됩니다.
반면 예외가 발생하면 롤백됩니다.

</div>
</details>
<details>
<summary>@Transactional은 어떻게 동작하나요?</summary>
<div markdown="1">

트랜잭션 시작:

@Transactional이 적용된 메서드가 호출되면, Spring은 트랜잭션을 시작합니다.
PlatformTransactionManager 획득:

Spring은 트랜잭션 관리를 위해 PlatformTransactionManager를 사용합니다. @Transactional이 적용된 메서드에서는 이 트랜잭션 매니저를 획득하여 사용합니다.
트랜잭션 속성 설정:

@Transactional 어노테이션은 다양한 속성을 가지고 있습니다. 이 속성들은 트랜잭션의 격리 수준, 전파 속성, 읽기 전용 여부, 타임아웃 등을 설정할 수 있게 해줍니다.
메서드 실행:

트랜잭션을 시작하고 설정된 속성에 따라 메서드가 실행됩니다.
커밋 또는 롤백:

메서드 실행이 완료되면, 예외가 발생하지 않았다면 트랜잭션은 커밋됩니다. 반면 예외가 발생하면 트랜잭션은 롤백됩니다.
트랜잭션 종료:

트랜잭션은 커밋 또는 롤백 이후에 종료됩니다.

</div>
</details>
<details>
<summary>Spring의 interceptor와 filter의 주요 차이점은 무엇인가요?</summary>
<div markdown="1">

1. 적용 대상:
Interceptor:

Spring MVC에서 사용되며, 컨트롤러 핸들러 메서드 호출 전/후, 뷰 렌더링 전에 동작합니다.
주로 컨트롤러 수준 또는 특정 URI 패턴에 대한 요청 전/후에 적용됩니다.
Filter:

Java Servlet API에서 사용되며, 서블릿이나 JSP 등 컨테이너 수준에서 동작합니다.
주로 모든 요청에 대해 적용되며, Servlet Container 내부에서 동작합니다.
2. 포커스:
Interceptor:

주로 웹 애플리케이션의 비즈니스 로직에 집중됩니다.
Spring 컨텍스트 내에서 작동하므로 Spring Bean과 함께 사용됩니다.
Filter:

주로 로우 레벨의 HTTP 요청 및 응답 처리에 중점을 둡니다.
웹 애플리케이션 전반적인 요청과 응답 처리에 사용됩니다.
3. Spring Container 의존성:
Interceptor:

Spring Container에 의존하며, Spring MVC 내에서만 동작합니다.
Spring Bean으로 등록되고 관리됩니다.
Filter:

Servlet Container에 의존하며, 독립적으로 작동합니다.
Servlet Filter는 Java EE 표준이므로 Spring과는 무관하게 동작합니다.

</div>
</details>
<details>
<summary>Spring MVC에서 interceptor의 역할은 무엇이며, 구성 방법에 대해 설명해주세요.</summary>
<div markdown="1">


</div>
</details>
<details>
<summary>직렬화란 무엇이며, 왜 사용하나요?</summary>
<div markdown="1">


직렬화(Serialization)는 객체를 데이터 스트림으로 변환하는 프로세스를 의미합니다. 이는 객체를 파일에 저장하거나 네트워크를 통해 다른 시스템으로 전송하고, 나중에 원래의 객체로 복원할 수 있도록 합니다. 자바에서는 직렬화를 통해 객체를 바이트 스트림으로 변환하고, 역직렬화를 통해 바이트 스트림을 객체로 다시 변환할 수 있습니다.

직렬화의 주요 목적과 사용 이유:
데이터 저장 및 전송:

객체를 직렬화하여 데이터를 파일에 저장하거나, 네트워크를 통해 다른 시스템으로 전송할 수 있습니다. 이는 데이터의 영속성 유지나 다른 시스템 간에 객체를 주고받을 때 유용합니다.
클러스터링 및 분산 시스템:

여러 서버 간에 객체를 전송하거나, 클러스터링된 환경에서 객체를 공유하기 위해 직렬화가 사용됩니다.
RMI(원격 메서드 호출):

Java에서는 RMI를 통해 원격 시스템에서 메서드를 호출할 수 있습니다. 이때 객체를 직렬화하여 전송함으로써 원격에서 메서드 호출이 가능해집니다.
캐싱:

객체를 직렬화하여 캐시에 저장하거나 분산 캐싱 시스템에서 사용함으로써, 객체를 효율적으로 관리하고 성능을 향상시킬 수 있습니다.
자바 직렬화 API:

자바에서는 Serializable 인터페이스를 구현하여 직렬화를 지원합니다. 이를 통해 객체의 필드 값들이 바이트 스트림으로 변환됩니다. 또한, Externalizable 인터페이스를 사용하여 직렬화 및 역직렬화 프로세스를 직접 제어할 수도 있습니다.

</div>
</details>
<details>
<summary>Spring에서 객체의 직렬화와 역직렬화를 처리하는 방법에 대해 설명해주세요.</summary>
<div markdown="1">


</div>
</details>
<details>
<summary>스프링의 전체 동작 과정에 대해서 간단하게 설명해주세요.</summary>
<div markdown="1">


</div>
</details>
