# Spring 심화
- AOP
- - Spring AOP 어노테이션
  - JDK Dynamic Proxy
  - CGLIB
- [@transactional](https://github.com/transactional)
- interceptor
  - filter와 차이점
- 직렬화, 역직렬화
- Spring 전체 동작과정
 

# 면접 질문

### AOP란 무엇인가요 ?

Aspect Oriented Programming의 약자로 관점 지향 프로그래밍이라고 불린다. 

관점 지향은 쉽게 말해어떤 로직을 기준으로 핵심적인 관점, 부가적인 관점으로 나누어서 보고 그 관점을 기준으로 각각 모듈화하겠다는 것이다. 

### (꼬리질문) AOP의 구성요소에 대해 설명해주세요.

Aspect : 위에서 설명한 흩어진 관심사를 모듈화 한 것. 주로 부가기능을 모듈화함.

Target : Aspect를 적용하는 곳 (클래스, 메서드 .. )

Advice : 실질적으로 어떤 일을 해야할 지에 대한 것, 실질적인 부가기능을 담은 구현체

JointPoint : Advice가 적용될 위치, 끼어들 수 있는 지점. 메서드 진입 지점, 생성자 호출 시점, 필드에서 값을 꺼내올 때 등 다양한 시점에 적용가능

PointCut : JointPoint의 상세한 스펙을 정의한 것. 'A란 메서드의 진입 시점에 호출할 것'과 같이 더욱 구체적으로 Advice가 실행될 지점을 정할 수 있음

### (꼬리질문) AOP의 동작원리에 대해 설명해주세요.

Spring AOP에서는 런타임 시에 **JDK Dynamic Proxy** 또는 **CGLIB**를 활용하여 프록시를 생성해 준다. 참고로 이를 런타임 위빙(Runtime Weaving)이라고 부르며, 타겟 객체를 새로운 프록시 객체로 적용하는 과정을 의미한다.

Spring은 AOP 프록시를 생성하는 과정에서 자체 검증 로직을 통해 타겟의 인터페이스 유무를 판단한다. 이때 타겟이 하나 이상의 인터페이스를 구현하고 있는 클래스라면 JDK Dynamic Proxy를 사용하고, 그렇지 않으면 CGLIB의 방식으로 AOP 프록시를 생성해 준다.

### (꼬리질문) 스프링에서 AOP를 제공하는 두가지 방법에 대해 설명해주세요.

JDK Dynamic Proxy는 Java의 리플렉션 패키지에 존재하는 Proxy라는 클래스를 통해 생성된 프록시 객체를 의미한다. 리플렉션 Proxy 클래스의 `newProxyInstance()` 메소드를 사용하면 된다. 

CGLIB는 Code Generator Libray의 약자로, 클래스의 바이트 코드를 조작하여 프록시 객체를 생성해 주는 라이브러리다. CGLIB를 사용하면 인터페이스가 아닌 타겟 클래스에 대해서도 프록시 객체를 만들어 줄 수 있고, 이 과정에서 Enhancer라는 클래스를 활용한다.

### (꼬리질문) 각 방식의 장단점은 무엇인가요 ?
JDK Dynamic Proxy
- 장점
    - 개발자가 직접 프록시 객체를 만들 필요가 없다.
- 단점
    - 프록시하려는 클래스는 반드시 인터페이스의 구현체여야한다.
    - 리플렉션을 활용하므로 성능이 떨어진다.
CGLIB
- 장점
    - 인터페이스 없이 단순 클래스만으로도 프록시 객체를 동적으로 생성해 줄 수 있다.
    - 리플렉션이 아닌 바이트 조작을 사용하며, 타겟에 대한 정보를 알고 있기 때문에 JDK Dynamic Proxy에 비해 성능이 좋다.
- 단점
    - 의존성을 추가해야 한다. (Spring 3.2 이후 버전의 경우 Spring Core 패키지에 포함되어 있음)
    - default 생성자가 필요하다. (현재는 objenesis 라이브러리를 통해 해결)
    - 타겟의 생성자가 두 번 호출된다. (현재는 objenesis 라이브러리를 통해 해결)

### @Transactional 에 대해 설명해주세요.

`@Transactional` 어노테이션은 스프링에서 많이 사용되는 선언적 트랜잭션 방식이다.

해당 어노테이션은 getConnection(), setAutoCommit(false), 예외 발생 시 롤백, 정상 종료 시 커밋 등의 필요한 코드를 삽입해준다.

### @Transactional 의 동작원리에 대해 설명해주세요.

1. Target에 대한 호출이 오면, AOP 프록시가 인터셉터 체인을 통해 가로채온 후 Transaction Advisor에게 전달한다.
2. Transaction Advisor는 트랜잭션을 생성한다.
3. Custom Advisor가 있다면, 실행한 후 비즈니스 로직을 호출한다.
4. Transaction Advisor는 커밋 또는 롤백 등의 트랜잭션 결과를 반환한다.

### Interceptor와 filter에 관해 차이점을 중심으로 설명해주세요.

필터는 스프링 이전의 서블릿 영역에서 관리되지만, 인터셉터는 스프링 영역에서 관리되는 영역이기 때문에 필터는 스프링이 처리해주는 내용들을 적용 받을 수 없다. 

필터에서는 기본적으로 스프링과 무관하게 전역적으로 처리해야 하는 작업들을 처리할 수 있고, 인터셉터보다 앞단에서 동작하므로 전역적으로 해야하는 보안 검사(XSS 방어 등)를 하여 올바른 요청이 아닐 경우 차단을 할 수 있다. 
그러면 스프링 컨테이너까지 요청이 전달되지 못하고 차단되므로 안정성을 더욱 높일 수 있다.
또한 필터는 이미지나 데이터의 압축이나 문자열 인코딩과 같이 웹 애플리케이션에 전반적으로 사용되는 기능을 구현하기에 적당하다. Filter는 다음 체인으로 넘기는 ServletRequest/ServletResponse 객체를 조작할 수 있다.

인터셉터에서는 클라이언트의 요청과 관련되어 전역적으로 처리해야 하는 작업들을 처리할 수 있다.
세부적으로 적용해야 하는 인증이나 인가와 같이 클라이언트 요청과 관련된 작업의 처리가 가능하다.

### 직렬화와 역직렬화에 대해 설명해주세요.

직렬화는 객체를 저장, 전송할 수 있는 특정 포맷 상태로 바꾸는 과정이라고 할 수 있다.역직렬화는 말 그대로 직렬화의 반대이다. 즉,특정 포맷 상태의 데이터를 다시 객체로 변환하는 것을 뜻한다.

### Spring 전체 동작 과정을 설명해주세요.
1.**핸들러 조회** : 핸들러 매핑을 통해 URL에 매핑된 핸들러(컨트롤러) 조회

2.**핸들러 어댑터 조회**: 핸들러를 실행할 수 있는 핸들러 어댑터 조회

3.**핸들러 어댑터 실행**: 핸들러 어댑터 실행

4.**핸들러 실행**: 핸들러 어댑터가 실제 핸들러를 실행

5.**ModelAndView 반환**: 핸들러 어댑터는 핸들러가 반환하는 정보를 ModelAndView로 변환해 반환.

6.**viewResolver 호출**: 뷰 리졸버를 찾아 실행한다.

7.**View 반환**: 뷰 리졸버는 뷰의 논리 이름을 물이 이름으로 바꾸고 렌더링 역할을 담당하는 뷰 객체 반환.

8.**뷰 렌더링**: 뷰를 통해서 뷰를 렌더링한다.

# Ref

https://sasca37.tistory.com/267

https://steady-coding.tistory.com/608

https://code-lab1.tistory.com/289

https://mangkyu.tistory.com/173
