### AOP 
- **AOP란 무엇인가요?**
	- 스프링에서의 AOP는 cross-cutting concerns의 분리를 통해 모듈성을 증가시키는 프로그래밍 패러다임 입니다.
	- 기존 코드에 어드바이스(행동)을 추가하되, 코드 자체를 수정하지 않게 합니다.
	- 포인트컷 명세를 통해 어떤 코드가 수정되는지 별도로 지정합니다.
	- 이를 통해 비즈니스 로직에 중심이 되지 않는 행동들(로깅, 트랜잭션 관리, 보안)을 추가할 수 있게하여 비즈니스 로직만 보이게 합니다.
- **포인트 컷이란 무엇인가요?**
	- 포인트컷은 어드바이스가 적용될 조인 포인트를 지정하는 표현식입니다
	- 어드바이스는 포인트컷 표현식과 연결되며, 포인트컷에 의해 매칭된 모든 조인 포인트에서 실행됩니다(예: 특정 이름을 가진 메소드의 실행).
- **어드바이스란 무엇인가요?**
	- 어드바이스는 특정 조인 포인트에서 실행될 행동(로그, 트랜잭션 등) 입니다.
- **Aspect(관점)이란 무엇인가요?**
	- 여러 클래스에 걸쳐 있는 관심사의 모듈화입니다. 어드바이스(무엇을 할 것인가)와 포인트컷(어디에서 할 것인가)을 정의하는 곳입니다.
- JDK Dynamic Proxy에 대해 설명해주세요
	- - 대상 객체가 구현하는 인터페이스를 기반으로 프록시를 생성합니다.
	- `java.lang.reflect.Proxy` 클래스와 `java.lang.reflect.InvocationHandler` 인터페이스를 사용하여 구현합니다.
	- 인터페이스 기반이므로, 인터페이스를 구현하지 않는 클래스에는 사용할 수 없습니다.
- CGLIB Proxy의 주요 특징에 대해 설명해주세요
	- 대상 객체의 클래스를 상속받아 프록시를 생성합니다.
	- 인터페이스가 없는 클래스에도 프록시를 적용할 수 있습니다.
	- CGLIB는 클래스의 메소드를 오버라이딩하는 방식으로 작동하므로, final 메소드나 클래스에는 프록시를 적용할 수 없습니다.
	- 바이트코드 조작을 통해 구현되므로, JDK Dynamic Proxy보다 성능상 이점을 가질 수 있지만, 복잡성이 증가할 수 있습니다.
### @Transactional
- Transactional annotation에 대해 설명해주세요
	- 스프링에서 지원하며 선언적으로 트랜잭션을 관리하게 합니다.
	- 이 어노테이션을 사용하면 개발자가 트랜잭션 관리 코드를 직접 작성하지 않아도 되며, 대신 스프링이 지정된 메소드 실행을 트랜잭션 경계로 자동으로 관리해줍니다.
	- `@Transactional`을 메소드나 클래스에 적용하면 해당 메소드의 실행이 하나의 트랜잭션으로 처리됩니다.
- Transactional annotation의 속성에 대해 설명해주세요
	- **propagation**: 트랜잭션의 전파 방식을 지정합니다. 예를 들어, 이미 진행 중인 트랜잭션이 있을 때 현재 트랜잭션을 어떻게 처리할지 결정합니다.
	- **isolation**: 트랜잭션의 격리 수준을 지정합니다. 이는 동시에 실행되는 트랜잭션들이 서로에게 미치는 영향을 제어합니다.
	- **timeout**: 트랜잭션이 너무 오래 실행되는 경우 자동으로 롤백되도록 타임아웃을 설정합니다.
	- **readOnly**: 트랜잭션이 데이터를 읽기만 할 경우, 이를 최적화하기 위해 읽기 전용으로 설정할 수 있습니다.
	- **rollbackFor / noRollbackFor**: 특정 예외가 발생했을 때 롤백을 수행할지 여부를 지정합니다.

### 인터셉터와 필터
- **인터셉터와 필터의 차이점에 대해 설명해주세요**
	- 필터는 서블릿 컨테이너 수준에서 모든 요청에 대해 작동하는 반면, 인터셉터는 스프링 MVC의 일부로서 스프링이 처리하는 요청에 대해서만 작동합니다.
	- 인터셉터는 스프링 컨텍스트 내에서 작동하므로 스프링 빈과의 통합이 가능하지만, 필터는 서블릿 컨테이너 수준에서 작동합니다.
	- 필터는 서블릿 컨테이너에 의해 관리되기 때문에, 스프링 컨텍스트의 빈을 직접 참조하기 위해서는 추가적인 설정이 필요합니다. 하지만, 스프링 프레임워크는 `DelegatingFilterProxy`를 통해 필터 내에서 스프링 빈을 사용할 수 있게 해줍니다. 이는 필터를 스프링의 빈으로 선언하고, 실제 로직을 스프링 관리 아래에 있는 빈에 위임함으로써 해결할 수 있습니다.
	- 필터는 요청과 응답에 대한 전반적인 전처리와 후처리에 사용되며, 인터셉터는 스프링 MVC의 컨트롤러 실행 과정에 개입하는 데 주로 사용됩니다.
### 직렬화, 역직렬화
- **직렬화와 역직렬화에 대해 설명해주세요**
	-   직렬화(Serialization)와 역직렬화(Deserialization)는 데이터 구조나 객체 상태를 다른 데이터 포맷으로 변환하는 과정을 말합니다.
	- 직렬화는 객체의 상태를 연속적인 데이터로 변환하는 과정입니다. 이를 통해 객체를 파일에 저장하거나 네트워크를 통해 다른 시스템으로 전송할 수 있습니다. 직렬화된 데이터는 텍스트(예: JSON, XML) 또는 바이너리 형식일 수 있습니다.
	- 역직렬화는 직렬화의 반대 과정으로, 연속적인 데이터(직렬화된 데이터)를 원래의 객체 상태로 복원하는 과정입니다. 역직렬화를 통해 파일 시스템, 데이터베이스, 메모리 등에 저장되어 있거나 네트워크를 통해 전송받은 데이터 스트림을 다시 객체로 변환할 수 있습니다.

### 스프링 전체 동작 과정

스프링 웹 애플리케이션에서 사용자의 요청부터 응답까지의 처리 과정은 다음과 같습니다.

1. **필터 처리**: 요청이 서버에 도착하면, 먼저 서블릿 필터 체인을 통과합니다. 필터는 요청과 응답에 대한 전처리와 후처리를 담당합니다.

2. **DispatcherServlet 도달**: 필터 처리를 거친 요청은 스프링의 전면 컨트롤러인 `DispatcherServlet`에 도달합니다.

3. **핸들러 매핑 조회**: `DispatcherServlet`은 핸들러 매핑(`HandlerMapping`)을 조회하여 요청 URL을 처리할 수 있는 컨트롤러를 찾습니다.

4. **인터셉터 전처리**: 요청이 컨트롤러로 전달되기 전, 인터셉터가 실행됩니다. 인터셉터는 컨트롤러의 실행 전후에 추가적인 처리를 할 수 있습니다.

5. **컨트롤러 실행**: 적절한 컨트롤러가 선택되면, `DispatcherServlet`은 해당 컨트롤러의 메소드를 호출합니다.

6. **뷰 리졸버**: 컨트롤러가 반환한 뷰 이름을 바탕으로, 뷰 리졸버(`ViewResolver`)가 실제 뷰 객체를 찾아냅니다.
7. **뷰 렌더링**: 뷰 객체는 모델 데이터를 사용하여 최종적으로 사용자에게 보여줄 HTML 페이지를 생성합니다.
8. **인터셉터 후처리**: 컨트롤러의 로직이 실행되고, 뷰가 렌더링된 후, 인터셉터의 후처리 메소드가 호출됩니다.
9. **응답 반환**: 생성된 HTML 페이지(응답)는 사용자의 웹 브라우저로 반환되어 사용자에게 보여집니다.

10. **인터셉터와 필터의 요청 완료 처리**: 요청 처리가 완료되면, 남아 있는 인터셉터와 필터의 요청 완료 처리 메소드가 호출됩니다.
