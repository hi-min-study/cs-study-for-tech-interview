### Spring
- Spring 5.x.x 와 6.x.x 버전 차이에 대해서 설명해주세요
	- 5버전은 java 8 이상을 사용하게 만들었다면 6버전은 java 17이상을 강제로 사용하게 합니다.
	- 기존 javax.* 패키지를 스프링 6 버전에서 부터는 Jakarta.* 패키지로 대체하고 있습니다.
	- 자바 17에서는 ATOP 컴파일 및 Spring Native를 지원하여 애플리케이션의 시작 시간을 단축 시키고, 메모리 사용량을 줄일 수 있도록 지원 합니다

- Spring Boot 2.x.x와 3.x.x에 대해서 설명해주세요
	- 스프링 부트2
		- 2018년 처음 출시되었으며, Spring Framework 5.x.x를 기반으로 합니다. 
		- 자바 8 이상을 사용해야 합니다.
	- 스프링 부트3
		- Spring Framework 6.x.x를 기반으로 하며, Java17 이상을 요구 합니다. 
		- 기존 javax.* 패키지를 jakarta.* 패키지로 이동 하였습니다.
		- ATOP 컴파일 및 Spring Native를 지원하여 애플리케이션의 시작 시간을 단축 시키고, 메모리 사용량을 줄일 수 있도록 지원 합니다.

### Database 접근 
- JDBC에 대해 설명해주세요
	- DBC는 자바 애플리케이션에서 데이터베이스에 접근할 수 있도록 하는 Java API입니다. JDBC는 데이터베이스 작업을 수행하기 위한 자바 표준으로, 다양한 데이터베이스 (예: MySQL, PostgreSQL, Oracle 등)에 대해 통일된 인터페이스를 제공합니다. JDBC를 사용하면 SQL 명령어를 실행하여 데이터베이스를 조회하거나 업데이트할 수 있습니다.
	- JDBC를 사용하는 기본 단계는 다음과 같습니다:
		1. **드라이버 로드**: 사용할 데이터베이스에 맞는 JDBC 드라이버를 로드합니다.
		2. **연결 생성**: 데이터베이스에 연결하기 위한 `Connection` 객체를 생성합니다.
		3. **SQL 실행**: `Statement`, `PreparedStatement` 등을 생성하여 SQL 명령을 실행합니다.
		4. **결과 처리**: SQL 쿼리의 결과를 `ResultSet` 객체를 통해 받아와서 처리합니다.
		5. **자원 해제**: 사용한 리소스 (연결, 명령어 등)를 해제합니다.
- Spring JDBC에 대해 설명해주세요
	- Spring JDBC는 Spring 프레임워크에서 제공하는 JDBC의 추상화된 형태입니다. JDBC의 복잡성과 반복되는 코드 작성을 줄이는 것이 주목적입니다. Spring JDBC는 보일러플레이트 코드를 대폭 줄여주며, 데이터베이스 오류 처리, 리소스 관리, 결과 매핑 등을 용이하게 해줍니다.
	- **JdbcTemplate 클래스**: `JdbcTemplate` 클래스는 JDBC 작업에 대한 템플릿 메서드를 제공하여, SQL 실행, 결과셋 처리 등의 작업을 간단하게 만듭니다.
- SQL Mapper에 대해 설명해주세요
	- SQL Mapper는 SQL 문을 자바 코드와 연결하는 매핑 기능을 제공합니다. MyBatis와 같은 SQL Mapper는 개발자가 작성한 SQL 문을 사용하여 데이터베이스와의 상호작용을 관리하며, 결과를 자바 객체로 매핑합니다. 이는 개발자가 SQL을 직접 제어할 수 있게 해주어, 복잡한 쿼리나 최적화된 데이터베이스 작업이 필요한 경우 유용합니다. MyBatis는 설정을 통해 SQL 문과 자바 객체 간의 매핑을 관리하며, SQL 문의 재사용 및 유지보수를 용이하게 합니다.
- ORM에 대해 설명해주세요 
	- ORM은 관계형 데이터베이스의 테이블을 자바 객체로 매핑하는 기술입니다. 이를 통해 개발자는 SQL 쿼리를 직접 작성하지 않고도 객체 지향적인 방식으로 데이터베이스를 조작할 수 있습니다. Hibernate, JPA(Java Persistence API)와 같은 ORM 프레임워크는 데이터베이스 작업을 추상화하고, 객체와 데이터베이스 간의 상호작용을 자동화합니다. ORM의 주요 이점은 생산성 향상, 코드의 가독성 및 유지보수성 개선입니다. 하지만, 복잡한 쿼리를 최적화하기 어렵거나, ORM 프레임워크의 작동 방식을 이해하는 데 시간이 필요한 경우도 있습니다.
- @Transactional 전파 옵션 위주로 설명해주세요
	1. **REQUIRED** (기본값)
	    - 현재 진행 중인 트랜잭션이 있으면 해당 트랜잭션에 참여합니다. 진행 중인 트랜잭션이 없으면 새로운 트랜잭션을 시작합니다.
	    - 대부분의 경우에 적합한 기본 옵션입니다.
	1. **SUPPORTS**
	    - 현재 진행 중인 트랜잭션이 있으면 해당 트랜잭션에 참여합니다. 하지만, 진행 중인 트랜잭션이 없어도 트랜잭션 없이 메서드를 실행할 수 있습니다.
	    - 트랜잭션이 필요하지 않은 읽기 전용 연산에 주로 사용됩니다.
	2. **MANDATORY**
	    - 이미 시작된 트랜잭션이 있어야만 메서드를 실행할 수 있습니다. 진행 중인 트랜잭션이 없으면 예외가 발생합니다.
	    - 반드시 상위 트랜잭션의 컨텍스트에서 실행되어야 하는 작업에 적합합니다.
	4. **REQUIRES_NEW**
	    - 항상 새로운 트랜잭션을 시작합니다. 현재 진행 중인 트랜잭션이 있으면 잠시 중단(보류)되고, 새 트랜잭션이 완료된 후에 이전 트랜잭션이 재개됩니다.
	    - 독립적인 트랜잭션 관리가 필요한 경우에 사용됩니다.
	5. **NOT_SUPPORTED**
	    - 트랜잭션을 사용하지 않고 메서드를 실행합니다. 현재 진행 중인 트랜잭션이 있으면 잠시 중단됩니다.
	    - 트랜잭션이 필요 없는 작업에 사용됩니다.
	6. **NEVER**
	    - 트랜잭션 없이 메서드를 실행합니다. 현재 진행 중인 트랜잭션이 있으면 예외가 발생합니다.
	    - 트랜잭션을 사용하면 안 되는 명확한 경우에 사용됩니다.
	7. **NESTED**
	    - 현재 진행 중인 트랜잭션이 있으면, 현재 트랜잭션 내에서 중첩된 트랜잭션을 시작합니다. 중첩된 트랜잭션은 독립적으로 커밋 또는 롤백될 수 있습니다. 진행 중인 트랜잭션이 없으면, `REQUIRED`와 동일하게 작동합니다.
	    - 세분화된 트랜잭션 관리가 필요한 복잡한 로직에서 유용합니다.
- Batch Insert에 대해서 설명해주세요
	-   Batch Insert는 데이터베이스에 대량의 데이터를 한 번에 삽입하는 기술입니다. 이 방법은 여러 개의 삽입(insert) 명령을 하나의 대규모 연산으로 그룹화하여 데이터베이스 서버로 전송합니다. Batch Insert를 사용하면 네트워크 지연 시간을 줄이고, 데이터베이스 처리 속도를 개선하여 전반적인 성능을 향상시킬 수 있습니다.