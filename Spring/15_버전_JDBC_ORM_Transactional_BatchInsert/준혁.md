- Spring 버전
  - Spring 5.x.x와 6.x.x 버전 차이
  - Spring Boot 2.x.x와 3.x.x 버전 차이
- JDBC, Spring JDBC
- Sql Mapper(MyBatis), ORM
- @transactional 옵션들 위주로
- Batch Insert

## 예상 질문
- Spring 5.x.x와 6.x.x 버전 차이에 대해서 설명해주세요
  - java 17 기반으로 동작하고, xml이 점진적으로 사라지게 될 것이라는 것이 가장 큰 특징입니다.
- Spring Boot 2.x.x와 3.x.x 버전 차이
  - 최소 요구 사항들이 좀 변화했습니다. java 17과 spring 6 버전을 사용해야합니다.
- ORM에 대해서 설명해주세요
  - Object Relation Mapping의 약자로, 객체 지향 언어에서 사용되는 객체라는 개념과 관계형 데이터베이스에서 사용되는 릴레이션 이라는 개념을 매핑 시켜놓은 기술을 말합니다.
- SQL Mapper에 대해서 설명해주세요.
  - 개발자가 직접 SQL을 이용해 DB 데이터를 다루는 기술로, 쿼리의 결과를 객체와 매핑시키는 전략을 사용합니다.
- ORM과 SQL Mapper의 장단점을 비교해주세요
  - ORM은 개발자가 SQL을 직접 작성하지 않고, 데이터베이스를 조작할 수 있고, DBMS에 종속적이지 않다는 장점이 있는 반면 비교적 성능면에서 아쉬움이 있고, 복잡한 쿼리가 필요할 시 불리해진다는 단점이 있습니다.
  - SQL Mapper는 SQL이 비즈니스 로직과 분리되어있고, ORM과는 다르게 좀 더 세밀한 SQL도 처리가 가능하다는 장점이 있는 반면 객체와 테이블 간의 패러다임 불일치가 발생하고, DBMS에 종속적이라는 단점이 있습니다.
- JDBC와 DataSource에 대해서 설명해주세요
  - JDBC는 Java 진영에서 데이터베이스와의 연결을 위해 사용하는 기술입니다.
  - JDBC에서 DB와 통신할 때, Connection 이라는 객체를 통해서 통신하는데, 이 Connection과 Connection Pool을 관리하는 주체를 Data Source라고 합니다.  
- @Transactional의 전파 옵션에 대해서 아는대로 설명해주세요
  - REQUIRED : 이미 시작된 트랜잭션이 있으면 참여하고, 없으면 새로운 트랜잭션을 시작합니다. (디폴트 속성)
  - SUPPORTS : 이미 시작된 트랜잭션이 있으면 참여하고, 없으면 트랜잭션 없이 처리합니다.
  - REQUIRED_NEW : 항상 새로운 트랜잭션을 시작합니다. 이미 진행중인 트랜잭션이 있다면 잠시 보류시킵니다.
  - MANDATORY : 이미 시작된 트랜잭션이 있으면 참여하고, 없으면 새로운 트랜색션을 시작하는 대신 예외를 발생시킵니다. 혼자서는 독립적으로 수행되면 안되는 경우에 사용됩니다.
  - NOT_SUPPORTED : 트랜잭션을 사용하지 않고 처리하도록 합니다. 이미 진행중인 트랜잭션이 있다면 잠시 보류시킵니다.
  - NEVER : 트랜잭션을 사용하지 않도록 강제시킵니다. 이미 진행중인 트랜잭션 또한 허용하지 않으며, 있다면 예외를 발생시킵니다.
  - NESTED : 이미 실행중인 트랜잭션이 있다면 중첩하여 트랜잭션을 진행합니다. 부모 트랜잭션은 중첩 트랜잭션에 영향을 주지만 중첩 트랜잭션은 부모 트랜잭션에 영향을 주지 않습니다.
- 만약 JPA 환경에서 batch성 작업을 해야한다면 어떻게 하실건가요?
  - 영속성 컨텍스트에 너무 많은 엔티티가 존재하지 않도록 관리해주는 것이 중요합니다. 대량의 작업을 하는 중간 중간에 주기적으로 영속성 컨텍스트를 flush하고 clear하는 식으로 구현할 수 있습니다.
