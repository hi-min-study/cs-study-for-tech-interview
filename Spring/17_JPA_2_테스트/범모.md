## 내용 정리
### 프록시 필요성

- JPA에서 특정 엔티티 조회시 연관관계에 놓여있는 엔티티까지 조회하지 않기 위해 지연 로딩 사용
- 지연로딩을 구현하기 위해 연관관계에 놓여있는 엔티티는 프록시 객체로 생성

### 프록시 초기화 과정

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/f161c15f-c5f0-4683-9793-c7551a62792f/af82d3d9-1c95-46ef-a42a-f703d6fd3f0c/Untitled.png)

1. 실제 사용을 위해 메서드를 호출합니다.
2. 메서드가 호출되면 영속성 컨텍스트에 초기화를 요청합니다. 실제 엔티티 객체의 참조를 가지기 위해 실제 엔티티 객체의 생성이 필요합니다.
3. 영속성 컨텍스트는 데이터베이스를 조회해서 실제 엔티티 객체의 정보를 얻습니다.
4. 조회된 정보를 바탕으로 실제 Entity 객체를 생성합니다.
5. 참조를 통해 실제 엔티티 객체의 메서드를 호출합니다.
6. 메서드 호출의 결과를 반환합니다.

### 프록시 특징

- 프록시 객체는 처음 사용할 때 한 번만 초기화됩니다.
- 프록시 객체의 초기화는 실제 엔티티 객체로의 변경을 의미하는 것이 아니라 실제 엔티티 객체의 참조를 가지는 것으로 이해할 수 있습니다.
- 프록시 객체는 원본 엔티티를 상속받은 객체이므로 타입 체크 시 주의해서 사용해야 합니다.
- 영속성 컨텍스트에 이미 존재한다면 데이터베이스 조회가 필요 없고 프록시 객체 사용 필요성이 없으므로 프록시 객체가 아닌 실제 엔티티 객체를 반환합니다.
    - 동일성 보장을 위해 먼저 나온 객체가 프록시 객체일 때 **`find`**를 사용하더라도 프록시 객체가 나올 수 있습니다.
- 초기화는 영속성 컨텍스트의 도움을 받아야 하기에 준영속 상태의 프록시를 초기화하면 문제가 발생합니다.

### 영속성 전이

- 특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만들고 싶을 때 사용하는 옵션

### 종류

- **ALL : 모두 적용**
- **PERSIST : 영속**
- **REMOVE : 삭제**
- MERGE : 병합
- REFRESH : REFRESH
- DETACH : DETACH

### 고아객체

- 부모 엔티티와 연관관계가 끊어진 자식 엔티티

**orphanRemoval**

- 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제

## 주의

- 참조가 제거된 엔티티는 다른 곳에서 참조하지 않는 고아객체로 보고 삭제하는 기능
- **참조하는 곳이 하나일 때 사용해야한다!**
    - 자식 객체가 부모가 두개 이상일 때, orphanRemoval = true로 설정하면
    - 하나의 부모와 관계가 끊어졌을 때 자식객체가 delete되어 다른 부모와의 관계가 없어져 버림.
- **특정 엔티티가 개인 소유할 때만 사용**
- @OneToMany, @OneToOne만 가능 : 참조하는 쪽이 하나인 경우만 사용

### 단방향/양방향 매핑

### 단방향 매핑 (Undirectional Mapping)

- 한 엔티티가 다른 엔티티를 참조할 수 있지만, 반대 방향으로는 참조가 어렵다.
- 한쪽 방향에서만 관계를 관리할 수있다.
- 구현이 간단하고 명확하지만, 반대 방향으로의 참조가 필요한 경우에는 적합하지 않을 수 있다.

### 양방향 매핑 (Bidirectional Mapping)

- 양방향 매핑에서는 두 엔티티가 서로를 참조할 수 있다.
- 한쪽 엔티티에서 변경이 발생하면 관련 엔티티도 해당 변경을 인식할 수 있다.
- 단방향 매핑에 비해서 복잡하고 관리해야 하는 영역이 많지만, 양쪽 엔티티간의 관계를 유연하게 관리할 수 있는 장점이 존재.

### 연관관계의 주인

### 연관관계의 주인이 필요한 이유

1. 패러다임의 차이

예를 들어 (Member, Team)이 있고 양방향 연관 관계를 갖는다고 해보자. 이 상황에서 Member를 다른 Team으로 수정하려고 할 때 Member 객체에서 setTeam() 같은 메서드로 수정해야하는지, Team 객체에서 getMemberList()로 List형식으로 들어와있는 member List 객체를 꺼내 수정해야하는지의 문제가 발생한다. 객체 패러다임에서는 두 방식 다 옳지만, 데이터베이스의 패러다임을 적용하려고 존재하는 JPA 입장에서 혼란스러워진다는 것이다.즉, 연관관계의 주인이 있어야 객체 패러다임에서의 양방향 관계가 데이터베이스 패러다임에서 연관관계가 하나임을 보장할 수 있게 된다.

2. 영속성 컨텍스트 변경감지기준

예를들어 member.setTeam(), team.getMemberlist().addMember() 등을 모두 허용하게 되면 영속성 컨텍스트가 너무 복잡해지게 된다. 경우에 따라 하나의 수정이지만, update 쿼리가 두번 나가게 될 수도 있고(양쪽 연관관계를 모두 업데이트 해버리는 경우), 이를 최적화하기 위한 추가적인 연산도 많아진다. 또한 양쪽 연관관계가 모순되는 경우 어떻게 처리할지에 대한 규약도 훨씬 복잡해진다.(team.memberLis에는 member1이 있는데, member1.setTeam(null)인 경우에 어떤 쪽을 따라야하는가?)

### 연관관계의 주인

- 두 단방향관계 (A->B, B->A)를 맺을 때, 이 중 제어의 권한(데이터 조회, 저장, 수정, 삭제)를 갖는실질적인 관계가 무엇인지 JPA에게 알리는 것
- 외래 키가 있는 곳을 주인으로 정해야한다.
- 외래키의 반대쪽(다대일에서 일의 위치)을 주인으로 정하게 되면, 다음과 같은 문제가 생긴다.
    - 하나의 팀은 여러 Member를 가진다. 만약 Team을 수정하게되면 모든 members에게 DB 쿼리가 발생하게 된다.
    - Member에서 외래키를 가지고 있지 않기때문에, Member가 스스로 Team을 변경할 수 없게 되버린다.
- 주인이 아닌 쪽에서는, 참조값을 통해 값을 수정할 수 없다. 수정해도 DB에 반영되지 않는다.

### 연관관계 편의 메소드

- 양방향 연관관계를 한 번에 설정하기 위해 작성하는 메서드

### 필요성

- 연관관계의 주인을 통해 연관관계를 맺기만 해도 양방향으로 사용이 가능하지만, 연관관계 설정 이후에 한 트랜잭션에서 조회가 제대로 되지 않으므로.
- 코드 중복을 방지하고 양방향 연관 관계 매핑에서 한쪽에만 연관 관계가 설정되는 것을 방지할 수 있습니다.

### N+1문제

- 연관 관계가 설정된 엔티티를 조회할 경우에 조회된 데이터 갯수(n) 만큼 연관관계의 조회 쿼리가 추가로 발생하여 데이터를 읽어오는 문제.

### 해결책

1. Fetch Join

```
@Query("select distinct u from User u left join fetch u.articles")
List<User> findAllJPQLFetch();
```

- JPQL로 fetch join을 작성하여 연관관계에 놓여있는 엔티티들을 즉시로딩한다.
- 단점
    - distinct 작업을 하기 위해 쿼리 결과를 전부 메모리에 적재한 뒤 Pagination 작업을 어플리케이션 레벨에서 하기 때문에 offset, limit절 사용 의미가 없다.
    - 따라서 distinct작업이 없도록 ManyToOne 관계에서 fetch join을 사용한다.(그러면 offset, limit절을 정상사용 가능하다.)
1. @EntityGraph
- JPQL없이 페치 조인을 사용할 수 있다.
- 단점
    - 페치 조인과 다르게 inner join ( 교집합 ) 이 아닌, left outer join ( 왼쪽 기준으로 합집합 )을 사용한다.
    - 페치 조인과 같이 메모리에서 페이징 처리를 하기 때문에 페이지네이션의 의미가 없어진다.
1. Batch Size
- 연관된 엔티티 조회 시 지정한 size 만큼 `IN` 쿼리를 사용하여 조회하고, (지연로딩 사용 시) 조회한 다음 엔티티의 정보가 필요한 시점에 추가 in 쿼리를 size만큼 또 날린다.
- `size`는 IN절에 올수있는 최대 인자 개수를 말한다.
- 기존에는
    - Place 를 조회하는 쿼리 1개
    - 조회된 N개의 Place에 대해 연관된 엔티티를 조회하는 쿼리 N개

  로 인해 N+1 문제가 발생했다면, @BatchSize를 적용한 후에는

    - Place 를 조회하는 쿼리 1개 (Place가 N개 조회된다.)
    - 조회된 Place N개와 연관된 컬렉션 엔티티를 조회하는 `IN` 쿼리 1개

  의 쿼리가 실행된다. 즉, `1 + N` 번 실행 되었던 쿼리가 `1 + 1`번 실행됨으로써 N+1 문제를 해결한 것이다.

- 데이터의 전체 row를 예상할 수 있는 범위에서는 좋은 방안이긴 하나 정확한 Size를 알수 없을때는 적정값을 설정해 주긴 어렵습니다.

### DDD, TDD

### DDD

### **정의**

DDD(Domain-Driven Design) 또는 도메인 주도 설계라고 부른다. **도메인 패턴**을 중심에 놓고 설계하는 방식을 일컫는다.

### **특징**

- 도메인 그 자체와 도메인 로직에 초점을 맞춘다. 일반적으로 많이 사용하는 **데이터 중심의 접근법**을 탈피해서 순수한 도메인의 모델과 로직에 집중하는 것을 말한다.
- **보편적인(ubiquitous) 언어**의 사용이다. 도메인 전문가와 소프트웨어 개발자 간의 커뮤니케이션 문제를 없애고 상호가 이해할 수 있고 모든 문서와 코드에 이르기까지 동일한 표현과 단어로 구성된 단일화된 언어체계를 구축해나가는 과정을 말한다. 이로서 분석 작업과 설계 그리고 구현에 이르기까지 통일된 방식으로 커뮤니케이션이 가능해진다.
- **소프트웨어 엔티티와 도메인 컨셉트를 가능한 가장 가까이 일치시키는 것이다.** 분석 모델과 설계가 다르고 그것과 코드가 다른 구조가 아니라 도메인 모델부터 코드까지 항상 함께 움직이는 구조의 모델을 지향하는 것이 DDD의 핵심원리이다.

### TDD

- 반복 테스트를 이용한 소프트웨어 방법론으로,작은 단위의 테스트 케이스를 작성하고 이를 통과하는 코드를 추가하는 단계를 반복하여 구현

### 진행과정

- Red단계에서는 실패하는 테스트 코드를 먼저 작성한다.
- Green단계에서는 테스트 코드를 성공시키기 위한 실제 코드를 작성한다.
- Blue단계에서는 중복 코드 제거, 일반화 등의 리팩토링을 수행한다.

### 장점

1. 디버깅 시간을 단축 할 수 있다. 이는 유닛 테스팅을 하는 이점이기도 하다. 예를 들면 사용자의 데이터가 잘못 나온다면 DB의 문제인지, 비즈니스 레이어의 문제인지 UI의 문제인지 실제 모든 레이어들을 전부 디버깅 해야하지만, TDD의 경우 자동화 된 유닛테스팅을 전재하므로 특정 버그를 손 쉽게 찾아낼 수 있다.
2. 코드가 내 손을 벗어나기 전에가장 빠르게 피드백 받을 수 있다. 개발 프로세스에서는 보통 ‘인수 테스트’를 한다. 이미 배치된 시스템을 대상으로 클라이언트가 의뢰한 소프트웨어가 사용자 관점에서 사용할 수 있는 수준인지 체크하는 과정이다. 이미 90% 이상 완성된 코드를 가지고 테스트하기 때문에,문제를 발견해도, 정확하게 원인이 무엇인지 진단하기는 힘들다. 하지만 TDD를 사용하면 기능 단위로 테스트를 진행하기 때문에 코드가 모두 완성되어 프로그래머의 손을 떠나기 전에 피드백을 받는 것이 가능하다.
3. 작성한 코드가 가지는 불안정성을 개선하여 생산성을 높일 수 있다. 켄트 백은 TDD는 불안함을 지루함으로 바꾸는 마법의 돌이라고 말했다. 앞서 말한 것처럼 TDD를 사용하면, 코드가 내 손을 떠나 사용자에게 도달하기 전에 문제가 없는지 먼저 진단 받을 수 있다. 그러므로 코드가 지닌 불안정성과 불확실성을 지속적으로 해소해준다.
4. 재설계 시간을 단축 할 수 있다.테스트 코드를 먼저 작성하기 때문에 개발자가 지금 무엇을 해야하는지 분명히 정의하고 개발을 시작하게 된다. 또한 테스트 시나리오를 작성하면서 다양한 예외사항에 대해 생각해볼 수 있다.이는 개발 진행 중 소프트웨어의 전반적인 설계가 변경되는 일을 방지할 수 있다.
5. 추가 구현이 용이하다. 개발이 완료된 소프트웨어에어떤 기능을 추가할 때 가장 우려되는 점은 해당 기능이기존 코드에 어떤 영향을 미칠지 알지 못한다는 것이다. 하지만 TDD의 경우 자동화된 유닛 테스팅을 전제하므로 테스트 기간을 획기적으로 단축시킬 수 있다.

### 단점

1. 가장 큰 단점은 바로 생산성의 저하이다. 개발 속도가 느려진다고 생각하는 사람이 많기 때문에 TDD에 대해 반신반의 한다.
   왜냐하면 처음부터 2개의 코드를 짜야하고, 중간중간 테스트를 하면서 고쳐나가야 하기 때문이다.
   TDD 방식의 개발 시간은 일반적인 개발 방식에 비해 대략 10~30% 정도로 늘어난다.
   SI 프로젝트에서는 소프트웨어의 품질보다 납기일 준수가 훨씬 중요하기 때문에 TDD 방식을 잘 사용하지 않는다.
2. 이제까지 자신이 개발하던 방식을 많이 바꿔야 한다. 몸에 체득한 것이 많을 수록 바꾸기가 어렵다. 오히려 개발을 별로 해보지 않은 사람들에겐 적용하기가 쉽다.
3. 구조에 얽매인다. TDD로 프로젝트를 진행하면서 어려운 예외가 생길 수 있는데 그것 때문에 고민하는 순간이 찾아오게 된다.원칙을 깰 수는 없고 꼼수가 있기는 한데 그 꼼수를 위해서 구조를 바꾸자니 이건 아무래도 아닌 것 같고, 테스트는 말 그대로 테스트일 뿐 실제 코드가 더 중요한 상황인데도 불구하고 테스트 원칙 때문에 쉽게 넘어가지 못하는 그런 경우다.

### Junit4 vs Junit5

## **JUnit**

- 자바 프로그래밍 언어용 유닛 테스트 프레임워크
- 테스트 결과는 **Test클래스**로 개발자에게 테스트 방법 및 클래스의 History를 공유 가능
- **단정(assert) 메서드**로 테스트 케이스의 수행 결과를 판별
- **어노테이션**으로 간결하게 지원(JUnit4부터)

***SpringBoot 2.2.x*** 버전이 release 되면서 예전의 SpringBoot에서 ***Junit4*** 버전이 ***Junit5***이 기본으로 변경되었습니다.

Junit5는 **Java 8** 이상의 버전을 요구합니다.

### Junit4

- ***vintage-engine***
- @Test 어노테이션을 이용한 테스트 메소드 지정
- @Before, @After, @BeforeClass, @AfterClass 어노테이션을 사용한 테스트의 전처리 및 후처리 작업 지정
- @Ignore 어노테이션을 사용한 테스트 무시
- assert 메소드를 통한 테스트 검증
- 예외 테스트를 위해 @Test(expected= Exception.class) 사용

### Junit5

- ***jupiter-engine***
- @ExtendWith를 통한 더 유연한 확장 모델 제공
- 람다를 사용한 동적 테스트생성 지원
- @DisplayName 어노테이션으로 테스트 이름을 직관적으로 표현
- @Tag를 사용한 테스트 필터링
- @Nested를 사용한 중첩된 테스트 클래스 지원
- @ParameterizedTest를 사용한 파라미터화 된 테스트 지원
- assertThrows를 이용한 예외 테스트개선
- 다양한 assert 메소드 제공

## **JUnit5 모듈 구성**

JUnit5는 이전버전과 달리 크게 3개의 서브 프로젝트로 구성된 복수의 모듈로 구성되어 있습니다. 또한 각각의 프로젝트는 용도에 따라서 몇개의 서브 모듈로 구성되어 있습니다.

### **JUnit Platform**

JUnit 테스트를 실행하기 위한 기반이 되는 모듈입니다. Gradle, Maven과 같은 빌드툴은 물론 IDE를 위한 모듈도 각각 존재합니다. Platform이 제공하는 `TestEngine`을 구현한 모듈을 찾아서 실행해준다고 보면 될 것 같습니다.

JVM에서 동작하는 테스트 프레임워크입니다. 테스트를 발견하고 계획을 생성하고 결과를 보고하는 TestEngine 인터페이스를 정의합니다.

### **JUnit Jupiter**

테스트를 기술하기 위한 프로그램, 확장 모델들이 담겨있는 모듈입니다. 엄밀한 의미에서는 맞지않겠지만 흔히 JUnit5라고 언급할 경우에 이 모듈을 지칭한다고 생각하시면 될 듯 합니다.

### **JUnit Vintage**

JUnit의 3, 4 버전을 실행하기 위한 `TestEngine`을 제공하는 모듈입니다. 이 모듈을 통해서 JUnit5와 병행 사용이 가능합니다. TestEngine에서 Junit3 및 Junit4 기반 테스트를 실행하기 위한 기능을 제공합니다.

제가 제일 궁금했던 어노테이션의 차이는 @ExtendWith입니다. 왜냐 @AutoMockMvc와 같이사용해야 MockMvc를 사용할수있었기떄문입니다.

@ExtendWith 애노테이션은 JUnit5에서 확장 기능을 실행할 때 사용한다.

SpringExtension은 JUnit5를 위한 스프링 확장 기능으로 스프링 연동 테스트를 실행할 수 있게 한다.

그런데 @SpringBootTest에 들어있기때문에 안사용해도된다.

### 플랫폼 제공

Junit4에서는 plugin과 ide의 통합 지원이 없었기 때문에 reflection에 의존해야만 했습니다.

Junit5 부터는 JUnit Platform이라는 테스트코드 통합 지원 플랫폼이 제공되어 테스트 코드 실행이 해당 플랫폼 위에서 수행됩니다.

### 단위, 통합, 인수 테스트

### **단위 테스트(Unit Test)**

> 단위 테스트는 응용 프로그램에서 테스트 가능한 가장 작은 소프트웨어를 실행하여 예상대로 동작하는지 확인하는 테스트이다.
>

단위 테스트에서 테스트 대상 단위의 크기는 엄격하게 정해져 있지 않다. 하지만, 일반적으로 클래스 또는 메소드 수준으로 정해진다. 단위의 크기가 작을수록 단위의 복잡성이 낮아진다. 따라서, 단위 테스트를 활용하여 동작을 표현하기 더 쉬워진다. 즉, 테스트 대상 단위의 크기를 작게 설정해서 단위 테스트를 최대한 간단하고 디버깅하기 쉽게 작성해야 한다.

소프트웨어를 개발할 때, 소프트웨어 내부 구조나 구현 방법을 고려하여 개발자 관점에서 테스트한다. 그러므로 단위 테스트는 소프트웨어 내부 코드에 관련한 지식을 반드시 알고 있어야 하는 화이트박스 테스트이다. 단위 테스트는 TDD와 함께 할 때 특히 더 강력해진다.

프로그래밍 언어마다 단위 테스트에서 사용하는 프레임워크가 다르다. Java는 주로 `JUnit`으로 테스트한다.

### **통합 테스트(Integration Test)**

> 통합 테스트는 단위 테스트보다 더 큰 동작을 달성하기 위해 여러 모듈들을 모아 이들이 의도대로 협력하는지 확인하는 테스트이다.
>

통합 테스트는 단위 테스트와 달리 개발자가 변경할 수 없는 부분(ex. 외부 라이브러리)까지 묶어 검증할 때 사용한다. 이는 DB에 접근하거나 전체 코드와 다양한 환경이 제대로 작동하는지 확인하는데 필요한 모든 작업을 수행할 수 있다. 그러나, 통합 테스트가 응용 프로그램이 완전하게 작동하는 걸 무조건 증명하지는 않는다.

통합 테스트의 장점은 단위 테스트에서 발견하기 어려운 버그를 찾을 수 있다는 점이다. 예를 들어, 통합 테스트에서는 환경 버그(ex. 싱글 코어 CPU에서는 잘 실행되나 쿼드 코어 CPU에서는 잘 실행되지 않음)이 발생할 수 있다.

한편, 통합 테스트의 단점은 단위 테스트보다 더 많은 코드를 테스트하기 때문에 신뢰성이 떨어질 수 있다는 점이다. 또, 어디서 에러가 발생했는지 확인하기 쉽지 않아 유지보수하기 힘들다는 점도 있다.

스프링부트에서는 클래스 상단에 `@SpringBootTest` 어노테이션을 붙여 통합 테스트를 수행할 수 있다.

### **인수 테스트(Acceptance Test)**

> 인수 테스트는 사용자 스토리(시나리오)에 맞춰 수행하는 테스트이다.
>

앞선 두 테스트들과 달리 비즈니스 쪽에 초점을 둔다. 프로젝트에 참여하는 사람들(ex. 기획자, 클라이언트 대표, 개발자 등)이 토의해서 시나리오를 만들고, 개발자는 이에 의거해서 코드를 작성한다. 개발자가 직접 시나리오를 제작할 수도 있지만, `다른 의사소통집단으로부터 시나리오를 받아(인수) 개발한다`는 의미를 가지고 있다.

인수 테스트는 애자일 개발 방법론에서 파생했다. 특히, 익스트림 프로그래밍(XP)에서 사용하는 용어이다. 이는 시나리오가 정상적으로 동작하는지를 테스트하기 때문에 통합 테스트와는 분류가 다르다. 시나리오에서 요구하는 것은 `누가, 어떤 목적으로, 무엇을 하는가`이다. 개발을 하다 보면 이런 기능은 API를 통해 드러난다. 인수 테스트는 주로 이 API를 확인하는 방식으로 이뤄진다.

결국, 인수 테스트는 소프트웨어 인수를 목적으로 하는 테스트이다. 소프트웨어를 인수하기 전에 명세한 요구사항(인수 조건)대로 잘 작동하는지 검증이 필요하다.

소프트웨어를 인수할 때, 소프트웨어 내부 구조나 구현 방법을 고려하기보다는 실제 사용자 관점에서 테스트하는 경우가 많다. 따라서, 인수 테스트는 소프트웨어 내부 코드에 관심을 가지지 않는 블랙박스 테스트이다. 실제 사용자 관점에서 테스트할 때 주로 E2E(End-to-End) 형식을 이용해서 확인한다.

Java에서는 `RestAssured`, `MockMvc` 같은 도구를 활용하여 인수 테스트를 작성할 수 있다.

### stub, mock

### **테스트 대역(Test Double)**

- 테스트 대역이란 테스트하려는 객체가 다른 객체들이 여러 관계가 엮여있어 사용하기 힘들 때, **대체할 수 있는 객체를 의미**합니다.
- 테스트 대역은 Dummy, Stub, Spy, Mock, Fake로 나눠집니다.
- `Dummy` 객체는 전달되지만 사용되지 않고 일반적으로 매개변수 목록을 채우는 목적으로만 사용됩니다.
- `Fake` 객체는 실제로 작동하는 구현을 가지고 있지만 일반적으로 프로덕션에 적합하지 않는 몇가지 지름길을 사용합니다.
    - 대표적인 예시로 메모리 데이터베이스가 있습니다.
- `Stub`은 테스트 중에 만들어진 호출에 미리 준비된 답변을 제공하며 일반적으로 테스트를 위해 프로그래밍된 것 외에는 전혀 응답하지 않습니다.
- `Spy`는 어떻게 호출받았는지에 따라 일부 정보를 기록하는 Stub 입니다.
    - 예시로 전송된 메시지 수를 기록하는 이메일 서비스 일 수 있습니다.
- `Mock` 은 예상되는 기대값으로 미리 프로그래밍 객체입니다.

Test의 원칙에 따르면 하나의 테스트에는 여러 개의 스텁이 있을 수 있지만 일반적으로 mock은 하나만 있습니다.

### **Stub**

- 인스턴스화하여 구현한 가짜 객체(Dummy, 기능 구현이 없음)을 이용해 실제로 동작하는 것처럼 보이게 만드는 객체입니다.
- 해당 인터페이스나 클래스를 최소한으로 구현합니다.
- 테스트에서 호출된 요청에 대해 미리 준비해둔답변을 응답합니다.
- 테스트시에 프로그래밍된 것 외에는 응답하지 않습니다.
- 협력 객체의 특정 부분이 테스트가 어려운 경우, stub을 사용하여 수월하게 테스트할 수 있습니다.

### **Stub's Lifecycle**

- Setup, 테스트 준비
- Exercise, 테스트
- Verify state, 상태 검증
- Teardown, 리소스 정리

### **Mock**

- 호출에 대한 기대를 명세하고, 내용에 따라 동작하도록 프로그래밍 된 객체입니다.
- 테스트 작성을 위한 환경 구축이 어려울 때, 테스트하고자 하는 코드와 엮인 객ㅊ들을 대신하기 위해 만들어진 객체입니다.
- 행위 검증을 진행합니다.

### **Mock's Lifecycle**

- Setup data, 데이터 준비
- Setup expectations, 예상되는 결과 준비
- Exercise, 테스트
- Verify expectations, 예상 검증
- Verify state, 상태 검증
- Teardown, 리소스 정리

### **Stub과 Mock의 차이**

- **stub**을 포함한 다른 대역들은 **상태 검증(state verification)** 을 사용하고 **Mock** 오브젝트는 **행위 검증(behavior verification)** 을 사용합니다.
    - `상태 검증`이란 메소드가 수행된 후, 객체의 상태를 확인하여 올바르게 동작했는지를 확인하는 검증법입니다.
    - `행위 검증`이란 메소드의 리턴 값으로 판단할 수 없는 경우, 특정 동작을 수행하는지 확인하는 검증법입니다.
- 검증의 대상이 다르다는 것이 중요한 체크 요소입니다.

### SpringBoot 계층별 테스트 방법

**Domain**

- 순수한 Domain 로직은 JUnit 나 AssertJ 등 테스트 편의 도구 외에 다른 프레임워크의 도움이 필요하지 않다.

**Repository**

- 저장 및 조회와 관련된 Repository 테스트는 JPA의 도움이 필요하므로 `@DataJpaTest` 슬라이스 테스트를 활용한다.
- `@DataJpaTest` 테스트는 저장을 위한 JPA 연관 관계가 적절히 구성되었는지, Repository 메서드가 제대로 구현되었는지 확인하는 것이 목적이다.
- 먼저 JPA 관련 애노테이션 없이 코드를 작성해서 저장에 실패하는 테스트 코드를 먼저 작성하고,
- JPA 규칙에 맞는 애노테이션을 추가해서 테스트 코드를 통과시킨다.

**Service**

- 서비스 레이어는 데이터의 CRUD를 Repository에 위임하고 트랜잭션을 관리하는 것이 주요 책임이다.
    - JPA를 사용한다면 DTO <-> Entity 간 변환도 서비스 레이어에서 처리하는 것을 선호한다. 이유는 이 변환을 컨트롤러 레이어에서 수행한다면 Lazy 조회 시 LazyInitializationException이 발생할 위험에 노출되기 때문이다.
    - 물론 이 경우에도 실제 DTO <-> Entity 간 변환 로직 자체는 DTO에 담고, 서비스 레이어에서는 DTO의 변환 로직을 호출할 뿐이다.
- Repository의 동작은 위의 Repository 테스트에서 이미 확인했으므로, 서비스 레이어에서는 Repository 메서드가 제대로 호출되는지만 확인하면 되므로 실제 Repository 대신 Mock Repository를 사용하면 된다. 따라서 Mockito 필요
    - 필요하다면 `@SpringBootTest(classes = {A.class, B.class, ...})`도 사용 가능하다.
- Mock을 사용하므로 실제 저장/조회가 발생하지 않는다.
- 생성, 삭제, 조회 시에는 생성/삭제/조회를 호출하는 메서드 호출 여부를 verify 하면 된다.
- 수정 시에는 명시적으로 `save()`나 `saveAndFlush()`가 호출되지 않을 수도 있으므로 verify 로는 테스트가 불가능하므로 Mock 에 사용되는 엔티티나 DTO의 상태 변경을 assert 한다.
- Mock에 사용되는 엔티티나 DTO를 생성하는 부분이 매우 번거로울 수 있다.

**Controller**

- 컨트롤러는 넓게 보면 사용자가 보낸 요청을 서비스에 전달하기까지 모든 과정을 포괄한다고 볼 수 있지만, 필터, 인터셉터, 요청 라우팅, 보안(인증, 인가), 데이터 validation, 데이터 바인딩 등은 스프링 프레임워크에서 담당해주므로 컨트롤러가 실제로 담당하는 부분은 이를 모두 통과한 후의 요청 데이터를 서비스에 전달해주고, 서비스가 반환하는 결과를 클라이언트에게 반환하는 부분이다.
- 따라서 컨트롤러의 로직이 많지 않은 경우 서비스를 Mock 해서 컨트롤러 레이어만을 단위 테스트하는 것은 효용이 크지 않을 수 있으므로, 컨트롤러 테스트는 보통 Mock 대신 실제 서비스 및 도메인 계층을 대상으로 통합 테스트로 작성하는 편이 낫다.

### 테스트 커버리지

## 테스트 커버리지, 코드 커버리지

테스트 커버리지란 시스템 및 소프트웨어에 대해 충분히 테스트가 되었는지를 나타내는 정도이다. 수행한 테스트가 얼마나 테스트 대상을 커버했는지를 나타낸다.

코드 커버리지란 테스트에 의해 실행된 소스 코드의 양을 나타낸 것이다. 즉, 테스트로 코드가 얼마나 covered되었는지 나타내는 것이다. 소스 코드를 기반으로 수행하는 화이트 박스 테스트를 통해 측정된다. 퍼센트 (%)단위로 표시되는데, 커버리지가 100%라고 해서 버그없는 소프트웨어를 보장할수는 없다.

## 코드 커버리지 기준

### 구문 커버리지 (Statement Coverage)

라인 커버리지라고도 하며 코드 한줄이 한 번 이상 실행된다면 충족된다.

```python
def foo(a: int):
	print("--function starts--")	# 1번
    if a > 0:	# 2번
    	a //= 2	# 3번
	print("--function ends--")	# 4번
```

조건에 따른 모든 로직을 확인하기 보다는 모든 코드가 실행되었는지를 확인한다. 위 예시 코드의 경우 `a`가 음수이면 if문 내부 로직은 실행되지 않기 때문에 4개의 구문 중 3개의 구문만 실행되어 커버리지는 `3 / 4 * 100 = 75(%)`가 된다.

### 결정 커버리지 (Decision Coverage)

브랜치 커버리지라고도 하며 조건식이 True/False를 가지는 경우 충족된다.

```python
def foo(a: int, b: int):
	if a > 0 and b > 0:
    	 print("processing")
```

예를 들어 위 예시 코드와 같은 함수가 있다고 할때 `foo(1, 1)`, `foo(1,0)`의 경우 조건문에 대해 참/거짓을 만족하는 테스트이기 때문에 결정 커버리지를 만족한다.

### 조건 커버리지 (Condition Coverage)

모든 내부 조건에 대해 True/False를 가지게 되면 충족된다.

```python
def foo(a: int, b: int):
	if a > 0 and b > 0:
    	 print("processing")
```

내부 조건이란 if문 내부의 모든 조건들을 의미한다. 예시 코드에서는 `a>0` , `b>0`가 내부 조건이 되며 각각에 대해 True/False를 가지는 테스트가 있다면 충족된다.

예를 들어 테스트 케이스가 `foo(1, 0)`, `foo(0, 1)` 일 때 `a>0`, `b>0` 모두의 내부조건에 대해 True/False 케이스가 존재하므로 조건 커버리지를 만족한다. 하지만 `a>0 and b>0` 의 조건에서는 False이므로 조건문 내부의 코드는 테스트하지 못한다. 이처럼 조건 커버리지를 만족한다고 해도 구문 커버리지 또는 결정 커버리지를 만족하지 못할 수 있다.

## 대중적인 코드 커버리지 기준

위 세 가지의 코드 커버리지 기준 중에 가장 많이 사용되는 것은 구문 커버리지이다.

조건 커버리지와 결정 커버리지의 경우 조건문을 만족한다면 코드 커버리지를 만족하기 때문에 만약 조건문이 존재하지 않는 코드의 경우 커버리지의 대상에서 제외해버려 테스트를 하지 않는다.

구문 커버리지의 경우 조건식에 따라 실행되지 않는 코드들도 있기 때문에 모든 시나리오에 대해 테스트한다는 보장은 없지만 전체 코드에 대한 테스트가 커버되었다고는 할 수 있다. 따라서 라인 커버리지를 더 많이 사용한다고 한다.

### Jacoco

Jacoco는 자바 진영에서 프로젝트의 코드 커버리지를 분석하고, 보고서를 만들어주는 역할을 하는 코드 커버리지 프레임워크입니다

### ref

- 프록시 : https://woo-chang.tistory.com/28
- 고아객체 : [https://velog.io/@syleemk/JPA-영속성-전이와-고아-객체](https://velog.io/@syleemk/JPA-%EC%98%81%EC%86%8D%EC%84%B1-%EC%A0%84%EC%9D%B4%EC%99%80-%EA%B3%A0%EC%95%84-%EA%B0%9D%EC%B2%B4)
- 연관관계의 주인 : https://jiwondev.tistory.com/227#head4, https://abcdefgh123123.tistory.com/472
- 연관관계 편의 메소드 : https://developer-rooney.tistory.com/223
- N + 1 : [https://velog.io/@jinyoungchoi95/JPA-모든-N1-발생-케이스과-해결책](https://velog.io/@jinyoungchoi95/JPA-%EB%AA%A8%EB%93%A0-N1-%EB%B0%9C%EC%83%9D-%EC%BC%80%EC%9D%B4%EC%8A%A4%EA%B3%BC-%ED%95%B4%EA%B2%B0%EC%B1%85)
- batch size : [https://velog.io/@balparang/JPA-컬렉션-엔티티와-페이징을-함께-사용하기-feat.-BatchSize#컬렉션-엔티티-조회-시-n1-문제-발생](https://velog.io/@balparang/JPA-%EC%BB%AC%EB%A0%89%EC%85%98-%EC%97%94%ED%8B%B0%ED%8B%B0%EC%99%80-%ED%8E%98%EC%9D%B4%EC%A7%95%EC%9D%84-%ED%95%A8%EA%BB%98-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-feat.-BatchSize#%EC%BB%AC%EB%A0%89%EC%85%98-%EC%97%94%ED%8B%B0%ED%8B%B0-%EC%A1%B0%ED%9A%8C-%EC%8B%9C-n1-%EB%AC%B8%EC%A0%9C-%EB%B0%9C%EC%83%9D)
- DDD : https://incheol-jung.gitbook.io/docs/q-and-a/architecture/ddd, https://happycloud-lee.tistory.com/94
- TDD : [https://inpa.tistory.com/entry/QA-📚-TDD-방법론-테스트-주도-개발](https://inpa.tistory.com/entry/QA-%F0%9F%93%9A-TDD-%EB%B0%A9%EB%B2%95%EB%A1%A0-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%A3%BC%EB%8F%84-%EA%B0%9C%EB%B0%9C)
- Junit : [https://velog.io/@gehwan96/Junit5-Junit4와의-비교-도입의-필요성](https://velog.io/@gehwan96/Junit5-Junit4%EC%99%80%EC%9D%98-%EB%B9%84%EA%B5%90-%EB%8F%84%EC%9E%85%EC%9D%98-%ED%95%84%EC%9A%94%EC%84%B1)
- 단위, 통합, 인수 테스트 : https://tecoble.techcourse.co.kr/post/2021-05-25-unit-test-vs-integration-test-vs-acceptance-test/
- stub, mock : https://azderica.github.io/00-test-mock-and-stub/
- SpringBoot 계층별 테스트 방법 : [https://github.com/HomoEfficio/dev-tips/blob/master/Spring-Boot-레이어별-테스트.md](https://github.com/HomoEfficio/dev-tips/blob/master/Spring-Boot-%EB%A0%88%EC%9D%B4%EC%96%B4%EB%B3%84-%ED%85%8C%EC%8A%A4%ED%8A%B8.md)
- 테스트 커버리지 : [https://velog.io/@newdana01/Test-테스트-커버리지-Test-Coverage](https://velog.io/@newdana01/Test-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BB%A4%EB%B2%84%EB%A6%AC%EC%A7%80-Test-Coverage)

## 질문 정리
### JPA에서 프록시 객체는 언제 사용하나요?

- 특정 엔티티 조회시 연관관계에 놓여있는 엔티티까지 조회하지 않기 위해 지연 로딩 사용
- 지연로딩을 구현하기 위해 연관관계에 놓여있는 엔티티는 프록시 객체로 생성

### 프록시 객체의 초기화 과정에 대해 설명해 주세요.

1. 실제 사용을 위해 메서드를 호출합니다.
2. 메서드가 호출되면 영속성 컨텍스트에 초기화를 요청합니다. 실제 엔티티 객체의 참조를 가지기 위해 실제 엔티티 객체의 생성이 필요합니다.
3. 영속성 컨텍스트는 데이터베이스를 조회해서 실제 엔티티 객체의 정보를 얻습니다.
4. 조회된 정보를 바탕으로 실제 Entity 객체를 생성합니다.
5. 참조를 통해 실제 엔티티 객체의 메서드를 호출합니다.
6. 메서드 호출의 결과를 반환합니다.

### 프록시 객체의 특징에 대해 설명해 주세요.

- 프록시 객체는 처음 사용할 때 한 번만 초기화됩니다.
- 프록시 객체의 초기화는 실제 엔티티 객체로의 변경을 의미하는 것이 아니라 실제 엔티티 객체의 참조를 가지는 것으로 이해할 수 있습니다.
- 프록시 객체는 원본 엔티티를 상속받은 객체이므로 타입 체크 시 주의해서 사용해야 합니다.
- 영속성 컨텍스트에 이미 존재한다면 데이터베이스 조회가 필요 없고 프록시 객체 사용 필요성이 없으므로 프록시 객체가 아닌 실제 엔티티 객체를 반환합니다.
    - 동일성 보장을 위해 먼저 나온 객체가 프록시 객체일 때 **`find`**를 사용하더라도 프록시 객체가 나올 수 있습니다.
- 초기화는 영속성 컨텍스트의 도움을 받아야 하기에 준영속 상태의 프록시를 초기화하면 문제가 발생합니다.

### 영속성 전이의 정의와 종류에 대해 설명해 주세요.

- 특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만들고 싶을 때 사용하는 옵션

### 종류

- **ALL : 모두 적용**
- **PERSIST : 영속**
- **REMOVE : 삭제**
- MERGE : 병합
- REFRESH : REFRESH
- DETACH : DETACH

### 고아객체의 정의와 필요성, 주의할 점에 대해 설명해 주세요.

- 부모 엔티티와 연관관계가 끊어진 자식 엔티티

**orphanRemoval**

- 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제

## 주의

- 참조가 제거된 엔티티는 다른 곳에서 참조하지 않는 고아객체로 보고 삭제하는 기능
- **참조하는 곳이 하나일 때 사용해야한다!**
    - 자식 객체가 부모가 두개 이상일 때, orphanRemoval = true로 설정하면
    - 하나의 부모와 관계가 끊어졌을 때 자식객체가 delete되어 다른 부모와의 관계가 없어져 버림.
- **특정 엔티티가 개인 소유할 때만 사용**
- @OneToMany, @OneToOne만 가능 : 참조하는 쪽이 하나인 경우만 사용

### 단방향/양방향 매핑에 대해 설명해 주세요.

### 단방향 매핑 (Undirectional Mapping)

- 한 엔티티가 다른 엔티티를 참조할 수 있지만, 반대 방향으로는 참조가 어렵다.
- 한쪽 방향에서만 관계를 관리할 수있다.
- 구현이 간단하고 명확하지만, 반대 방향으로의 참조가 필요한 경우에는 적합하지 않을 수 있다.

### 양방향 매핑 (Bidirectional Mapping)

- 양방향 매핑에서는 두 엔티티가 서로를 참조할 수 있다.
- 한쪽 엔티티에서 변경이 발생하면 관련 엔티티도 해당 변경을 인식할 수 있다.
- 단방향 매핑에 비해서 복잡하고 관리해야 하는 영역이 많지만, 양쪽 엔티티간의 관계를 유연하게 관리할 수 있는 장점이 존재.

### 연관관계의 주인이 무엇인가요?

- 두 단방향관계 (A->B, B->A)를 맺을 때, 이 중 제어의 권한(데이터 조회, 저장, 수정, 삭제)를 갖는실질적인 관계가 무엇인지 JPA에게 알리는 것
- 외래 키가 있는 곳을 주인으로 정해야한다.

### 연관관계의 주인이 필요한 이유는 무엇인가요?

1. 패러다임의 차이

예를 들어 (Member, Team)이 있고 양방향 연관 관계를 갖는다고 해보자. 이 상황에서 Member를 다른 Team으로 수정하려고 할 때 Member 객체에서 setTeam() 같은 메서드로 수정해야하는지, Team 객체에서 getMemberList()로 List형식으로 들어와있는 member List 객체를 꺼내 수정해야하는지의 문제가 발생한다. 객체 패러다임에서는 두 방식 다 옳지만, 데이터베이스의 패러다임을 적용하려고 존재하는 JPA 입장에서 혼란스러워진다는 것이다.즉, 연관관계의 주인이 있어야 객체 패러다임에서의 양방향 관계가 데이터베이스 패러다임에서 연관관계가 하나임을 보장할 수 있게 된다.

2. 영속성 컨텍스트 변경감지기준

예를들어 member.setTeam(), team.getMemberlist().addMember() 등을 모두 허용하게 되면 영속성 컨텍스트가 너무 복잡해지게 된다. 경우에 따라 하나의 수정이지만, update 쿼리가 두번 나가게 될 수도 있고(양쪽 연관관계를 모두 업데이트 해버리는 경우), 이를 최적화하기 위한 추가적인 연산도 많아진다. 또한 양쪽 연관관계가 모순되는 경우 어떻게 처리할지에 대한 규약도 훨씬 복잡해진다.(team.memberLis에는 member1이 있는데, member1.setTeam(null)인 경우에 어떤 쪽을 따라야하는가?)

### 다대일 관계에서 연관관계의 주인을 일로 설정하면 무엇이 문제될까요?

- 외래키의 반대쪽(다대일에서 일의 위치)을 주인으로 정하게 되면, 다음과 같은 문제가 생긴다.
    - 하나의 팀은 여러 Member를 가진다. 만약 Team을 수정하게되면 모든 members에게 DB 쿼리가 발생하게 된다.
    - Member에서 외래키를 가지고 있지 않기때문에, Member가 스스로 Team을 변경할 수 없게 되버린다.

### 연관관계 편의 메소드의 정의와 필요성에 대해 설명해 주세요.

- 양방향 연관관계를 한 번에 설정하기 위해 작성하는 메서드

### 필요성

- 연관관계의 주인을 통해 연관관계를 맺기만 해도 양방향으로 사용이 가능하지만, 연관관계 설정 이후에 한 트랜잭션에서 조회가 제대로 되지 않으므로.
- 코드 중복을 방지하고 양방향 연관 관계 매핑에서 한쪽에만 연관 관계가 설정되는 것을 방지할 수 있습니다.

### N+1문제에 대해서 설명해 주시고, 해결방법에 대해 설명해 주세요.

- 연관 관계가 설정된 엔티티를 조회할 경우에 조회된 데이터 갯수(n) 만큼 연관관계의 조회 쿼리가 추가로 발생하여 데이터를 읽어오는 문제.

### 해결책

1. Fetch Join

```
@Query("select distinct u from User u left join fetch u.articles")
List<User> findAllJPQLFetch();
```

- JPQL로 fetch join을 작성하여 연관관계에 놓여있는 엔티티들을 즉시로딩한다.
- 단점
    - distinct 작업을 하기 위해 쿼리 결과를 전부 메모리에 적재한 뒤 Pagination 작업을 어플리케이션 레벨에서 하기 때문에 offset, limit절 사용 의미가 없다.
    - 따라서 distinct작업이 없도록 ManyToOne 관계에서 fetch join을 사용한다.(그러면 offset, limit절을 정상사용 가능하다.)
1. @EntityGraph
- JPQL없이 페치 조인을 사용할 수 있다.
- 단점
    - 페치 조인과 다르게 inner join ( 교집합 ) 이 아닌, left outer join ( 왼쪽 기준으로 합집합 )을 사용한다.
    - 페치 조인과 같이 메모리에서 페이징 처리를 하기 때문에 페이지네이션의 의미가 없어진다.
1. Batch Size
- 연관된 엔티티 조회 시 지정한 size 만큼 `IN` 쿼리를 사용하여 조회하고, (지연로딩 사용 시) 조회한 다음 엔티티의 정보가 필요한 시점에 추가 in 쿼리를 size만큼 또 날린다.
- `size`는 IN절에 올수있는 최대 인자 개수를 말한다.
- 기존에는
    - Place 를 조회하는 쿼리 1개
    - 조회된 N개의 Place에 대해 연관된 엔티티를 조회하는 쿼리 N개

  로 인해 N+1 문제가 발생했다면, @BatchSize를 적용한 후에는

    - Place 를 조회하는 쿼리 1개 (Place가 N개 조회된다.)
    - 조회된 Place N개와 연관된 컬렉션 엔티티를 조회하는 `IN` 쿼리 1개

  의 쿼리가 실행된다. 즉, `1 + N` 번 실행 되었던 쿼리가 `1 + 1`번 실행됨으로써 N+1 문제를 해결한 것이다.

- 데이터의 전체 row를 예상할 수 있는 범위에서는 좋은 방안이긴 하나 정확한 Size를 알수 없을때는 적정값을 설정해 주긴 어렵습니다.

### fetch join, @Entitygraph의 단점에 대해 설명해 주세요.

- 메모리에서 페이징 처리를 하기 때문에 페이지네이션의 의미가 없어진다.

### DDD, TDD의 정의에 대해 설명해 주세요.

DDD(Domain-Driven Design) : 도메인 주도 설계라고 부른다. **도메인 패턴**을 중심에 놓고 설계하는 방식을 일컫는다.

TDD : 반복 테스트를 이용한 소프트웨어 방법론으로,작은 단위의 테스트 케이스를 작성하고 이를 통과하는 코드를 추가하는 단계를 반복하여 구현

### TDD의 진행과정에 대해 설명해 주세요.

- Red단계에서는 실패하는 테스트 코드를 먼저 작성한다.
- Green단계에서는 테스트 코드를 성공시키기 위한 실제 코드를 작성한다.
- Blue단계에서는 중복 코드 제거, 일반화 등의 리팩토링을 수행한다.

### TDD의 장단점에 대해 설명해 주세요.

### 장점

1. 디버깅 시간을 단축 할 수 있다. 이는 유닛 테스팅을 하는 이점이기도 하다. 예를 들면 사용자의 데이터가 잘못 나온다면 DB의 문제인지, 비즈니스 레이어의 문제인지 UI의 문제인지 실제 모든 레이어들을 전부 디버깅 해야하지만, TDD의 경우 자동화 된 유닛테스팅을 전재하므로 특정 버그를 손 쉽게 찾아낼 수 있다.
2. 코드가 내 손을 벗어나기 전에가장 빠르게 피드백 받을 수 있다. 개발 프로세스에서는 보통 ‘인수 테스트’를 한다. 이미 배치된 시스템을 대상으로 클라이언트가 의뢰한 소프트웨어가 사용자 관점에서 사용할 수 있는 수준인지 체크하는 과정이다. 이미 90% 이상 완성된 코드를 가지고 테스트하기 때문에,문제를 발견해도, 정확하게 원인이 무엇인지 진단하기는 힘들다. 하지만 TDD를 사용하면 기능 단위로 테스트를 진행하기 때문에 코드가 모두 완성되어 프로그래머의 손을 떠나기 전에 피드백을 받는 것이 가능하다.
3. 작성한 코드가 가지는 불안정성을 개선하여 생산성을 높일 수 있다. 켄트 백은 TDD는 불안함을 지루함으로 바꾸는 마법의 돌이라고 말했다. 앞서 말한 것처럼 TDD를 사용하면, 코드가 내 손을 떠나 사용자에게 도달하기 전에 문제가 없는지 먼저 진단 받을 수 있다. 그러므로 코드가 지닌 불안정성과 불확실성을 지속적으로 해소해준다.
4. 재설계 시간을 단축 할 수 있다.테스트 코드를 먼저 작성하기 때문에 개발자가 지금 무엇을 해야하는지 분명히 정의하고 개발을 시작하게 된다. 또한 테스트 시나리오를 작성하면서 다양한 예외사항에 대해 생각해볼 수 있다.이는 개발 진행 중 소프트웨어의 전반적인 설계가 변경되는 일을 방지할 수 있다.
5. 추가 구현이 용이하다. 개발이 완료된 소프트웨어에어떤 기능을 추가할 때 가장 우려되는 점은 해당 기능이기존 코드에 어떤 영향을 미칠지 알지 못한다는 것이다. 하지만 TDD의 경우 자동화된 유닛 테스팅을 전제하므로 테스트 기간을 획기적으로 단축시킬 수 있다.

### 단점

1. 가장 큰 단점은 바로 생산성의 저하이다. 개발 속도가 느려진다고 생각하는 사람이 많기 때문에 TDD에 대해 반신반의 한다.
   왜냐하면 처음부터 2개의 코드를 짜야하고, 중간중간 테스트를 하면서 고쳐나가야 하기 때문이다.
   TDD 방식의 개발 시간은 일반적인 개발 방식에 비해 대략 10~30% 정도로 늘어난다.
   SI 프로젝트에서는 소프트웨어의 품질보다 납기일 준수가 훨씬 중요하기 때문에 TDD 방식을 잘 사용하지 않는다.
2. 이제까지 자신이 개발하던 방식을 많이 바꿔야 한다. 몸에 체득한 것이 많을 수록 바꾸기가 어렵다. 오히려 개발을 별로 해보지 않은 사람들에겐 적용하기가 쉽다.
3. 구조에 얽매인다. TDD로 프로젝트를 진행하면서 어려운 예외가 생길 수 있는데 그것 때문에 고민하는 순간이 찾아오게 된다.원칙을 깰 수는 없고 꼼수가 있기는 한데 그 꼼수를 위해서 구조를 바꾸자니 이건 아무래도 아닌 것 같고, 테스트는 말 그대로 테스트일 뿐 실제 코드가 더 중요한 상황인데도 불구하고 테스트 원칙 때문에 쉽게 넘어가지 못하는 그런 경우다.

### Junit4와 Junit5를 비교해 주세요.

### Junit4

- ***vintage-engine***
- @Test 어노테이션을 이용한 테스트 메소드 지정
- @Before, @After, @BeforeClass, @AfterClass 어노테이션을 사용한 테스트의 전처리 및 후처리 작업 지정
- @Ignore 어노테이션을 사용한 테스트 무시
- assert 메소드를 통한 테스트 검증
- 예외 테스트를 위해 @Test(expected= Exception.class) 사용

### Junit5

- ***jupiter-engine***
- @ExtendWith를 통한 더 유연한 확장 모델 제공
- 람다를 사용한 동적 테스트생성 지원
- @DisplayName 어노테이션으로 테스트 이름을 직관적으로 표현
- @Tag를 사용한 테스트 필터링
- @Nested를 사용한 중첩된 테스트 클래스 지원
- @ParameterizedTest를 사용한 파라미터화 된 테스트 지원
- assertThrows를 이용한 예외 테스트개선
- 다양한 assert 메소드 제공

## **JUnit5 모듈 구성**

JUnit5는 이전버전과 달리 크게 3개의 서브 프로젝트로 구성된 복수의 모듈로 구성되어 있습니다. 또한 각각의 프로젝트는 용도에 따라서 몇개의 서브 모듈로 구성되어 있습니다.

### **JUnit Platform**

JUnit 테스트를 실행하기 위한 기반이 되는 모듈입니다. Gradle, Maven과 같은 빌드툴은 물론 IDE를 위한 모듈도 각각 존재합니다. Platform이 제공하는 `TestEngine`을 구현한 모듈을 찾아서 실행해준다고 보면 될 것 같습니다.

JVM에서 동작하는 테스트 프레임워크입니다. 테스트를 발견하고 계획을 생성하고 결과를 보고하는 TestEngine 인터페이스를 정의합니다.

### **JUnit Jupiter**

테스트를 기술하기 위한 프로그램, 확장 모델들이 담겨있는 모듈입니다. 엄밀한 의미에서는 맞지않겠지만 흔히 JUnit5라고 언급할 경우에 이 모듈을 지칭한다고 생각하시면 될 듯 합니다.

### **JUnit Vintage**

JUnit의 3, 4 버전을 실행하기 위한 `TestEngine`을 제공하는 모듈입니다. 이 모듈을 통해서 JUnit5와 병행 사용이 가능합니다. TestEngine에서 Junit3 및 Junit4 기반 테스트를 실행하기 위한 기능을 제공합니다.

제가 제일 궁금했던 어노테이션의 차이는 @ExtendWith입니다. 왜냐 @AutoMockMvc와 같이사용해야 MockMvc를 사용할수있었기떄문입니다.

@ExtendWith 애노테이션은 JUnit5에서 확장 기능을 실행할 때 사용한다.

SpringExtension은 JUnit5를 위한 스프링 확장 기능으로 스프링 연동 테스트를 실행할 수 있게 한다.

그런데 @SpringBootTest에 들어있기때문에 안사용해도된다.

### 플랫폼 제공

Junit4에서는 plugin과 ide의 통합 지원이 없었기 때문에 reflection에 의존해야만 했습니다.

Junit5 부터는 JUnit Platform이라는 테스트코드 통합 지원 플랫폼이 제공되어 테스트 코드 실행이 해당 플랫폼 위에서 수행됩니다.

### 단위, 통합, 인수테스트에 대해 설명해 주세요.

### **단위 테스트(Unit Test)**

> 단위 테스트는 응용 프로그램에서 테스트 가능한 가장 작은 소프트웨어를 실행하여 예상대로 동작하는지 확인하는 테스트이다.
>

단위 테스트에서 테스트 대상 단위의 크기는 엄격하게 정해져 있지 않다. 하지만, 일반적으로 클래스 또는 메소드 수준으로 정해진다. 단위의 크기가 작을수록 단위의 복잡성이 낮아진다. 따라서, 단위 테스트를 활용하여 동작을 표현하기 더 쉬워진다. 즉, 테스트 대상 단위의 크기를 작게 설정해서 단위 테스트를 최대한 간단하고 디버깅하기 쉽게 작성해야 한다.

소프트웨어를 개발할 때, 소프트웨어 내부 구조나 구현 방법을 고려하여 개발자 관점에서 테스트한다. 그러므로 단위 테스트는 소프트웨어 내부 코드에 관련한 지식을 반드시 알고 있어야 하는 화이트박스 테스트이다. 단위 테스트는 TDD와 함께 할 때 특히 더 강력해진다.

프로그래밍 언어마다 단위 테스트에서 사용하는 프레임워크가 다르다. Java는 주로 `JUnit`으로 테스트한다.

### **통합 테스트(Integration Test)**

> 통합 테스트는 단위 테스트보다 더 큰 동작을 달성하기 위해 여러 모듈들을 모아 이들이 의도대로 협력하는지 확인하는 테스트이다.
>

통합 테스트는 단위 테스트와 달리 개발자가 변경할 수 없는 부분(ex. 외부 라이브러리)까지 묶어 검증할 때 사용한다. 이는 DB에 접근하거나 전체 코드와 다양한 환경이 제대로 작동하는지 확인하는데 필요한 모든 작업을 수행할 수 있다. 그러나, 통합 테스트가 응용 프로그램이 완전하게 작동하는 걸 무조건 증명하지는 않는다.

통합 테스트의 장점은 단위 테스트에서 발견하기 어려운 버그를 찾을 수 있다는 점이다. 예를 들어, 통합 테스트에서는 환경 버그(ex. 싱글 코어 CPU에서는 잘 실행되나 쿼드 코어 CPU에서는 잘 실행되지 않음)이 발생할 수 있다.

한편, 통합 테스트의 단점은 단위 테스트보다 더 많은 코드를 테스트하기 때문에 신뢰성이 떨어질 수 있다는 점이다. 또, 어디서 에러가 발생했는지 확인하기 쉽지 않아 유지보수하기 힘들다는 점도 있다.

스프링부트에서는 클래스 상단에 `@SpringBootTest` 어노테이션을 붙여 통합 테스트를 수행할 수 있다.

### **인수 테스트(Acceptance Test)**

> 인수 테스트는 사용자 스토리(시나리오)에 맞춰 수행하는 테스트이다.
>

앞선 두 테스트들과 달리 비즈니스 쪽에 초점을 둔다. 프로젝트에 참여하는 사람들(ex. 기획자, 클라이언트 대표, 개발자 등)이 토의해서 시나리오를 만들고, 개발자는 이에 의거해서 코드를 작성한다. 개발자가 직접 시나리오를 제작할 수도 있지만, `다른 의사소통집단으로부터 시나리오를 받아(인수) 개발한다`는 의미를 가지고 있다.

인수 테스트는 애자일 개발 방법론에서 파생했다. 특히, 익스트림 프로그래밍(XP)에서 사용하는 용어이다. 이는 시나리오가 정상적으로 동작하는지를 테스트하기 때문에 통합 테스트와는 분류가 다르다. 시나리오에서 요구하는 것은 `누가, 어떤 목적으로, 무엇을 하는가`이다. 개발을 하다 보면 이런 기능은 API를 통해 드러난다. 인수 테스트는 주로 이 API를 확인하는 방식으로 이뤄진다.

결국, 인수 테스트는 소프트웨어 인수를 목적으로 하는 테스트이다. 소프트웨어를 인수하기 전에 명세한 요구사항(인수 조건)대로 잘 작동하는지 검증이 필요하다.

소프트웨어를 인수할 때, 소프트웨어 내부 구조나 구현 방법을 고려하기보다는 실제 사용자 관점에서 테스트하는 경우가 많다. 따라서, 인수 테스트는 소프트웨어 내부 코드에 관심을 가지지 않는 블랙박스 테스트이다. 실제 사용자 관점에서 테스트할 때 주로 E2E(End-to-End) 형식을 이용해서 확인한다.

Java에서는 `RestAssured`, `MockMvc` 같은 도구를 활용하여 인수 테스트를 작성할 수 있다.

### Mock, Stub에 대해 설명해 주세요.

### **Stub**

- 인스턴스화하여 구현한 가짜 객체(Dummy, 기능 구현이 없음)을 이용해 실제로 동작하는 것처럼 보이게 만드는 객체입니다.
- 해당 인터페이스나 클래스를 최소한으로 구현합니다.
- 테스트에서 호출된 요청에 대해 미리 준비해둔답변을 응답합니다.
- 테스트시에 프로그래밍된 것 외에는 응답하지 않습니다.
- 협력 객체의 특정 부분이 테스트가 어려운 경우, stub을 사용하여 수월하게 테스트할 수 있습니다.

### **Mock**

- 호출에 대한 기대를 명세하고, 내용에 따라 동작하도록 프로그래밍 된 객체입니다.
- 테스트 작성을 위한 환경 구축이 어려울 때, 테스트하고자 하는 코드와 엮인 객ㅊ들을 대신하기 위해 만들어진 객체입니다.
- 행위 검증을 진행합니다.

### Mock, Stub의 차이점에 대해 설명해 주세요.

- **stub**을 포함한 다른 대역들은 **상태 검증(state verification)** 을 사용하고 **Mock** 오브젝트는 **행위 검증(behavior verification)** 을 사용합니다.
    - `상태 검증`이란 메소드가 수행된 후, 객체의 상태를 확인하여 올바르게 동작했는지를 확인하는 검증법입니다.
    - `행위 검증`이란 메소드의 리턴 값으로 판단할 수 없는 경우, 특정 동작을 수행하는지 확인하는 검증법입니다.
- 검증의 대상이 다르다는 것이 중요한 체크 요소입니다.

### SpringBoot 계층별 테스트 방법에 대해 설명해 주세요.

**Domain**

- 순수한 Domain 로직은 JUnit 나 AssertJ 등 테스트 편의 도구 외에 다른 프레임워크의 도움이 필요하지 않다.

**Repository**

- 저장 및 조회와 관련된 Repository 테스트는 JPA의 도움이 필요하므로 `@DataJpaTest` 슬라이스 테스트를 활용한다.
- `@DataJpaTest` 테스트는 저장을 위한 JPA 연관 관계가 적절히 구성되었는지, Repository 메서드가 제대로 구현되었는지 확인하는 것이 목적이다.
- 먼저 JPA 관련 애노테이션 없이 코드를 작성해서 저장에 실패하는 테스트 코드를 먼저 작성하고,
- JPA 규칙에 맞는 애노테이션을 추가해서 테스트 코드를 통과시킨다.

**Service**

- 서비스 레이어는 데이터의 CRUD를 Repository에 위임하고 트랜잭션을 관리하는 것이 주요 책임이다.
    - JPA를 사용한다면 DTO <-> Entity 간 변환도 서비스 레이어에서 처리하는 것을 선호한다. 이유는 이 변환을 컨트롤러 레이어에서 수행한다면 Lazy 조회 시 LazyInitializationException이 발생할 위험에 노출되기 때문이다.
    - 물론 이 경우에도 실제 DTO <-> Entity 간 변환 로직 자체는 DTO에 담고, 서비스 레이어에서는 DTO의 변환 로직을 호출할 뿐이다.
- Repository의 동작은 위의 Repository 테스트에서 이미 확인했으므로, 서비스 레이어에서는 Repository 메서드가 제대로 호출되는지만 확인하면 되므로 실제 Repository 대신 Mock Repository를 사용하면 된다. 따라서 Mockito 필요
    - 필요하다면 `@SpringBootTest(classes = {A.class, B.class, ...})`도 사용 가능하다.
- Mock을 사용하므로 실제 저장/조회가 발생하지 않는다.
- 생성, 삭제, 조회 시에는 생성/삭제/조회를 호출하는 메서드 호출 여부를 verify 하면 된다.
- 수정 시에는 명시적으로 `save()`나 `saveAndFlush()`가 호출되지 않을 수도 있으므로 verify 로는 테스트가 불가능하므로 Mock 에 사용되는 엔티티나 DTO의 상태 변경을 assert 한다.
- Mock에 사용되는 엔티티나 DTO를 생성하는 부분이 매우 번거로울 수 있다.

**Controller**

- 컨트롤러는 넓게 보면 사용자가 보낸 요청을 서비스에 전달하기까지 모든 과정을 포괄한다고 볼 수 있지만, 필터, 인터셉터, 요청 라우팅, 보안(인증, 인가), 데이터 validation, 데이터 바인딩 등은 스프링 프레임워크에서 담당해주므로 컨트롤러가 실제로 담당하는 부분은 이를 모두 통과한 후의 요청 데이터를 서비스에 전달해주고, 서비스가 반환하는 결과를 클라이언트에게 반환하는 부분이다.
- 따라서 컨트롤러의 로직이 많지 않은 경우 서비스를 Mock 해서 컨트롤러 레이어만을 단위 테스트하는 것은 효용이 크지 않을 수 있으므로, 컨트롤러 테스트는 보통 Mock 대신 실제 서비스 및 도메인 계층을 대상으로 통합 테스트로 작성하는 편이 낫다.

### 테스트 커버리지, 코드 커버리지에 대해 설명해 주세요.

테스트 커버리지란 시스템 및 소프트웨어에 대해 충분히 테스트가 되었는지를 나타내는 정도이다. 수행한 테스트가 얼마나 테스트 대상을 커버했는지를 나타낸다.

코드 커버리지란 테스트에 의해 실행된 소스 코드의 양을 나타낸 것이다. 즉, 테스트로 코드가 얼마나 covered되었는지 나타내는 것이다. 소스 코드를 기반으로 수행하는 화이트 박스 테스트를 통해 측정된다. 퍼센트 (%)단위로 표시되는데, 커버리지가 100%라고 해서 버그없는 소프트웨어를 보장할수는 없다.

### 코드 커버리지의 3가지 기준에 대해 설명해 주세요.

### 구문 커버리지 (Statement Coverage)

라인 커버리지라고도 하며 코드 한줄이 한 번 이상 실행된다면 충족된다.

```python
def foo(a: int):
	print("--function starts--")	# 1번
    if a > 0:	# 2번
    	a //= 2	# 3번
	print("--function ends--")	# 4번
```

조건에 따른 모든 로직을 확인하기 보다는 모든 코드가 실행되었는지를 확인한다. 위 예시 코드의 경우 `a`가 음수이면 if문 내부 로직은 실행되지 않기 때문에 4개의 구문 중 3개의 구문만 실행되어 커버리지는 `3 / 4 * 100 = 75(%)`가 된다.

### 결정 커버리지 (Decision Coverage)

브랜치 커버리지라고도 하며 조건식이 True/False를 가지는 경우 충족된다.

```python
def foo(a: int, b: int):
	if a > 0 and b > 0:
    	 print("processing")
```

예를 들어 위 예시 코드와 같은 함수가 있다고 할때 `foo(1, 1)`, `foo(1,0)`의 경우 조건문에 대해 참/거짓을 만족하는 테스트이기 때문에 결정 커버리지를 만족한다.

### 조건 커버리지 (Condition Coverage)

모든 내부 조건에 대해 True/False를 가지게 되면 충족된다.

```python
def foo(a: int, b: int):
	if a > 0 and b > 0:
    	 print("processing")
```

내부 조건이란 if문 내부의 모든 조건들을 의미한다. 예시 코드에서는 `a>0` , `b>0`가 내부 조건이 되며 각각에 대해 True/False를 가지는 테스트가 있다면 충족된다.

예를 들어 테스트 케이스가 `foo(1, 0)`, `foo(0, 1)` 일 때 `a>0`, `b>0` 모두의 내부조건에 대해 True/False 케이스가 존재하므로 조건 커버리지를 만족한다. 하지만 `a>0 and b>0` 의 조건에서는 False이므로 조건문 내부의 코드는 테스트하지 못한다. 이처럼 조건 커버리지를 만족한다고 해도 구문 커버리지 또는 결정 커버리지를 만족하지 못할 수 있다.

### Jacoco가 무엇인가요?

Jacoco는 자바 진영에서 프로젝트의 코드 커버리지를 분석하고, 보고서를 만들어주는 역할을 하는 코드 커버리지 프레임워크입니다
