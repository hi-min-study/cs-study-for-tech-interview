# 📍 키워드
- JPA
    - 프록시
        - https://tecoble.techcourse.co.kr/post/2022-10-17-jpa-hibernate-proxy/
    - 고아객체
        - https://hongchangsub.com/jpa-cascade-2/
    - 단뱡향/양방향 매핑
    - N + 1 문제
        - https://incheol-jung.gitbook.io/docs/q-and-a/spring/n+1
        - https://velog.io/@xogml951/JPA-N1-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%B4%9D%EC%A0%95%EB%A6%AC
- 테스트
    - DDD, TDD
    - Junit4 vs Junit5
        - https://www.geeksforgeeks.org/junit-5-vs-junit-4/
        - https://dev-handbook.tistory.com/54
    - 단위, 통합, 인수 테스트
        - https://tecoble.techcourse.co.kr/post/2021-05-25-unit-test-vs-integration-test-vs-acceptance-test/
    - stub, mock
        - https://medium.com/daangn/%ED%9A%A8%EC%9C%A8%EC%A0%81%EC%9D%B8-%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%A5%BC-%EC%9C%84%ED%95%9C-stub-%EA%B0%9D%EC%B2%B4-%ED%99%9C%EC%9A%A9%EB%B2%95-5c52a447dfb7
    - SpringBoot 계층별 테스트 방법
    - 테스트 커버리지 (JACOCO)

<br>

# 📍 예상 질문
## 1️⃣ JPA
<details>
<summary>JPA에서 프록시 객체의 역할과 어떻게 작동하는지 설명해주세요.</summary>
<div markdown="1">

- JPA에서 프록시 객체를 통해 지연 로딩을 구현하고 있습니다. 하이버네이트는 지연 로딩을 사용하는 연관관계 자리에 프록시 객체를 주입하여 실제 객체가 들어있는 것처럼 동작하도록 합니다. 덕분에 우리는 연관관계 자리에 프록시 객체가 들어있든 실제 객체가 들어있든 신경쓰지 않고 사용할 수 있습니다.
- 프록시 객체는 실제 객체에 대한 참조를 보관하여, 프록시 객체의 메서드를 호출했을 때 실제 객체의 메서드를 호출합니다. 프록시 객체는 최초 지연 로딩 시점에는 참조 값이 없고, 실제 객체의 메서드를 호출할 필요가 있을 때 데이터베이스를 조회해서 참조 값을 채우며, 이를 프록시 객체 초기화라고 부릅니다.

</div>
</details>
<details>
<summary>JPA에서 프록시 객체를 사용할 때 주의해야 할 점이 있나요?</summary>
<div markdown="1">

- 프록시 객체를 초기화할 때 주의해야 합니다. 바로 프록시 객체를 초기화 하지 못하는 경우 입니다. 프록시의 초기화는 영속성 컨텍스트의 도움을 받습니다. 따라서 영속성 컨텍스트의 관리를 받지 못하는 상황, 즉 준영속 상태의 프록시를 초기화 한다던가 OSIV 옵션이 꺼져 있는 상황에서 트랜잭션 바깥에서 프록시를 초기화하려는 경우 LazyInitializationException가 발생할 수 있습니다.
- 프록시 객체끼리 동등성을 비교할 때 주의해야 합니다. 보통 JPA 엔티티의 equals는 id값만 비교해서 재정의할 경우, 동등성이 다르게 나옵니다. equals가 호출되는 객체는 getId가 아닌 메서드를 호출해서 실제 객체의 equals가 호출되는데 이 객체의 클래스는 원본 객체의 클래스 타입이 나오고, 인수인 프록시 객체는 프록시 타입이 나오게 되어 클래스 타입 비교에서 false가 나옵니다. 또한 프록시 객체의 값들은 모두 null이기 때문에 id를 비교하는 부분에서도 false가 나옵니다.

</div>
</details>
<details>
<summary>프록시 객체가 아직 초기화 되기 전, Id를 조회해도 프록시 객체가 초기화 되나요?</summary>
<div markdown="1">

- getId 메서드를 통해 id(식별자)를 조회할 때는 프록시 객체가 초기화 되지 않습니다. 일반적으로는 식별자 접근 시 프록시를 초기화하는 옵션이 꺼져 있습니다.
- 만약 getter에 대한 자바 빈 규약을 만족시키지 못하거나, 식별자 이름과 매칭되지 않는 메서드로 호출할 경우에는 프록시가 초기화 됩니다.

</div>
</details>
<details>
<summary>JPA에서 고아 객체란 무엇인가요?</summary>
<div markdown="1">

- 고아 객체는 부모 엔티티와의 연관관계가 끊어진 자식 엔티티를 의미합니다. 즉, 자식 엔티티가 더 이상 부모 엔티티에 속하지 않을 때, 그 자식 엔티티를 고아 객체라고 합니다.

</div>
</details>
<details>
<summary>고아 객체를 삭제할 때 사용하는 orphanRemoval = true 옵션과 Cascade.REMOVE의 차이에 대해서 설명해주세요.</summary>
<div markdown="1">

- orphanRemoval = true
    - orphanRemoval 옵션은 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제하는 기능입니다. 즉, 부모 엔티티의 컬렉션에서 특정 자식 엔티티를 제거하면, 해당 자식 엔티티는 고아 객체(orphan)로 간주되어 자동으로 데이터베이스에서 삭제됩니다.
    - 연관관계가 끊어진 자식 엔티티에만 영향을 미칩니다. 즉, 부모 엔티티와의 연관관계만을 기준으로 삭제 여부를 판단합니다.
- CascadeType.REMOVE
    - CascadeType.REMOVE는 특정 엔티티를 삭제할 때, 그 엔티티와 연관된 엔티티도 함께 삭제하도록 JPA에 지시하는 옵션입니다. 이는 엔티티 간의 계층적인 관계에서 특히 유용합니다.
    - 부모 엔티티가 삭제될 때 연관된 자식 엔티티들도 함께 삭제되는 것을 의미합니다. 즉, 부모 엔티티의 생명주기에 따라 자식 엔티티의 생명주기가 결정됩니다.

</div>
</details>
<details>
<summary>단방향 매핑과 양방향 매핑에 대해서 설명해주세요.</summary>
<div markdown="1">

- 단방향 매핑
    - 단방향 매핑은 한 엔티티가 다른 엔티티를 참조할 수 있지만, 반대 방향으로는 참조할 수 없는 구조입니다. 즉, 관계를 가지는 엔티티 중 한 쪽만이 다른 쪽을 알고 있습니다. 
    - 장점: 단방향 매핑은 관계의 소유자가 명확하기 때문에 구현이 상대적으로 단순하고 이해하기 쉽습니다.
    - 단점: 반대 방향에서의 조회나 연산이 필요할 때 제한적입니다.
- 양방향 매핑
    - 양방향 매핑은 두 엔티티가 서로를 참조할 수 있는 구조입니다. 이 경우, 양쪽 엔티티 모두에서 관계의 반대편을 참조할 수 있습니다.
    - 장점: 양쪽에서 서로를 참조할 수 있으므로, 더 유연하게 엔티티 간의 관계를 활용할 수 있습니다. 데이터를 조회하거나 연산을 수행할 때 다양한 방법을 사용할 수 있습니다.
    - 단점: 구현이 복잡하고, 양쪽에서 관계를 관리해야 하기 때문에 주의 깊게 코드를 작성해야 합니다. 특히, 연관관계 편의 메소드를 잘 구현하지 않으면 데이터 불일치가 발생할 수 있습니다.

</div>
</details>
<details>
<summary>JPA에서 N+1 문제란 무엇이며, 이 문제를 어떻게 해결할 수 있나요?</summary>
<div markdown="1">

- N+1 문제란 연관 관계가 설정된 엔티티를 조회할 경우에 조회된 데이터 갯수만큼 연관관계의 조회 쿼리가 추가로 발생하는 현상입니다.
- 해결 방법
    1. Fetch join - 연관된 엔티티를 하나의 쿼리로 함께 로딩하는 방식
    2. EntityGraph - EntityGraph를 사용하면, 복잡한 연관 관계를 가진 엔티티를 한번에 로딩할 수 있음
    3. FetchMode.SUBSELECT
    4. @BatchSize

</div>
</details>

## 2️⃣ 테스트
<details>
<summary>DDD와 TDD에 대해서 설명해주세요.</summary>
<div markdown="1">

- DDD(도메인 주도 설계)
    - DDD는 복잡한 소프트웨어의 설계와 개발 과정에서 도메인(문제 영역)을 중심으로 접근하는 방법론입니다. 이 방법론은 소프트웨어가 해결하려는 실제 문제 영역에 초점을 맞추며, 도메인 전문가와 개발자 간의 긴밀한 협력을 통해 도메인의 복잡성을 이해하고 모델링합니다. DDD의 주요 목표는 도메인의 복잡성을 관리하고, 유연하며 유지보수가 용이한 소프트웨어를 개발하는 것입니다.
- TDD(테스트 주도 개발)
    - TDD는 소프트웨어 개발 프로세스에서 테스트를 먼저 작성하고, 그 테스트를 통과하기 위한 최소한의 코드를 작성하는 접근 방식입니다. TDD는 설계와 개발 과정에서 테스트의 역할을 강조하며, 코드의 품질을 높이고 유지보수를 용이하게 하는 것을 목표로 합니다.
    - TDD의 기본 순환은 다음과 같습니다:
        1. 실패하는 테스트 작성: 개발할 기능에 대한 테스트 케이스를 먼저 작성합니다. 이 테스트는 처음에는 실패합니다.
        2. 테스트 통과를 위한 코드 작성: 테스트를 통과하기 위해 최소한의 코드를 작성합니다.
        3. 리팩토링: 코드를 개선하고 중복을 제거합니다.
    - TDD를 통해 개발 과정에서 리팩토링의 필요성을 줄이고, 소프트웨어의 품질을 높일 수 있습니다. 또한, 테스트 케이스를 먼저 작성함으로써, 개발자는 요구 사항을 더 명확하게 이해하고, 설계를 더 세심하게 고려하게 됩니다.

</div>
</details>
<details>
<summary>Junit4와 Junit5의 주요 차이점은 무엇인가요?</summary>
<div markdown="1">

1. 모듈 구조
    - JUnit4: 단일 jar 파일로 제공되며, 확장을 위해서는 별도의 라이브러리가 필요합니다.
    - JUnit5: JUnit 플랫폼, JUnit Jupiter, JUnit Vintage로 구성된 모듈화된 구조를 가지고 있습니다. 이는 테스트를 실행하는 플랫폼, 새로운 테스트를 작성하기 위한 API와 런타임, 그리고 구버전의 JUnit 테스트를 지원하기 위한 모듈입니다.
2. 어노테이션과 실행 모델
    - JUnit4:
        - @Before, @After, @BeforeClass, @AfterClass 등의 어노테이션을 사용합니다.
        - 테스트 메소드는 public void여야 하며, @Test 어노테이션으로 표시됩니다.
    - JUnit5:
        - @BeforeEach, @AfterEach, @BeforeAll, @AfterAll 등으로 변경되었습니다.
        - 테스트 메소드는 접근 제한자 없이 작성될 수 있으며 (package-private), 반환 타입이 void가 아닐 수도 있습니다.
        - 더 다양한 어노테이션을 지원합니다 (@DisplayName, @Nested, @Tag, @Disabled 등).
3. 확장 모델
    - JUnit4: 확장을 위해 @Rule과 @ClassRule 어노테이션을 사용합니다.
    - JUnit5: 더 강력하고 유연한 확장 모델을 제공합니다. @ExtendWith 어노테이션을 사용하여 커스텀 어노테이션을 만들 수 있으며, 테스트 실행 과정의 다양한 단계에서 사용자 정의 로직을 적용할 수 있습니다.
4. 테스트 인스턴스 라이프사이클
    - JUnit4: 기본적으로 테스트 메소드마다 새로운 테스트 인스턴스를 생성합니다.
    - JUnit5: @TestInstance 어노테이션을 사용하여 테스트 클래스당 인스턴스를 하나만 생성하는 방식을 선택할 수 있어, 테스트 간의 상태 공유가 용이해집니다.
5. 조건부 테스트 실행
    - JUnit5는 @EnabledOnOs, @EnabledIf, @EnabledIfSystemProperty 등의 어노테이션을 통해 특정 조건에서만 테스트를 실행하도록 할 수 있는 기능을 제공합니다. 이는 JUnit4에서는 제공되지 않는 기능입니다.
6. 동적 테스트
    - JUnit5는 테스트 케이스를 동적으로 생성하고 실행할 수 있는 API를 제공합니다. 이를 통해 런타임에 테스트 케이스를 생성하고 조건에 따라 다른 테스트를 실행할 수 있습니다.
7. Assertions
    - JUnit4: JUnit5와 비교하면서 org.junit.Assert 클래스를 통해 기본 Assertion을 제공합니다.
    - JUnit5: 단일 테스트 내에서 여러 Assertion을 지원하는 AssertAll 및 기타 지원과 같은 다양한 메서드를 갖춘 보다 유연한 Assertions 클래스를 도입합니다.

</div>
</details>
<details>
<summary>단위 테스트, 통합 테스트, 인수 테스트에 대해서 설명해주세요.</summary>
<div markdown="1">

- 단위 테스트(Unit Test)
    - 단위 테스트는 응용 프로그램에서 테스트 가능한 가장 작은 소프트웨어를 실행하여 예상대로 동작하는지 확인하는 테스트입니다. 주로 클래스나 메소드 수준에서 이루어지며, 테스트 대상 단위의 크기를 작게 설정해서 단위 테스트를 최대한 간단하고 디버깅하기 쉽게 작성해야 합니다.
    - 단위 테스트는 개발자가 소프트웨어의 내부 코드를 깊이 이해하고 있어야 하는 화이트박스 테스트의 한 형태로, 특히 테스트 주도 개발(TDD)과 결합될 때 그 효과가 극대화됩니다.
    - Java에서는 JUnit이라는 프레임워크를 주로 사용하여 단위 테스트를 수행합니다.
- 통합 테스트(Integration Test)
    - 통합 테스트는 여러 모듈을 결합해 이들이 의도대로 협력하는지 검증하는 과정입니다. 단위 테스트와는 다르게, 개발자가 직접 수정할 수 없는 부분(예: 외부 라이브러리)까지 포함하여 전체 시스템이 다양한 환경에서 제대로 동작하는지 확인합니다
    - 이 방식은 단위 테스트로는 찾기 어려운 버그(예: 환경에 따라 다르게 작동하는 버그)를 발견할 수 있지만, 테스트 범위가 넓어 신뢰성이 떨어질 수 있고, 에러 위치를 정확히 파악하기 어려워 유지보수에 어려움이 있을 수 있습니다.
    - 스프링부트에서는 @SpringBootTest 어노테이션을 사용해 통합 테스트를 손쉽게 수행할 수 있습니다.
- 인수 테스트(Acceptance Test)
    - 인수 테스트(Acceptance Test)는 사용자의 스토리나 시나리오에 따라 수행되는 테스트로, 주로 비즈니스 요구사항에 초점을 맞춥니다. 이 테스트는 프로젝트에 참여하는 다양한 이해관계자(예: 기획자, 클라이언트 대표, 개발자 등)가 함께 토의하여 시나리오를 만들고, 이를 바탕으로 개발자가 코드를 작성하는 과정에서 이루어집니다. 인수 테스트의 목적은 소프트웨어가 사전에 정의된 요구사항(인수 조건)에 따라 올바르게 작동하는지 확인하는 것입니다.
    - 애자일 개발 방법론, 특히 익스트림 프로그래밍(XP)에서 유래한 인수 테스트는 주로 소프트웨어의 API를 통해 기능이 정상적으로 동작하는지 확인하는 방식으로 진행됩니다. 이 테스트는 소프트웨어의 내부 구조나 구현 방법보다는 실제 사용자의 관점에서 수행되는 블랙박스 테스트이며, 주로 E2E(End-to-End) 테스트 형식을 사용합니다.
    - Java에서는 RestAssured, MockMvc와 같은 도구를 활용해 인수 테스트를 작성할 수 있습니다.

</div>
</details>
<details>
<summary>Stub과 Mock의 차이점은 무엇이며, 각각 언제 사용하는 것이 적합한가요?</summary>
<div markdown="1">

- Stub
    - 목적: 테스트에 필요한 호출에 대해 미리 준비된 답을 제공하는 객체입니다. 주로 테스트 대상이 되는 코드의 의존성을 제거하기 위해 사용됩니다.
    - 스타일: 실제 객체처럼 동작하는 클래스를 직접 구현합니다. 하지만 테스트에 필요한 구현에만 집중하고, 부가적인 기능은 구현하지 않습니다.
    - 검증 방식: 상태 검증(state verification)을 사용합니다. 이는 어떤 입력에 대해 예상되는 출력이 발생하는지 검증하는 방식입니다.
- Mock
    - 목적: 예상된 동작을 가진 객체로, 특정 액션에 대한 출력을 정의합니다. 테스트 중에 특정 메소드가 호출되었는지, 몇 번 호출되었는지 등의 행동을 검증하는 데 사용됩니다.
    - 스타일: 다양한 Mock Framework를 사용하여 Mock 객체를 생성하고, 특정 액션에 대한 출력을 정의합니다.
    - 검증 방식: 행동 검증(behavior verification)을 사용합니다. 이는 입력과 상관없이 특정 행동이 이루어졌는지, 예를 들어 메소드가 특정 횟수로 호출되었는지 등을 검증하는 방식입니다.
- Stub은 테스트에 필요한 구체적인 결과를 미리 정의하여 상태 검증에 집중하는 반면, Mock은 특정 행동이 이루어졌는지를 검증하는 데 초점을 맞춥니다.

</div>
</details>
<details>
<summary>@Mock와 @MockBean의 차이를 설명해주세요.</summary>
<div markdown="1">

- @Mock
    - 개요: @Mock은 Mockito 라이브러리에서 제공하는 어노테이션입니다. 이는 주로 단위 테스트에서 사용되며, 특정 클래스의 모의 객체를 생성하는 데 사용됩니다.
    - 적용 범위: @Mock으로 생성된 모의 객체는 주로 해당 테스트 클래스 내에서만 유효합니다. 이는 해당 테스트에서만 사용되는 독립적인 모의 객체를 만들 때 유용합니다.
    - 사용 예: 단위 테스트에서 특정 메소드의 동작을 모의하기 위해 사용됩니다. 예를 들어, 데이터베이스 접근 로직을 가진 클래스를 테스트할 때 실제 데이터베이스에 접근하지 않고 @Mock을 사용하여 해당 클래스의 의존성을 모의할 수 있습니다.
- @MockBean
    - 개요: @MockBean은 스프링 부트 테스트에서 제공하는 어노테이션입니다. 스프링 애플리케이션 컨텍스트(Application Context) 내에 있는 빈(Bean)을 모의 객체로 대체할 때 사용됩니다.
    - 적용 범위: @MockBean으로 생성된 모의 객체는 스프링의 애플리케이션 컨텍스트에 추가되므로, 해당 스프링 애플리케이션 컨텍스트를 공유하는 모든 테스트에서 사용될 수 있습니다. 이는 애플리케이션의 다양한 부분에서 동일한 모의 객체를 재사용하고 싶을 때 유용합니다.
    - 사용 예: 통합 테스트에서 특정 빈의 실제 로직을 모의 로직으로 대체하여 테스트의 복잡성을 줄이고, 외부 시스템에 대한 의존성을 제거하고자 할 때 사용됩니다. 예를 들어, 웹 컨트롤러 테스트 시, 실제 서비스 레이어를 모의 서비스 레이어로 대체하여 테스트할 수 있습니다.
- 요약
    - @Mock
        - Mockito 라이브러리 제공
        - 주로 단위 테스트에 사용
        - 테스트 클래스 내에서만 유효한 모의 객체 생성
    - @MockBean
        - 스프링 부트 테스트 제공
        - 주로 통합 테스트에 사용
        - 애플리케이션 컨텍스트 전역에서 유효한 모의 객체 생성, 다른 테스트와 공유 가능

</div>
</details>
<details>
<summary>Spring Boot에서 계층별 테스트 방법에는 어떤 것들이 있나요? 간략하게 설명해주세요.</summary>
<div markdown="1">

- 1. 단위 테스트(Unit Test)
    - 목적: 가장 기본적인 단위에서 코드의 정확성을 검증합니다.
    - 특징: 의존성을 모의 객체(Mock Objects)로 대체하여, 테스트하고자 하는 단위를 격리시킵니다. 빠르고 효율적입니다.
2. 서비스 레이어 테스트(Service Layer Test)
    - 목적: 비즈니스 로직이 기대대로 작동하는지 검증합니다.
    - 특징: 서비스 레이어를 테스트하기 위해 레포지토리 레이어를 모의 객체로 대체합니다. 트랜잭션 관리가 중요할 수 있습니다.
3. 리포지토리 레이어 테스트(Repository Layer Test)
    - 목적: 데이터베이스와의 상호작용이 정확하게 이루어지는지 검증합니다.
    - 특징: @DataJpaTest 어노테이션을 사용하여 리포지토리 레이어만을 로드하고, 데이터베이스 트랜잭션을 관리합니다.
4. 컨트롤러 테스트(Controller Test)
    - 목적: HTTP 요청과 응답이 올바르게 처리되는지 검증합니다.
    - 특징: @WebMvcTest 어노테이션을 사용하여 컨트롤러 레이어만을 로드합니다. MockMvc를 사용해 HTTP 요청을 모의하고, 결과를 검증할 수 있습니다.
5. 통합 테스트(Integration Test)
    - 목적: 애플리케이션의 여러 컴포넌트가 함께 잘 작동하는지 확인합니다.
    - 특징: @SpringBootTest 어노테이션을 사용하여 전체 애플리케이션 컨텍스트를 로드합니다. 실제 애플리케이션에 가까운 환경에서 테스트가 가능합니다.

</div>
</details>
<summary>프로젝트에서 계층별 테스트를 어떻게 진행하셨나요?</summary>
<div markdown="1">


</div>
</details>
<details>
<summary>테스트 커버리지와 JACOCO에 대해서 설명해주세요.</summary>
<div markdown="1">

- 테스트 커버리지
    - 테스트 커버리지는 소프트웨어 테스트가 얼마나 소스 코드를 커버하고 있는지를 나타내는 지표입니다. 다시 말해, 전체 코드 중 테스트로 검증된 부분이 얼마나 되는지를 수치적으로 표현한 것이죠. 이는 테스트의 완성도와 품질을 평가하는 중요한 기준 중 하나로 활용됩니다.
    - 테스트 커버리지는 소프트웨어의 품질을 보장하는 데 중요한 역할을 합니다. 높은 테스트 커버리지는 코드에 대한 신뢰도를 높여주며, 잠재적인 버그와 결함을 사전에 발견할 수 있는 기회를 제공합니다. 하지만, 100% 테스트 커버리지가 모든 버그를 제거한다는 것을 보장하지는 않습니다. 따라서 개발자는 테스트 커버리지와 함께 코드의 품질을 종합적으로 평가하고, 테스트 케이스의 질에도 주의를 기울여야 합니다.
- JACOCO
    - JaCoCo(Java Code Coverage)는 자바 애플리케이션의 코드 커버리지를 측정하는 도구입니다. 이는 주로 개발자가 자신의 코드가 얼마나 잘 테스트되었는지를 확인하기 위해 사용되며, 테스트 커버리지 보고서를 생성하여 어떤 코드 부분이 테스트되었고, 어떤 부분이 누락되었는지를 시각적으로 보여줍니다.

</div>
</details>