  

### JPA

#### JPA 프록시에 대해서 설명해주세요

JPA 프록시는 실제 엔티티 객체를 상속받아 만들어지는 가짜(프록시) 객체입니다. 이 프록시 객체는 실제 엔티티의 참조를 갖고 있으며, 실제 엔티티의 데이터가 필요한 시점까지 데이터베이스 조회를 지연시키는 방법으로 사용됩니다. `EntityManager`의 `getReference()` 메소드를 통해 프록시 객체를 얻을 수 있으며, 이 객체에 접근할 때 실제 데이터베이스 조회가 이루어지고 필요한 엔티티 데이터를 로딩합니다.

#### 고아 객체에 대해서 설명해주세요

고아 객체(Orphan Object)는 부모 엔티티와의 연관 관계가 끊어진 자식 엔티티를 말합니다. JPA에서는 `orphanRemoval=true` 옵션을 설정하여 부모 엔티티에서 자식 엔티티를 컬렉션에서 제거하면, 해당 자식 엔티티를 자동으로 삭제(고아 객체로 취급하여 제거)할 수 있습니다. 이는 연관 관계 관리에 있어 편리함을 제공하지만, 사용 시 신중해야 합니다.

#### 단방향 매핑과 양방향 매핑을 비교해서 설명해주세요

- **단방향 매핑**: 엔티티 간의 관계가 한 쪽 방향으로만 설정되는 매핑입니다. 예를 들어, `Post` 엔티티가 `Comment` 엔티티를 참조할 수 있지만, `Comment`에서는 `Post`를 참조할 수 없습니다.
- **양방향 매핑**: 두 엔티티가 서로를 참조하는 관계입니다. 이를 통해 한 엔티티에서 연관된 다른 엔티티를 쉽게 찾을 수 있습니다. 양방향 매핑에서는 한 쪽이 연관 관계의 주인(Owner)이 되어 외래 키를 관리합니다.

#### 연관 관계 주인이란 무엇인가요?

연관 관계 주인은 양방향 매핑에서 외래 키를 관리하는 엔티티를 말합니다. JPA에서는 `@JoinColumn` 등의 어노테이션을 사용하여 연관 관계 주인을 설정합니다. 연관 관계 주인이 아닌 쪽은 `mappedBy` 속성을 사용하여 연관 관계의 주인을 지정합니다. 연관 관계 주인만이 데이터베이스의 연관 관계와 매핑되어 외래 키를 관리할 수 있습니다.

#### N + 1 문제란 무엇인가요?

N + 1 문제는 ORM을 사용할 때 발생하는 성능 저하 문제입니다. 하나의 엔티티를 조회할 때 연관된 엔티티를 함께 로딩해야 하는 상황에서, 처음 1번의 쿼리로 목록을 조회한 후, 각 엔티티에 대해 추가적으로 N번의 쿼리가 발생하는 문제를 말합니다. 이는 특히 연관된 데이터가 많은 경우 성능 저하의 주요 원인이 됩니다.

#### N + 1 문제 해결 방법에 대해 말씀해주세요

N + 1 문제의 해결 방법으로는 주로 다음과 같은 방법이 있습니다:

- **즉시 로딩(Eager Loading)**: 연관된 엔티티를 처음부터 함께 로딩하는 방법입니다. `@Fetch(FetchMode.JOIN)` 등을 사용하여 구현할 수 있습니다. 하지만 모든 상황에 적합한 것은 아니며, 경우에 따라 성능 저하를 일으킬 수 있습니다.
- **JPQL Fetch Join**: JPQL 쿼리 내에 `FETCH JOIN` 구문을 사용하여 연관된 엔티티를 한 번의 쿼리로 함께 조회합니다. 이 방법은 필요한 데이터만 선택적으로 로딩하는 데 유용합니다.
- **`@EntityGraph`**: 엔티티를 조회할 때 특정 속성을 함께 로딩하도록 하는 기능입니다. `@EntityGraph` 어노테이션을 사용하여 구현할 수 있으며, 성능 최적화에 도움을 줄 수 있습니다.
- **배치 사이즈 설정**: `@BatchSize` 어노테이션 또는 글로벌 설정을 통해 한 번에 로딩할 연관 엔티티의 수를 조정할 수 있습니다. 이를 통해 N + 1 문제를 완화할 수 있습니다.

### 테스트

#### DDD란 무엇인가요?

도메인 주도 설계(Domain-Driven Design, DDD)는 복잡한 요구사항을 가진 소프트웨어 프로젝트에 대해, 도메인(문제 영역)의 전문 지식을 중심으로 설계와 개발을 진행하는 접근 방법입니다. DDD는 도메인 모델을 통해 실제 세계의 비즈니스 규칙을 반영하며, 이를 기반으로 소프트웨어를 설계하고 구현하는 것을 목표로 합니다.

#### TDD란 무엇인가요?

테스트 주도 개발(Test-Driven Development, TDD)은 매우 짧은 개발 사이클을 반복하는 소프트웨어 개발 프로세스 중 하나입니다. TDD에서는 먼저 요구 사항을 테스트 케이스로 작성하고, 이 테스트를 통과하는 가장 간단한 코드를 작성한 후, 코드를 리팩토링하는 순서로 진행됩니다. 이 방법은 설계의 개선과 소프트웨어의 품질 향상에 기여합니다.

#### Junit4 와 Junit5 에 대해 비교해서 설명해주세요

- **JUnit4**: Java로 작성된 소프트웨어의 단위 테스트를 위한 프레임워크 중 하나입니다. 어노테이션 기반으로 테스트 메소드를 작성하며, `@Before`, `@After`, `@Test` 등의 어노테이션을 사용합니다.
- **JUnit5**: JUnit의 다음 세대 버전으로, JUnit4보다 더 유연한 테스트 작성과 더 많은 기능을 제공합니다. JUnit5는 JUnit Platform, JUnit Jupiter, JUnit Vintage로 구성되며, 람다식을 지원하고, 테스트 인스턴스 생명주기, 확장 모델 등 새로운 기능들을 포함합니다.

#### 단위 테스트란 무엇인가요?

단위 테스트(Unit Test)는 소프트웨어의 가장 작은 단위(일반적으로 메소드)를 검증하는 테스트입니다. 단위 테스트는 독립적으로 실행되어야 하며, 소프트웨어의 다른 부분에 의존하지 않아야 합니다. 이를 통해 개발자는 개별 구성 요소가 예상대로 정확하게 작동하는지 확인할 수 있습니다.

#### 통합 테스트란 무엇인가요?

통합 테스트(Integration Test)는 소프트웨어의 여러 모듈이나 시스템의 구성 요소가 함께 올바르게 작동하는지 검증하는 테스트입니다. 단위 테스트가 각 부분의 정확성을 검증한다면, 통합 테스트는 이러한 부분들이 서로 올바르게 통합되어 전체 시스템이 기대한 대로 작동하는지 확인하는 데 중점을 둡니다.

#### 인수 테스트란 무엇인가요?

인수 테스트(Acceptance Test)는 실제 사용 환경에서 소프트웨어가 사용자의 비즈니스 요구사항을 만족시키는지 확인하는 과정입니다. 주로 사용자나 클라이언트가 참여하여 실시되며, 소프트웨어의 기능, 성능, 안정성 등이 최종 사용자의 기대를 충족시키는지 평가합니다.

#### stub과 mock 개념에 대해 설명해주세요

- **Stub**: 테스트 중인 코드가 의존하는 부분을 간단하게 대체하기 위한 객체입니다. 일반적으로 반환 값만 설정되어 있으며, 테스트를 위해 프로그램의 특정 부분을 단순화한 버전입니다.
- **Mock**: Stub보다 더 복잡하며, 테스트 중인 코드와 상호 작용하는 방식을 검증할 수 있습니다. Mock 객체는 기대하는 호출이 이루어졌는지, 올바른 인자로 호출되었는지 등을 검증하는 데 사용됩니다.

#### SpringBoot에서 계층별로 어떻게 테스트하는지 설명해주세요

- **단위 테스트**: `@SpringBootTest` 어노테이션 없이 순수한 단위 테스트를 수행합니다. 주로 서비스 레이어나 리포지토리 레이어의 메소드를 대상으로 합니다. Mock 객체를 사용하여 의존성을 제거하고, `@MockBean`을 사용하여 Spring 컨텍스트 내의 빈을 Mock으로 대체할 수 있습니다.
- **통합 테스트**: `@SpringBootTest` 어노테이션을 사용하여 Spring Boot 애플리케이션의 전체 컨텍스트를 로드하여 테스트를 수행합니다. 데이터베이스, 웹 환경 등 실제 애플리케이션과 유사한 환경에서 컴포넌트들이 올바르게 작동하는지 검증합니다.
- **웹 레이어 테스트**: `@WebMvcTest` 등을 사용하여 컨트롤러의 HTTP 요청과 응답을 테스트합니다. 이는 웹 레이어에 집중된 테스트로, 컨트롤러가 예상대로 동작하는지 검증합니다.

#### 테스트 커버리지와 관련된 개념 중 Jacoco에 대해 설명해주세요
- JaCoCo(Java Code Coverage)는 Java 프로그램의 코드 커버리지를 측정하는 라이브러리입니다. 코드 커버리지는 테스트 케이스가 소프트웨어의 코드 베이스 중 얼마나 많은 부분을 실행하는지를 나타내는 지표로, 소프트웨어 테스트의 완성도와 품질을 평가하는 데 중요한 요소입니다. JaCoCo는 테스트 실행 중에 코드 실행 정보를 수집하여 다양한 형태의 리포트를 생성합니다. 이를 통해 개발자는 테스트가 덮고 있는 코드 영역과 미처 다루지 못한 영역을 명확하게 확인할 수 있습니다.