### Web Server 와 WAS의 차이점을 비교해서 설명해 주세요.

웹 서버는 **정적(이미지, html 파일 같이 컴퓨터에 저장되어 있는 자원.)**인 자원을 응답하거나, 동적인 자원을 요청할 시 해당 요청을 WAS에게 전달하는 역할을 한다.

WAS(Web Server + Web Container)는 전달받은 **동적** 자원 요청을 처리해서 반환하는 역할을 한다. 다만 현재 WAS는 정적인 자원을 처리할 수 있기 때문에, 웹서버로써의 역할까지 할 수 있다.

### WAS가 웹 서버로써 동작할 수 있는데, 굳이 따로 웹서버를 두는 이유?

WAS는 대량의 데이터를 처리해야 하거나, 동시 요청 수가 많아지면 부하가 걸리기 마련이다.

따라서 WAS의 **부하 방지**를 위해서 웹 서버와 WAS를 분리하여 WAS의 부담을 웹 서버에게 덜어낸다.

또한 웹 서버를 로드밸런서로써 활용하여 여러대의 WAS를 두어 장애 극복에 잘 대응할 수 있는 장점도 가져갈 수 있다.

### 웹서버로서 Apache 와 Nginx의 차이점을 간단하게 설명해 주세요.

Nginx는 비동기 **이벤트 중심 접근 방식**으로 하나의 스레드 내에서 여러 요청을 처리하는 구조이기 때문에, 다른 요청을 block하지 않고도 다수개의 요청을 처리할 수 있다.

Apache는 **프로세스 기반 접근 방식**으로 하나의 스레드가 하나의 요청을 처리하는 구조이기 때문에, 요청마다 1개의 프로세스를 할당한다.

또한 Apache는 기본적으로 동적으로 로드 가능한 다양한 60개의 공식 모듈을 제공하기 때문에, 유연성이 뛰어나다.

반면에 Nginx는 정교한 아키텍처(이벤트 기반 아키텍처)로 인해 서드파티 / 모듈 개발이 쉽지 않고, 타사 플러그인 과정으로 선택되고 컴파일되기 때문에 동적으로 모듈을 로드할 수 없다 → 유연성이 떨어진다.

### Apache/Nginx의 장단점에 대해서 설명해 주세요.

### Apache

- 장점 : 연결당 Process/Thread로 접근되어 개별적인 연결이 진행되며, 웹 서비스 로직의 어느 지점에서나 새로운 모듈을 추가하거나, 수정하는 것이 쉽습니다. 오류가 발생했을 때 개발자는 해당 작업자 프로세스를 통해 코드를 수정할 수도 있습니다.
- 단점 : 커넥션 형성 구조가 연결당 1개의 프로세스를 할당하여 커넥션이 증가할수록 메모리와 리소스가 부족해지는 현상이 발생하며, CPU 코어가 별도의 과정을 통해 부하를 얻는 상황이 빈번합니다.

### Nginx

- 장점 : 태생적으로 Apache의 C10K 문제점을 해결하기 위해 탄생하여, 비동기적으로 연결을 진행하며 동시 커넥션의 부하를 분산시킬 수 있다. Apache와 동시에 실행될 수 있으며, 부하 분산을 목적으로만 사용이 가능하며 단일 프로그램으로 웹 서버를 운영할 수 있다는 장점이 있다.
- 단점 : 정교한 아키텍처로 인해 서드파티 / 모듈 개발이 쉽지 않다는 점입니다. Nginx 개발자는 오류 없이 효율적이고 정확한 코드를 통해 복잡한 이벤트 기반의 커널과 상호작용을 위해 주의해야 합니다. 또한 Apache에 비해 Windows에서 안정성이 떨어진다는 특징도 가지고 있습니다.

### 웹서버를 선택할 때 무슨 기준으로 선택하실건가요?

- 트래픽이 적은 경우 혹은 다양한 모듈을 이용하여 유연성 있는 서버를 설계하고 싶은 경우에는 Apache를, 그렇지 않다면 Nginx를 선택하는 것이 좋을 것 같습니다.

### SSL Offloading이란 무엇이고, 왜 필요한가요?

> 서버 대신 SSL handshake, 데이터 암복호화를 수행하여 SSL 통신관련 부하를 제거하고 클라이언트와 서버간의 SSL 암호화 통신을 제공하는 기능.
>

### SSL offloading의 필요성

1. 웹서버에서 SSL 기능을 사용하게 되면 인증과 암호화 과정에서 웹서버 오버헤드가 심해진다.
2. 웹서버가 심한 부하를 감당하므로 서비스할 수 있는 사용자수가 급감한다.

### 프록시 서버는 무엇이고, 왜 사용하나요?

> 프록시 서버는 클라이언트가 자신을 통해서 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해 주는 컴퓨터 시스템이나 응용 프로그램을 가리킨다.
프록시를 쓰는 이유는 보안상의 이유로 직접 통신할 수 없는 두 점 사이에서 대리로 통신을 수행하여 보안성, 성능을 향상 시키기 위해서 이다.
>

### 포워드 프록시와 리버스 프록시에 대해서 설명해 주시고, 해당 프록시를 적용했을 때의 장점에 대해서 설명해 주세요.

### 포워드 프록시

- 클라이언트 바로 뒤에 놓여 있다.
- 클라이언트가 서버에 접근하고자 할때, 클라이언트는 타겟 서버의 주소를 포워드 프록시에 전달하여, 포워드 프록시가 인터넷으로 요청된 내용을 가져오는 방식이다.

### 포워드 프록시 장점

**클라이언트 보안 (Security)**

- 해당 기관에 속한 사람들이 그들이 방문하고자 하는 웹사이트에 직접적으로(directly) 방문하는 것을 방지할 수 있다. 예를 들어, 포워드 프록시 서버에 룰을 추가해서 특정 사이트에 접속하는 것을 막을 수 있다.

**캐싱**

- 우리가 어떤 웹 페이지에 접근하면 프록시 서버는 해당 페이지 서버의 정보를 캐싱(임시보관)해둔다.
  그래서 똑같이 해당 페이지에 접근하거나, 다른 클라이언트가 해당 페이지를 요청할 때 , 캐시된 정보(페이지)를 그대로 반환할 수 있고, 이는 서버의 부하를 줄이는 효과도 낼 수 있다.

위의 그림에서 만일 4명의 클라이언트가 naver.com에 접근할때 본래는 각각 따로 인터넷을 경유해서 네이버 페이지를 받겠지만, 포워드 프록시를 이용하면 프록시내 캐싱 된 네이버 페이지를 불러오기 때문에 훨씬 빠르게 조회할수 있는 원리이다.

**암호화**

- 클라이언트의 요청은 포워드 프록시 서버를 통과할 때 암호화된다.
  암호화된 요청은 다른 서버를 통과할 때 필요한 최소한의 정보만 갖게 되는데, 이는 클라이언트의 ip 를 (보안을 위해) 감춰주는 보안 효과를 내준다.
  따라서 본 서버에서 IP 주소를 역추적해도 포워드 프록시 서버를 사용하면  정체를 파악하기 어렵게 된다.
  왜냐면 IP 추적해도 포워드 프록시 서버 IP만 보이기 때문이다.



### 리버스 프록시

- 웹서버/WAS 앞에 놓여 있는 것
- 클라이언트는 웹서비스에 접근할때 웹서버에 요청하는 것이 아닌, 프록시로 요청하게 되고, 프록시가 배후(reverse)의 서버로부터 데이터를 가져오는 방식이다.

> 내부 서버가 직접 서비스를 제공해도 되지만, 이렇게 구성하는 이유는 보안 때문이다.
보통 기업의 네트워크환경에서는 **DMZ**라고 부르는 내부네트워크/외부네트워크 사이에 위치하는 구간이 존재한다. (내부네트워크/외부네트워크에 둘다 접근할 수 있는 공간)
이 구간에는 보통 메일 서버, 웹 서버, FTP 서버 등 외부 서비스를 제공하는 서버가 위치하게 된다.
WAS를 DMZ에 놓고 서비스해도 되지만 보안상 문제가 있기 때문에 그렇게 하진 않는다.
WAS는 DB서버와 연결되어 있으므로, WAS가 해킹당할 경우 DB서버까지 해킹당할 수 있는 문제가 발생할 수 있기 때문이다.
따라서 리버스 프록시 서버를 DMZ에 두고 실제 서비스 서버는 내부망에 위치시킨 후 서비스 하는 것이 일반적이다.
>

### 리버스 프록시 장점

**로드 밸런싱 (Load Balancing)**

유명한 웹 사이트는 하루에도 수백만명이 방문한다.

그리고 그러한 대량의 트래픽을 하나의 싱글 서버로 감당해 내기란 어렵다.

하지만 리버스 프록시 서버를 여러개의 본 서버들 앞에 두면 특정 서버가 과부화 되지 않게 로드밸런싱이 가능하다.

**서버 보안 (Security)**

리버스 프록시를 사용하면 서버 측 보안에 좋다.리버스 프록시를 사용하면 본래 서버의 IP 주소를 노출시키지 않을 수 있다. 따라서 해커들의 DDoS 공격과 같은 공격을 막는데 유용하다.

위의 그림에서 보면, 클라이언트는 인터넷을 통해 리버스 프록시 서버 url에게 요청을 한다.

그리고 리버스 프록시는 본서버에게 요청을 경유해서 보내게 된다. 이렇게 되면 클라이언트는 본 서버의 url을 모른채 리버스 프록시 url을 통해 서비스를 이용하게 되고, 이는 즉 본서버의 정보를 숨기는 효과가 된다.

**캐싱 (Caching)**

만약 어떤 한국에 있는 유저가 미국에 웹서버를 두고 있는 사이트에 접속할때, 리버스 프록시 서버가 한국에 있다고 해보자.

그러면 한국에 있는 유저는 한국에 있는 리버스 프록시 서버와 통신해서 리버스 프록시 서버에 캐싱되어 있는 데이터를 사용할 경우에는 더 빠른 성능을 보여줄수 있다. 포워드 프록시의 캐싱과 비슷한 기능을 한다고 보면 된다. (정확히 프록시의 본래 기능)

**암호화 (Encryption)**

마지막으로 SSL 암호화에도 좋다.

본래 서버가 클라이언트들과 통신을 할때 SSL(or TSL)로 암호화, 복호화를 할 경우 비용이 많이 들게 된다.그러나 리버스 프록시를 사용하면 들어오는 요청을 모두 복호화하고 나가는 응답을 암호화해주므로 클라이언트와 안전한 통신을 할수 있으며 본래 서버의 부담을 줄여줄 수 있다.

### 포워드 프록시와 리버스 프록시의 차이점에 대해 설명해 주세요.

프록시 서버의 위치와 사용 목적에 따라 차이가 있습니다.

### 로드밸런서의 기본 기능에 대해서 아는대로 말씀해 주세요.

- **Health Check (상태 확인)**
    - 서버들에 대한 주기적인 Health Check를 통해 **서버들의 장애 여부를 판단**하여, **정상 동작 중인 서버로만 트래픽을 보낸다.**
    - **L3** 체크 : **ICMP**를 이용하여 서버의 **IP 주소가 통신 가능한 상태인지를 확인**한다.
    - **L4** 체크 : TCP는 3 Way-Handshaking (전송 - 확인/전송 - 확인) 를 기반으로 통신하는데, 이러한 **TCP**의 특성을 바탕으로 **각 포트 상태를 체크**하는 방식.
    - **L7** 체크 : **어플리케이션 계층에서 체크**를 수행. **실제 웹페이지에 통신을 시도**하여 이상 유무를 파악.
- **Tunneling (터널링)**
    - **데이터 스트림을 인터넷 상에서 가상의 파이프를 통해 전달시키는 기술**로, 패킷 내에 터널링할 대상을 캡슐화시켜 목적지까지 전송.**연결된 상호 간에만 캡슐화된 패킷을 구별**해 캡슐화를 해제하게 함.
- **NAT (Network Address Translation)**
    - 내부 네트워크에서 사용하는 **사설 IP 주소**와 로드밸런서 외부의 **공인 IP 주소 간의 변환 역할.**로드밸런싱 관점에서는 여러 개의 호스트가 **하나의 공인 IP 주소(VLAN or VIP)를 통해 접속하는 것이 주 목적**
    - **SNAT (Source Network Address Translation)**
        - 내부에서 외부로 트래픽이 나가는 경우.**내부 사설 IP 주소 -> 외부 공인 IP 주소**로 변환.
    - **DNAT (Destination Network Address Translation)**
        - 외부에서 내부로 트래픽이 들어오는 경우.**외부 공인 IP 주소 -> 내부 사설 IP 주소**로 변환.
- **DSR (Destination Network Address Translation)**
    - 서버에서 클라이언트로 트래픽이 되돌아가는 경우, 목적지를 클라이언트로 설정한 다음, **네트워크 장비나 로드밸런서를 거치지 않고 바로 클라이언트를 찾아가는 방식.** 이 기능을 통해 **로드밸런서의 부하를 줄여**줄 수 있음.

### L4로드밸런서와 L7로드밸런서에 대해 설명해 주시고, 장단점에 대해서 설명해 주세요.

- **L4 로드 밸런서**
    - 4 계층 - 전송 계층(TCP, UDP)이나 3 계층 -  네트워크 계층(IP, IPX)의 정보를 바탕으로 로드를 분산. 즉, IP 주소, 포트번호, MAC 주소, 전송 프로토콜 등에 따라 트래픽을 분산하는 것이 가능
    - **장점**
        - 패킷의 내용을 확인하지 않고 로드를 분산하므로 **속도가 빠르고 효율이 높음. →** 데이터의 내용을 **복호화할 필요가 없기에** 안전. → L7 로드밸런서보다 **가격이 저렴.**
    - **단점**
        - 패킷의 내용을 살펴볼 수 없으므로, **섬세한 라우팅 불가 → 사용자의 IP가 수시로 바뀌는 경우**라면, 연속적인 서비스를 제공하기 어려움.
- **L7 로드 밸런서**
    - 7 계층 - **어플리케이션 계층(HTTP, FTP, SMTP 등)에서 로드를 분산**하기 때문에, **HTTP 헤더**, **쿠키** 등과 같은 사용자 요청을 기준으로 특정 서버에 트래픽을 분산하는 것이 가능.
    - L4 로드밸런서의 기능에 더하여, **패킷의 내용을 확인하고 그 내용에 따라 로드를 특정 서버에 분배**하는 것이 가능.
    - **특정한 패턴을 지닌 바이러스를 감지**해 네트워크 보호 가능. Dos/DDos와 같은 **비정상적인 트래픽 필터링** 가능.
    - 방식
        - **URL 스위칭(URL Switching)** 방식 : **특정 하위 URL들**은 특정 서버로 처리하는 방식. ex) '.../steven/image' => 이미지 처리 서버 / '.../steven/video' => 동영상 처리 서버
        - **컨텍스트 스위칭(Context Switching)** 방식 : 클라이언트가 요청한 **특정 리소스에 대해 특정 서버로** 연결 가능.ex) 이미지 파일에 대해서는 **확장자를 참조**하여, 별도로 구성된 이미지 파일이 있는 서버 or 스토리지로 직접 연결.
        - **쿠키 지속성(Persistence with Cookies)** :  쿠키 정보를 바탕으로 **클라이언트가 연결했었던 동일한 서버에 계속 할당**해 주는 방식. 특히, 사설 네트워크에 있던 클라이언트의 IP 주소가 공인 IP 주소로 치환되어 전송하는 방식을 지원.ex) **X-Forwarded-For 헤더**에 클라이언트 IP 주소를 별도로 기입
    - **장점**
        - 상위 계층에서 로드를 분산하기 때문에 **훨씬 더 섬세한 라우팅** 가능.
        - **캐싱(Caching) 기능**을 제공.
        - 비정상적인 트래픽을 사전에 필터링할 수 있어 **서비스 안정성 높음.**
    - **단점**
        - L4 로드밸런서에 비해 **비쌈.**
        - **패킷의 내용을 복호화하여야** 하므로 더 높은 비용을 지불해야 함.
        - 클라이언트가 로드밸런서와 인증서를 공유해야 하기 때문에, 공격자가 로드밸런서를 통해 클라이언트의 데이터에 접근할 수 있는 **보안상의 위험성** 존재.

### L4,L7로드밸런서 중 어떤상황에 무슨 로드밸런서를 사용하실 건가요?

실시간 트래픽 처리가 중요한 서비스의 경우 L4 로드 밸런서를 사용하여 빠른 응답 시간을 제공할 것입니다.

혹은 HTTP 프로토콜을 이용해야 하는 경우(ex : 특정 url/특정 리소스는 특정 서버로 라우팅)에는 L7 로드밸런서를 이용할 것입니다.

### 로드밸런싱 알고리즘에 대해 설명해 주시고, 어느 상황에 사용하는지 간단하게 설명해 주세요.

- **라운드 로빈 방식 (Round Robin Method)**
    - 서버로 들어온 요청을 **순서대로 돌아가며 배정**하는 방식. 클라이언트의 요청을 순서대로 분배하기 때문에 **서버들이 동일한 스펙**을 갖고 있고, 서버와의 **연결(세션)이 오래 지속되지 않는 경우**에 활용하기 적합.
- **가중 라운드로빈 방식 (Weighted Round Robin Method)**
    - 각각의 서버마다 **가중치(Weight)**를 매기고 **가중치가 높은 서버에 클라이언트 요청을 우선적으로 배분.**주로 **서버의 트래픽 처리 능력이 상이한 경우** 사용되는 로드밸런싱 방식. **ex) 서버 A의 가중치: 5 / 서버 B의 가중치: 2** => A 서버에 5개의 Request, B 서버에 2개의 Request 할당.
- **IP 해시 방식 (IP Hash Method)**
    - **클라이언트의 IP 주소를 특정 서버로 매핑**하여 요청을 처리하는 방식.**사용자의 IP를 *해싱(Hashing)**하여 부하를 분산하기 때문에 **사용자가 항상 동일한 서버로 연결**되는 것을 보장.**경로가 보장되며, 접속자 수가 많을수록 분산 및 효율이 뛰어남.해싱(Hasing) :** 임의의 길이를 지닌 데이터를 고정된 길이의 데이터로 매핑 하는 것, 또는 그러한 함수.
- **최소 연결 방식 (Least Connection Method)**
    - Request가 들어온 시점에 **가장 적은 연결(세션) 상태를 보이는 서버에 우선적으로** 트래픽을 할당.**자주 세션이 길어지거나, 서버에 분배된 트래픽들이 일정하지 않은 경우**에 적합.
- **최소 응답시간 방식 (Least Response Time Method)**
    - 서버의 현재 연결 상태와 **응답시간(Response Time)을 모두 고려하여, 가장 짧은 응답 시간을 보내는 서버**로 트래픽을 할당하는 방식.**각 서버들의 가용한 리소스와 성능, 처리중인 데이터 양 등이 상이할 경우** 적합.
- **대역폭 방식 (Bandwidth Method)**
    - 서버들과의 **대역폭을 고려**하여 서버에 트래픽을 할당.

### 브라우저 캐시에 대해 설명해 주시고, 브라우저 캐시를 활용하는 과정에 대해 설명해 주세요.

### **브라우저 캐시**

- HTTP 캐시라고도 하며, 브라우저 혹은 HTTP 요청을 보내는 클라이언트의 내부 디스크 혹은 메모리에 저장되는 캐시이다.
- 각 사용자마다 할당되는 개인화(personalized)된 캐시이므로 클라이언트 간 공유는 불가능하다.
- 모든 HTTP 요청은 먼저 서버로 직접 요청을 보내지 않고 브라우저 캐시로 라우팅되는데, HTTP 캐시 내에 필요한 데이터가 존재한다면 캐시된 데이터를 반환한다.
- 브라우저 캐시는 HTML의 메타 태그로 캐시 속성을 지정하거나, HTTP 요청 및 응답 헤더에 지정하는 방법으로 제어가 가능하다.

- 브라우저 캐시 이용과정
    - HTTP 요청 시, 브라우저는 이전 응답에서 받은 Last-Modified를 If-Modified-Since 속성의 값으로 함께 전달한다.
    - 서버는 데이터의 최종 수정 시간을 If-Modified-Since의 값과 비교하고, 만약 값이 동일하다면 304 Not Modified 응답을 반환하고, 리소스가 변경되었다면 서버에서는 새로운 Last-Modified를 헤더에 담은 후 200 OK 응답을 반환한다.
    - 브라우저에서는 304 응답을 받은 경우에는 캐시된 데이터를 사용하게 되고, 200 응답을 받은 경우에는 서버에 새로운 데이터를 요청한 후 Last-Modified 값을 갱신한다.

### URI, URL, URN의 정의에 대해 설명해 주시고, 예시와 함께 구분해 주세요.

**URI(Uniform Resource Identifier)**

- 통합 자원 식별자를 말한다.
- 인터넷에 있는 자원을 나타내는 유일한 주소를 말한다.
- URI의 존재는 인터넷에서 요구되는 기본조건으로 인터넷 프로토콜에 항상 붙어다닌다.
- 하위 개념으로는 URL, URN이 있다. (즉 URI는 상위개념)

**URL(Uniform Resource Locator)**

- 프로토콜(스키마)을 포함한 개념이다.
- 네트워크 상에서 자원이 어디있는지(Path)를 알려주기 위한 규약을 말한다.
- 일반적으로 사이트 도메인을 자주 의미한다.
- 웹 상 뿐만 아니라 컴퓨터 네트워크 상의 자원은 모두 나타낼 수 있다.

**URN(Uniform Resource Name)**

- 프로토콜(스키마)을 포함하지 않은 개념이다.
- 해당 자원의 이름(Name)을 의미한다.
- 자원에 대하여 영속적이고 유일하다.
- 위치에 독립적인 이름을 제공하기 위하여 존재한다.

### REST의 정의와 구성요소에 대해 설명해 주세요.

**REST란**

1. HTTP URI(Uniform Resource Identifier)를 통해 자원(Resource)을 명시하고,
2. HTTP Method(POST, GET, PUT, DELETE, PATCH 등)를 통해
3. 해당 자원(URI)에 대한 CRUD Operation을 적용하는 것을 의미합니다.

### **REST 구성 요소**

REST는 다음과 같은 3가지로 구성이 되어있다.

1. **자원(Resource) : HTTP URI**
2. **자원에 대한 행위(Verb) : HTTP Method**
3. **자원에 대한 행위의 내용 (Representations) : HTTP Message Pay Load**

(꼬리질문) REST의 특징은 무엇이 있나요?

HTTP 프로토콜을 이용하기 때문에 기본적으로 HTTP의 특징을 따라갑니다.

- Server-Client(서버-클라이언트 구조)
    - 서로 간 의존성이 줄어든다.
- Stateless(무상태)
- Cacheable(캐시 처리 가능)
- Layered System(계층화)
- Uniform Interface(인터페이스 일관성)

### REST API의 정의와 설계 규칙에 대해서 아는대로 설명해 주세요.

### REST API의 정의

- REST 기반으로 서비스 API를 구현한 것

### **REST API의 특징**

- 사내 시스템들도 REST 기반으로 시스템을 분산해 확장성과 재사용성을 높여 유지보수 및 운용을 편리하게 할 수 있다.
- REST는 HTTP 표준을 기반으로 구현하므로, HTTP를 지원하는 프로그램 언어로 클라이언트, 서버를 구현할 수 있다.

### REST API 설계 기본 규칙

- 도큐먼트 : 객체 인스턴스나 데이터베이스 레코드와 유사한 개념
- 컬렉션 : 서버에서 관리하는 디렉터리라는 리소스
- 스토어 : 클라이언트에서 관리하는 리소스 저장소

- URI는 정보의 자원을 표현해야 한다
    - resource는 동사보다는 명사를, 대문자보다는 소문자를 사용한다.
    - resource의 도큐먼트 이름으로는 단수 명사를 사용해야 한다.
    - resource의 컬렉션 이름으로는 복수 명사를 사용해야 한다.
    - resource의 스토어 이름으로는 복수 명사를 사용해야 한다.
      ex) GET /Member/1 -> GET /members/1
- 자원에 대한 행위는 HTTP Method(GET, PUT, POST, DELETE 등)로 표현한다.
    - URI에 HTTP Method가 들어가면 안된다.
      ex) GET /members/delete/1 -> DELETE /members/1
    - URI에 행위에 대한 동사 표현이 들어가면 안된다.(즉, CRUD 기능을 나타내는 것은 URI에 사용하지 않는다.)
      ex) GET /members/show/1 -> GET /members/1
      ex) GET /members/insert/2 -> POST /members/2
    - 경로 부분 중 변하는 부분은 유일한 값으로 대체한다.(즉, :id는 하나의 특정 resource를 나타내는 고유값이다.)
      ex) student를 생성하는 route: POST /students
      ex) id=12인 student를 삭제하는 route: DELETE /students/12

### REST API 설계 규칙

- 슬래시 구분자(/ )는 계층 관계를 나타내는데 사용한다.
  ex)http://restapi.example.com/houses/apartments
- URI 마지막 문자로 슬래시(/ )를 포함하지 않는다.
    - URI에 포함되는 모든 글자는 리소스의 유일한 식별자로 사용되어야 하며 URI가 다르다는 것은 리소스가 다르다는 것이고, 역으로 리소스가 다르면 URI도 달라져야 한다.
    - REST API는 분명한 URI를 만들어 통신을 해야 하기 때문에 혼동을 주지 않도록 URI 경로의 마지막에는 슬래시(/)를 사용하지 않는다.
      ex)http://restapi.example.com/houses/apartments/ (X)
- 하이픈(- )은 URI 가독성을 높이는데 사용
    - 불가피하게 긴 URI경로를 사용하게 된다면 하이픈을 사용해 가독성을 높인다.
- 밑줄(_ )은 URI에 사용하지 않는다.
    - 밑줄은 보기 어렵거나 밑줄 때문에 문자가 가려지기도 하므로 가독성을 위해 밑줄은 사용하지 않는다.
- URI 경로에는 소문자가 적합하다.
    - URI 경로에 대문자 사용은 피하도록 한다.
    - RFC 3986(URI 문법 형식)은 URI 스키마와 호스트를 제외하고는 대소문자를 구별하도록 규정하기 때문
- 파일확장자는 URI에 포함하지 않는다.
    - REST API에서는 메시지 바디 내용의 포맷을 나타내기 위한 파일 확장자를 URI 안에 포함시키지 않는다.
    - Accept header를 사용한다.
      ex)http://restapi.example.com/members/soccer/345/photo.jpg (X)
      ex) GET / members/soccer/345/photo HTTP/1.1 Host: restapi.example.com Accept: image/jpg (O)
- 리소스 간에는 연관 관계가 있는 경우
    - /리소스명/리소스 ID/관계가 있는 다른 리소스명
      ex) GET : /users/{userid}/devices (일반적으로 소유 ‘has’의 관계를 표현할 때)

### REST API 단점

- Over/UnderFetching이 발생할 수 있다.

## Over-Fetching

`Over-Fetching`이란, 필요한 데이터 이상으로 서버에서 데이터를 받아오는 것을 의미한다.

예를 들어, 인스타그램에서 친구 추천 페이지를 사용자에게 보여준다고 생각해보자.

유저의 정보에는 팔로워/팔로잉, 프로필 주소, 게시글 수 등의 여러 정보가 있다.

하지만, 친구 추천 페이지에서는 이 모든 정보가 필요한 것은 아니다.

```jsx
{
  users : [
    {
      // 필요한 정보
      name : "zzzz",
      url : "instagram.com/zzzz",
      follower : ["aaaa", "bbbb", "cccc"],
      // 필요없는 정보
      following : ["dddd", "eeee", "ffff"],
      posts : 20,
    },
    {
      // 필요한 정보
      name : "qwer",
      url : "instagram.com/qwer",
      follower : ["asdf", "zxcv", "qaz"],
      // 필요없는 정보
      following : ["mnbv", "ljjh", "iuu"],
      posts : 10,
    }
  ]

```

이와 같이 필요없는 데이터까지 받아와 서버와 자원이 낭비되는 것을 `Over-Fetching`이라고 한다.

## Under-Fetching

`Under-Fetching`이란, 한 번의 요청으로 필요한 데이터를 모두 받아오지 못해 여러 번의 요청을 수행하는 것을 의미한다.

예를 들어, 인스타그램의 메인 페이지에서는 다른 유저의 스토리, 게시글, 친구 추천 등 여러 화면이 한 곳에 나타나게 된다.

이러한 정보들은 `GET /users/{id}/story`, `GET /users/{id}/posts`처럼 여러 번의 요청이 필요하다.

이로 인해 네트워크의 지연이 발생할 수 있고, 사용자는 느린 로딩 속도로 인해 불편함을 겪을 수 있다.
