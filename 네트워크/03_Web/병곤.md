# 웹

- Web Server vs WAS
    
    # 웹 서버(Web Server, WS) vs 웹 애플리케이션 서버(Web Application Server, WAS)
    
    웹 서버와 웹 애플리케이션 서버는 웹 기반 서비스를 제공하는 데 중요한 역할을 하지만, 그 목적과 기능에서 차이가 있습니다.
    
    ## 웹 서버 (Web Server)
    
    웹 서버는 HTTP 프로토콜을 사용하여 클라이언트의 요청을 받고, 정적 콘텐츠(HTML, CSS, 이미지 등)를 제공하는 서버입니다.
    
    ### 주요 기능
    
    - **정적 콘텐츠 제공**: 클라이언트로부터의 HTTP 요청에 따라 정적 파일을 반환합니다.
    - **리다이렉트 기능**: 클라이언트 요청에 따라 다른 페이지로 리다이렉트할 수 있습니다.
    - **로드 밸런싱**: 여러 서버에 요청을 분산하여 처리하는 기능을 제공할 수 있습니다.
    
    ## 웹 애플리케이션 서버 (Web Application Server, WAS)
    
    웹 애플리케이션 서버는 웹 서버 기능을 포함하며, 동적 콘텐츠를 생성하기 위해 서버 사이드 스크립트(예: PHP, Java, [ASP.NET](http://asp.net/))를 처리할 수 있는 환경을 제공합니다.
    
    ### 주요 기능
    
    - **동적 콘텐츠 처리**: 클라이언트 요청에 따라 실시간으로 콘텐츠를 생성하고 반환합니다.
    - **데이터베이스 연동**: 데이터베이스 시스템과의 연동을 통해 데이터를 처리하고 저장합니다.
    - **비즈니스 로직 실행**: 애플리케이션의 비즈니스 로직을 처리할 수 있습니다.
    
    ## 비교
    
    - **콘텐츠 유형**: 웹 서버는 주로 정적 콘텐츠를, 웹 애플리케이션 서버는 동적 콘텐츠를 처리합니다.
    - **기능적 범위**: 웹 애플리케이션 서버는 웹 서버의 기능을 포함하며 추가적으로 애플리케이션 로직 처리 기능을 제공합니다.
    - **사용 사례**: 단순한 웹 페이지 호스팅에는 웹 서버가 적합하며, 복잡한 동적 웹 애플리케이션에는 웹 애플리케이션 서버가 필요합니다.
    
    웹 서버와 웹 애플리케이션 서버는 각각의 역할에 최적화되어 있으며, 현대의 웹 환경에서는 종종 함께 사용되어 보다 풍부하고 효율적인 웹 서비스를 제공합니다.
    
- Web Server
    - 사용 이유
        
        # 웹 서버의 중요성
        
        웹 서버(Web Server) 사용의 주요 목적은 웹 기반 콘텐츠와 애플리케이션을 안정적으로 호스팅하고, 사용자 요청에 대해 신속하고 효율적으로 응답하기 위함입니다. 웹 서버의 주요 이점을 구체적으로 살펴보면 다음과 같습니다:
        
        ## 정적 콘텐츠 제공
        
        - 웹 서버는 HTML, CSS, JavaScript 파일과 같은 **정적 콘텐츠**를 저장하고 제공합니다.
        - 사용자의 브라우저로부터 이러한 파일 요청을 받고, 네트워크를 통해 전송하여 웹사이트를 사용자에게 보여줍니다.
        
        ## 동적 콘텐츠와의 인터페이스
        
        - 웹 서버는 동적 콘텐츠 생성을 위해 **웹 애플리케이션 서버(WAS)**나 데이터베이스와 같은 백엔드 시스템과 통신합니다.
        - 사용자의 요청에 따라 동적으로 콘텐츠를 생성하고, 이를 사용자에게 전달합니다.
        
        ## 효율적인 리소스 관리와 배포
        
        - **로드 밸런싱**과 **캐싱** 기능을 통해 웹 리소스를 효율적으로 관리하고 배포합니다.
        - 동시에 다수의 사용자 요청을 처리할 수 있으며, 사용자에게 빠른 응답 시간을 제공합니다.
        
        ## 보안
        
        - **SSL/TLS**와 같은 보안 프로토콜을 구현하여 사용자와 서버 간의 데이터 전송을 암호화합니다.
        - 데이터의 기밀성과 무결성을 보장하며, 사용자 정보를 보호합니다.
        
        ## 접근 제어와 요청 필터링
        
        - 특정 IP 주소나 도메인으로부터의 요청을 차단하는 등의 **접근 제어** 기능을 제공합니다.
        - 요청을 필터링하여 악의적인 요청이나 공격을 사전에 차단할 수 있습니다.
        
        웹 서버는 웹사이트의 안정적인 운영과 빠른 콘텐츠 제공, 사용자 경험 개선, 웹 리소스의 효율적인 관리 및 보안 제공에 핵심적인 역할을 수행합니다.
        
    - Apache vs nginx
        
        # Apache vs Nginx
        
        Apache와 Nginx는 모두 강력한 웹 서버이며, 각각의 장단점이 있습니다. 이 문서는 두 서버의 주요 차이점을 비교하여 백엔드 개발자가 적합한 선택을 할 수 있도록 돕습니다.
        
        ## Apache
        
        Apache HTTP Server는 1995년부터 개발되어 온, 가장 널리 사용되는 웹 서버 중 하나입니다.
        
        ### 장점
        
        - **유연성**: 다양한 모듈을 통해 서버 기능 확장이 가능합니다. SSL/TLS, 프록시, 로깅 등의 기능을 모듈로 추가할 수 있습니다.
        - **.htaccess 파일 지원**: 디렉토리 수준에서의 설정 변경이 가능하며, 서버 재시작 없이 적용됩니다. 이는 개발자에게 높은 유연성을 제공합니다.
        - **풍부한 문서와 커뮤니티 지원**: 오랜 역사를 통해 구축된 방대한 문서와 활발한 커뮤니티 지원이 있습니다.
        
        ### 단점
        
        - **성능**: 동시 접속 처리에 있어 Nginx에 비해 성능이 떨어질 수 있습니다. 특히 정적 파일 처리와 고부하 상황에서 차이가 나타납니다.
        - **리소스 사용량**: 각 연결마다 별도의 프로세스(또는 스레드)를 생성하기 때문에, 리소스 사용량이 많아질 수 있습니다.
        
        ## Nginx
        
        Nginx는 비동기 이벤트 기반 구조를 사용하는 웹 서버로, 특히 동시 접속 처리에 강점을 가지고 있습니다.
        
        ### 장점
        
        - **성능**: 비동기 이벤트 기반 구조로 인해 높은 동시 접속 처리 성능을 제공합니다. 정적 파일 처리와 리버스 프록시 서버로서 우수한 성능을 발휘합니다.
        - **저리소스 사용량**: 연결마다 프로세스 또는 스레드를 생성하지 않고, 비동기 이벤트를 처리하기 때문에 적은 리소스로 많은 수의 연결을 처리할 수 있습니다.
        - **리버스 프록시 및 로드 밸런싱**: 웹 서버로서뿐만 아니라 리버스 프록시, 로드 밸런서로서도 뛰어난 성능을 보입니다.
        
        ### 단점
        
        - **.htaccess 파일 미지원**: Apache의 .htaccess 파일과 같은 디렉토리 수준의 설정 변경을 지원하지 않습니다. 설정 변경 시 서버 재시작이 필요할 수 있습니다.
        - **모듈 시스템**: Apache에 비해 모듈 시스템이 덜 유연할 수 있으며, 특정 기능을 위해 컴파일 시 모듈을 추가해야 할 수도 있습니다.
        
        ## 결론
        
        선택은 사용 사례에 따라 달라집니다. Apache는 유연성과 .htaccess 파일을 통한 디렉토리 수준 설정 변경이 중요한 경우에 적합할 수 있습니다. 반면, Nginx는 높은 동시 접속 처리 성능과 저리소스 사용량이 요구되는 환경, 그리고 리버스 프록시 및 로드 밸런싱 기능이 중요한 경우에 더 적합할 수 있습니다.
        
    - SSL offloading
        
        # SSL Offloading
        
        SSL Offloading은 웹 서버의 부하를 줄이기 위해 SSL/TLS 암호화 및 복호화 과정을 전담하는 별도의 장치나 서비스에 위임하는 기술입니다. 이 접근 방식은 특히 고성능이 요구되는 환경에서 웹 서버의 효율성을 크게 높일 수 있습니다.
        
        ## 작동 원리
        
        - 클라이언트는 SSL Offloading을 수행하는 장치에 SSL/TLS 연결을 시작합니다.
        - SSL Offloading 장치는 SSL/TLS 암호화를 해제하여 평문 데이터를 얻고, 이를 내부 네트워크의 웹 서버로 전달합니다.
        - 웹 서버는 암호화되지 않은 데이터를 처리하고 응답을 SSL Offloading 장치로 보냅니다.
        - SSL Offloading 장치는 웹 서버의 응답을 다시 암호화하여 클라이언트에게 전송합니다.
        
        ## 장점
        
        - **성능 향상**: SSL/TLS 암호화 및 복호화에 필요한 CPU 자원이 많은 작업을 웹 서버에서 제거함으로써, 웹 서버는 요청 처리에 더 많은 자원을 할당할 수 있습니다.
        - **스케일 아웃 용이성**: SSL Offloading을 사용하면, 암호화 처리를 위해 웹 서버를 추가로 확장하는 대신, 로드 밸런서나 리버스 프록시와 같은 전용 장치를 통해 더 쉽게 처리량을 증가시킬 수 있습니다.
        - **보안 강화**: SSL Offloading 장치는 보안 강화를 위한 추가 기능(예: SSL/TLS 프로토콜 필터링, 암호화 알고리즘 선택)을 제공할 수 있습니다.
        
        ## 단점
        
        - **비용 증가**: SSL Offloading을 위한 별도의 하드웨어 또는 소프트웨어 구매가 필요할 수 있습니다.
        - **복잡성 증가**: 네트워크 아키텍처에 추가 구성 요소가 도입되면서 전반적인 시스템 복잡성이 증가할 수 있습니다.
        
        SSL Offloading은 웹 애플리케이션의 성능 최적화와 보안 강화를 위한 유용한 전략 중 하나입니다. 그러나 도입 시 비용과 복잡성을 고려하여 전체 시스템 아키텍처에 적합한지 평가하는 것이 중요합니다.
        
    - reverse proxy, forward proxy
        
        ## Forward Proxy
        
        - 클라이언트와 인터넷 사이의 위치에 있는 Forward Proxy.
        - 클라이언트 대신 인터넷의 서버에 요청을 처리하는 역할 수행
        
        ### 주요 기능
        
        - **익명성 제공**: 인터넷에 대한 클라이언트의 IP 주소 숨김으로 익명성 보장
        - **콘텐츠 필터링 실행**: 정책 기반의 특정 웹사이트나 콘텐츠 접근 제한
        - **캐싱 가능성**: 자주 접근하는 리소스에 대한 로드 시간 단축을 위한 콘텐츠 캐싱
        
        ## Reverse Proxy
        
        - 인터넷과 서버 사이의 위치에 있는 Reverse Proxy.
        - 인터넷의 클라이언트로부터 오는 요청을 백엔드 서버로 전달 및 서버 응답의 클라이언트 반환 역할 담당
        
        ### 주요 기능
        
        - **부하 분산 기능**: 여러 서버에 걸쳐 들어오는 트래픽 분산으로 성능과 신뢰성 향상
        - **SSL 종료 처리**: SSL 암호화 및 복호화 작업의 백엔드 서버 오프로딩
        - **캐싱 기능**: 나가는 콘텐츠에 대한 캐싱으로 응답 시간 개선
        
        ## Load Balancing
        
        네트워크나 애플리케이션 트래픽을 여러 서버에 분산시켜 단일 서버 과부하 방지 및 신뢰성, 성능 향상을 위한 Load Balancing 기술
        
        ### 주요 기능
        
        - **효율적인 트래픽 분산**: 여러 서버에 걸쳐 들어오는 네트워크 트래픽의 효율적 분산
        - **확장성 용이성**: 트래픽 양에 따른 쉬운 확장 또는 축소
        - **서버 건강 상태 검사**: 현재 이용 가능한 서버로만 트래픽 유도를 위한 정기적인 건강 상태 확인
        
        웹 서비스의 관리와 확장성을 위한 중요 구성 요소로서 효율적 운영, 보안 강화, 사용자 경험 개선에 기여
        
    - load balancing
        - L7 vs L4
            
            # L4 vs L7 로드 밸런싱 비교
            
            L4(Layer 4) 로드 밸런싱과 L7(Layer 7) 로드 밸런싱은 트래픽 분산 방식에 있어 서로 다른 계층에서 작동합니다. 이들의 주요 차이점과 각각의 사용 사례를 비교해 보겠습니다.
            
            ## L4 로드 밸런싱
            
            L4 로드 밸런싱은 OSI 모델의 전송 계층에서 작동하며, IP 주소와 포트 번호를 기반으로 트래픽을 분산합니다.
            
            ### 주요 특징
            
            - **속도와 효율성**: 낮은 계층에서 작동하기 때문에 처리 속도가 빠르고 효율적입니다.
            - **단순한 결정 로직**: 연결을 기반으로 트래픽을 분산시키므로, 복잡한 처리 없이 빠른 결정이 가능합니다.
            - **프로토콜 지원**: TCP/UDP 트래픽 모두 처리할 수 있습니다.
            
            ### 사용 사례
            
            - 대량의 트래픽을 빠르게 처리해야 하는 경우
            - 애플리케이션 계층의 내용을 볼 필요가 없는 트래픽 관리
            
            ## L7 로드 밸런싱
            
            L7 로드 밸런싱은 OSI 모델의 응용 계층에서 작동하며, HTTP 헤더, URL, 쿠키 등과 같은 고급 데이터를 기반으로 트래픽을 분산합니다.
            
            ### 주요 특징
            
            - **고급 라우팅 결정**: HTTP/HTTPS 트래픽의 내용을 분석하여 더 정교한 라우팅 결정을 내릴 수 있습니다.
            - **응용 프로그램 수준의 인텔리전스**: 세션 지속성, 쿠키 기반 세션 정보 처리 등 응용 프로그램 수준에서 더 많은 기능을 제공합니다.
            - **콘텐츠 기반 라우팅**: URL 경로 또는 특정 HTTP 헤더를 기반으로 특정 서버로 트래픽을 라우팅할 수 있습니다.
            
            ### 사용 사례
            
            - 사용자의 세션 정보를 유지해야 하는 웹 애플리케이션
            - 콘텐츠 기반으로 트래픽을 분산시켜야 하는 경우 (예: REST API 엔드포인트 라우팅)
            
            ## 결론
            
            - **속도와 단순함이 필요한 경우** L4 로드 밸런싱이 적합할 수 있습니다.
            - **응용 프로그램의 로직에 따라 정교한 라우팅 결정이 필요한 경우** L7 로드 밸런싱이 더 나은 선택이 될 수 있습니다.
            
            각각의 로드 밸런싱 방식은 특정 요구 사항과 환경에 따라 장점을 가지며, 적절한 선택이 시스템의 성능과 안정성을 최적화하는 데 중요합니다.
            
        - 알고리즘
            
            # 로드 밸런싱 알고리즘
            
            로드 밸런싱 알고리즘은 서버에 들어오는 트래픽을 분산시키는 데 사용되는 다양한 방식을 제공합니다. 각 알고리즘은 특정 상황과 요구 사항에 따라 최적의 성능을 발휘할 수 있습니다.
            
            ## 라운드 로빈 (Round Robin)
            
            - 가장 단순하고 널리 사용되는 알고리즘으로, 순차적으로 각 서버에 요청을 분배합니다.
            - 모든 서버가 동일한 처리 능력을 가질 때 효과적입니다.
            
            ## 가중 라운드 로빈 (Weighted Round Robin)
            
            - 서버마다 처리 능력에 따라 가중치를 부여하고, 가중치가 높은 서버에 더 많은 요청을 할당합니다.
            - 서버의 성능 차이를 고려할 수 있어 더 유연한 트래픽 분배가 가능합니다.
            
            ## 최소 연결 (Least Connections)
            
            - 가장 적은 수의 활성 연결을 가진 서버에 새로운 요청을 할당합니다.
            - 동적인 웹 애플리케이션에 적합하며, 서버의 부하 상태를 더 정확하게 반영할 수 있습니다.
            
            ## 가중 최소 연결 (Weighted Least Connections)
            
            - 최소 연결 알고리즘에 서버의 가중치를 추가하여, 서버의 처리 능력과 현재 부하를 동시에 고려합니다.
            - 서버의 성능과 부하 상태를 모두 반영하는 더 세밀한 트래픽 분배 방식입니다.
            
            ## IP 해시 (IP Hash)
            
            - 클라이언트의 IP 주소를 해싱하여 특정 서버에 요청을 지속적으로 할당합니다.
            - 사용자의 세션 지속성을 유지하는 데 유용하며, 특정 사용자가 항상 동일한 서버로 연결되도록 합니다.
            
            ## URL 해시 (URL Hash)
            
            - 요청 URL을 기반으로 해싱하여 특정 유형의 요청을 특정 서버에 할당합니다.
            - 비슷한 유형의 요청을 처리하는 데 특화된 서버에 트래픽을 집중시킬 수 있습니다.
            
            각 로드 밸런싱 알고리즘은 서버 환경, 트래픽 패턴, 애플리케이션의 요구 사항에 따라 선택되어야 합니다. 적절한 알고리즘을 선택하는 것은 시스템의 성능과 안정성을 최적화하는 데 중요한 역할을 합니다.
            
- Cache
    
    # 웹에서 사용되는 캐시
    
    웹 캐시는 웹 트래픽과 서버 부하를 줄이고, 사용자에게 더 빠른 콘텐츠 로딩 시간을 제공하기 위해 사용됩니다. 다음은 웹에서 주로 사용되는 캐시의 유형들입니다.
    
    ## 브라우저 캐시
    
    - 사용자의 브라우저에 저장되는 캐시입니다.
    - 자주 방문하는 웹사이트의 리소스를 로컬에 저장하여, 페이지 로딩 시간을 단축합니다.
    - CSS 파일, JavaScript, 이미지 등 정적 리소스에 주로 사용됩니다.
    
    ## 프록시 캐시
    
    - 네트워크 상의 프록시 서버에 저장되는 캐시입니다.
    - 여러 사용자가 공통으로 접근하는 웹 리소스를 캐싱하여, 네트워크 대역폭 사용을 줄이고 접근 시간을 단축합니다.
    - 기업이나 ISP(Internet Service Provider)에서 주로 사용됩니다.
    
    ## CDN(Content Delivery Network) 캐시
    
    - 전 세계에 분산된 서버 네트워크에 저장되는 캐시입니다.
    - 지리적으로 분산된 사용자에게 웹 콘텐츠를 빠르게 제공하기 위해 사용됩니다.
    - 웹사이트의 글로벌 사용자 경험을 개선하는 데 효과적입니다.
    
    ## 리버스 프록시 캐시
    
    - 웹 서버 앞단에 위치하는 리버스 프록시 서버에 저장되는 캐시입니다.
    - 외부에서의 요청을 받아 캐싱된 데이터를 제공하거나, 필요 시 실제 서버로 요청을 전달합니다.
    - 서버 부하를 줄이고, 보안성을 향상시키며, 콘텐츠 전송 속도를 개선합니다.
    
    ## 캐시 전략
    
    - **캐시 만료 정책**: 캐시된 리소스의 유효 기간을 정하여, 오래된 캐시는 자동으로 삭제됩니다.
    - **검증 토큰(Etag, Last-Modified)**: 리소스가 변경되었는지 확인하기 위해 사용되며, 변경되지 않았다면 캐시된 버전을 재사용합니다.
    - **캐시 제어 헤더**: HTTP 헤더를 통해 캐시 동작을 제어합니다. (`Cache-Control`, `Pragma` 등)
    
    캐시는 웹 성능 최적화의 핵심 요소로, 적절한 캐시 전략과 설정을 통해 사용자 경험을 대폭 향상시킬 수 있습니다.
    
- URI, URL, URN
    
    # URI, URL, URN에 대한 설명
    
    ## URI (Uniform Resource Identifier)
    
    - **정의**: 인터넷에서 자원을 식별하는 유일한 주소입니다.
    - **목적**: 인터넷 상의 자원을 식별하고 위치를 지정하는 데 사용됩니다.
    - **예시**: `http://example.com/path/to/file`는 웹 자원을 가리키는 URI입니다.
    
    ## URL (Uniform Resource Locator)
    
    - **정의**: 인터넷 상의 자원이 위치하는 곳을 나타내는 주소입니다. URI의 한 형태로, 자원의 위치와 접근 방법을 제공합니다.
    - **구성**: 프로토콜(예: http, https), 호스트 이름, 포트 번호, 경로(path) 등으로 구성됩니다.
    - **예시**: `http://www.example.com/index.html`은 웹 페이지의 위치를 나타내는 URL입니다.
    
    ## URN (Uniform Resource Name)
    
    - **정의**: 자원을 위치에 상관없이 이름만으로 식별하는 URI의 한 형태입니다. 위치가 변하더라도 동일한 자원을 가리킬 수 있습니다.
    - **특징**: 자원의 위치가 아니라, 이름으로 자원을 식별합니다. 따라서 자원의 위치가 변경되더라도 URN은 변하지 않습니다.
    - **예시**: `urn:isbn:0451450523`는 특정 책을 식별하는 URN입니다. 여기서 `isbn`은 책의 국제 표준 도서 번호를 나타냅니다.
- Rest API
    
    # REST API에 대한 기본 개념
    
    ## REST (Representational State Transfer)란?
    
    - **정의**: 웹 표준을 활용하여 서버와 클라이언트 간의 통신 규약을 정의한 아키텍처 스타일입니다.
    - **특징**: HTTP 프로토콜을 사용하여 자원을 표현하는 방법에 중점을 둡니다.
    
    ## REST의 주요 원칙
    
    1. **클라이언트-서버 구조**: 클라이언트와 서버는 서로 독립적으로 분리되어 있어야 합니다.
    2. **무상태성(Stateless)**: 각 요청은 독립적이며, 이전 요청의 상태 정보를 저장하지 않습니다.
    3. **캐시 처리 가능(Cacheable)**: 웹 표준 HTTP 프로토콜을 그대로 사용하기 때문에, HTTP가 가진 캐싱 기능을 적용할 수 있습니다.
    4. **계층화(Layered System)**: 클라이언트는 서버에 직접 연결되었는지, 중간에 프록시 서버를 통해 연결되었는지 알 수 없습니다.
    5. **코드 온 디맨드(Code on demand, 선택 사항)**: 서버에서 클라이언트로 코드를 전송하여 실행할 수 있습니다(예: 자바스크립트).
    6. **인터페이스 일관성(Uniform Interface)**: 애플리케이션의 아키텍처를 단순화하고, 분리하여 독립적으로 진화할 수 있도록 합니다.
    
    ## REST API란?
    
    - **정의**: REST 기반으로 서비스 API를 구현한 것입니다. 웹(HTTP)의 장점을 최대한 활용할 수 있는 아키텍처입니다.
    - **구성 요소**:
        - **자원(Resource)**: URI를 이용하여 표현됩니다.
        - **행위(Verb)**: HTTP 메소드(GET, POST, PUT, DELETE 등)를 사용합니다.
        - **표현(Representations)**: 자원의 상태(데이터)를 전달하기 위해, JSON 또는 XML을 주로 사용합니다.
    
    ## REST API의 장점
    
    - **플랫폼 독립적**: 다양한 플랫폼과 언어에서 사용할 수 있습니다.
    - **높은 확장성**: URL 형식과 HTTP 표준 프로토콜을 사용하여, 응용 프로그램을 쉽게 확장할 수 있습니다.
    - **브라우저와의 호환성**: HTTP 프로토콜을 사용하기 때문에, 웹 브라우저에서 쉽게 접근할 수 있습니다.
    - **간단한 인터페이스**: HTTP 표준 메소드를 통해 자원에 접근할 수 있어 개발자가 사용하기 쉽습니다.