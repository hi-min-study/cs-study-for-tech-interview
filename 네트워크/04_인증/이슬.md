# 📍 키워드
- 인증
    - 인증(authentication)과 인가(authorization)의 차이
    - 쿠키
    - 세션
    - JWT
    - 쿠키, 세션, JWT 차이

<br>

# 📍 예상 질문
## 인증/인가
- 인증과 인가의 차이점에 대해 설명해주세요.
    - 인증(Authentication)과 인가(Authorization)는 보안에 있어서 중요한 개념이고, 종종 혼동되기도 합니다. 하지만 이 둘은 각각 다른 목적과 과정을 가지고 있습니다.
    - 인증 (Authentication): 인증은 시스템이 사용자의 신원을 확인하는 과정입니다. 사용자가 누구인지 확인하는 것이죠. 예를 들어, 로그인 과정에서 아이디와 비밀번호를 입력하는 것이 인증 과정입니다. 이 단계에서 시스템은 사용자가 주장하는 자신의 신원이 정말로 그 사용자의 것인지를 검증합니다.
    - 인가 (Authorization): 인증 과정 후에 이루어지는 것이 인가입니다. 이는 인증된 사용자가 어떤 자원에 접근할 수 있는지, 어떤 행동을 할 수 있는지를 결정하는 과정입니다. 예를 들어, 어떤 웹사이트에서 관리자는 모든 페이지에 접근할 수 있지만 일반 사용자는 일부 페이지에만 접근할 수 있는 것이 인가의 예시입니다.
    - 결국, 인증은 '당신이 누구인가?'를 확인하는 과정이고, 인가는 '당신이 무엇을 할 수 있는가?'를 결정하는 과정입니다. 이 두 과정은 보안 체계를 구축하는데 있어서 결합되어 사용되며, 서로를 보완합니다.

## 쿠키, 세션, JWT
- 쿠키와 세션에 대해 설명해 주세요.
    - 쿠키 (Cookie): 쿠키는 클라이언트(사용자의 컴퓨터나 브라우저)에 저장되는 작은 텍스트 파일입니다. 쿠키는 사용자가 웹 사이트를 방문할 때 생성되며, 사용자의 브라우저를 통해 서버에 다시 전송됩니다. 쿠키는 사용자의 선호 설정, 로그인 정보 등을 저장하는데 사용됩니다. 쿠키는 사용자가 웹 사이트를 다시 방문했을 때 이전 방문 정보를 기억할 수 있게 해줍니다.
    - 세션 (Session): 세션은 서버 측에서 관리되는 데이터입니다. 사용자가 웹 사이트에 로그인하면 서버는 세션 ID를 생성하고, 이를 사용자의 브라우저에 전송합니다. 이 세션 ID는 쿠키를 통해 저장되며, 사용자가 웹 사이트를 방문할 때마다 이 세션 ID를 통해 사용자를 식별합니다. 세션은 쿠키보다 보안에 더 안전하며, 더 큰 데이터를 저장할 수 있습니다.
- 쿠키와 세션의 차이에 대해 설명해 주세요.
    - 저장 위치
        - 쿠키는 클라이언트의 웹 브라우저가 지정하는 메모리 or 하드 디스크에 저장됩니다.
        - 세션은 서버의 메모리에 저장됩니다.
    - 만료 시점
        - 쿠키는 저장할 때, expires 속성을 정의하여 무효화시키면 삭제될 날짜를 지정할 수 있습니다.
        - 세션은 클라이언트가 로그아웃하거나 설정 시간 동안 반응이 없으면 무효화되기 때문에 정확한 시점을 알 수 없습니다.
    - 리소스
        - 쿠키는 클라이언트에 저장되고 클라이언트의 메모리를 사용하기 때문에 서버 자원을 사용하지 않습니다.
        - 세션은 서버에 저장되고, 서버 메모리로 로딩되기 때문에 세션이 생길 때마다 서버의 자원을 사용합니다.
    - 용량 제한
        - 쿠키는 클라이언트도 모르게 접속되는 사이트에 의하여 설정될 수 있기 때문에 쿠키로 인해 문제가 발생하는 걸 막고자 한 도메인당 20개, 하나의 쿠키당 4KB로 제한해 두었습니다.
        - 세션은 클라이언트가 접속하면 서버에 의해 생성되므로 개수나 용량 제한이 없습니다.
    - 보안
        - 쿠키는 클라이언트에 저장하기 때문에 보안에 취약합니다.
        - 세션은 서버에 저장하기 때문에 쿠키에 비해서는 보안에 우수합니다.

- 쿠키와 세션을 각각 어느 상황에 사용하실 건지 설명해주세요.
    - 쿠키(Cookie)의 사용
        - 주로 사용자의 설정 정보나 사이트 선호도를 기억하는데 사용됩니다. 예를 들어, 사용자가 언어 설정을 한국어로 선택했다면, 이 정보를 쿠키에 저장하여 사용자가 사이트를 다시 방문할 때마다 한국어로 표시되게 할 수 있습니다. 또한, 쿠키는 장바구니 정보를 저장하는데도 사용됩니다. 사용자가 상품을 장바구니에 담고 사이트를 나갔다가 나중에 다시 방문했을 때, 이전에 담았던 상품이 여전히 장바구니에 있어야 합니다. 이런 정보는 쿠키에 저장됩니다.
        - 로그인 정보 유지 쿠키는 로그인 정보를 클라이언트(브라우저)에 저장하여 다음에 애플리케이션에 접속할 때 자동으로 로그인되도록 할 수 있습니다. 사용자가 "로그인 상태 유지" 옵션을 선택하면 쿠키에 인증 토큰 또는 세션 ID를 저장하여 재인증 없이 애플리케이션에 접근할 수 있습니다.
    - 세션(Session)의 사용
        - 주로 사용자의 로그인 상태를 유지하는 데 사용됩니다. 사용자가 웹사이트에 로그인했을 때, 서버는 세션을 생성하고 이를 통해 사용자의 로그인 상태를 유지합니다. 이후 사용자가 페이지를 이동하거나 다른 행동을 취할 때마다, 서버는 세션을 확인하여 사용자가 로그인 상태인지 확인합니다. 이렇게 함으로써 사용자는 매번 로그인을 하지 않아도 됩니다. 또한, 세션은 사용자의 특정 활동을 추적하거나 서버에서 처리해야 하는 다른 복잡한 작업에 사용될 수 있습니다.

- 쿠키로 로그인 정보를 관리하면 왜 위험할까요? 
    - 쿠키 탈취: 쿠키는 클라이언트 측에 저장되므로, 악성 코드나 취약점을 통해 쿠키가 탈취될 수 있습니다. 쿠키에 로그인 정보가 저장되어 있다면, 이것은 곧 사용자 계정의 접근 권한이 탈취당했다는 것을 의미합니다.
    - 중간자 공격: 쿠키는 사용자의 웹 브라우저와 서버 사이를 왔다갔다 하며, 이 과정에서 쿠키 정보가 중간에서 가로채일 수 있습니다. 이를 중간자 공격(MITM, Man-In-The-Middle Attack)이라고 합니다.

- 단일 서버를 이용할 때 세션으로 로그인 관리를 하게 되면 세션을 어디에다가 저장하실 예정이신가요?
    - 단일 서버를 이용할 때, 세션 정보는 주로 서버의 메모리 내에 저장됩니다. 이 방법은 세션 정보를 빠르게 액세스할 수 있다는 장점이 있습니다. 서버의 메모리를 사용하면, 사용자의 요청에 대해 빠르게 응답할 수 있으므로 사용자 경험을 향상시키는 데 도움이 됩니다.
    - 그러나 이 방법의 단점은 서버의 메모리가 한정되어 있으므로, 많은 양의 세션 정보를 저장하려면 메모리 부족 문제가 발생할 수 있다는 것입니다. 또한, 서버가 다운되거나 재시작되면 메모리 내의 모든 세션 정보가 사라지게 됩니다.
    - 이런 문제를 해결하기 위해, 대안으로 데이터베이스나 캐시 저장소(Redis 등)를 사용하여 세션 정보를 저장하는 방법도 있습니다. 이 방법은 서버가 다운되거나 재시작되더라도 세션 정보가 유지될 수 있게 하며, 많은 양의 세션 정보를 저장할 수 있게 합니다. 하지만, 이 방법은 데이터베이스나 캐시 저장소에 접근하는 데 추가적인 시간이 걸리므로, 성능에 영향을 미칠 수 있습니다.
    - 따라서, 어디에 세션 정보를 저장할지 결정할 때는 사용자의 요구, 사이트의 트래픽, 서버의 리소스 등을 고려하여 결정해야 합니다.

- 규모가 커져 서버가 여러 개가 된다면, 세션을 어떻게 관리할 수 있을까요?
    - 세션 클러스터링: 세션 클러스터링은 모든 서버가 세션 정보를 공유하는 방식입니다. 사용자의 요청이 어느 서버로 가든 해당 서버는 모든 세션 정보에 접근할 수 있습니다. 이 방식의 장점은 사용자의 요청을 처리하는 서버가 바뀌어도 세션 정보가 유지된다는 것입니다. 하지만, 이 방식은 서버 간에 세션 정보를 동기화해야 하므로 서버 간 네트워크 트래픽이 증가하고, 세션 정보가 많아질수록 각 서버의 메모리 부하가 커집니다.
    - 세션 스토어: 세션 스토어는 세션 정보를 중앙 데이터베이스나 캐시 저장소(예: Redis, Memcached)에 저장하는 방식입니다. 이 방식을 사용하면, 사용자의 요청을 처리하는 서버가 바뀌더라도 중앙 세션 스토어에서 동일한 세션 정보를 가져올 수 있습니다. 이렇게 하면 서버 간의 세션 정보 동기화 문제를 피할 수 있지만, 세션 정보를 가져오기 위해 네트워크를 거쳐야 하므로 세션 정보 접근 시간이 늘어날 수 있습니다.
    - 스티키 세션: 스티키 세션은 로드 밸런서가 특정 클라이언트의 요청을 항상 같은 서버로 라우팅하는 방식입니다. 이 방식은 사용자의 세션을 유지하는 데 효과적입니다. 스티키 세션을 사용하면, 사용자가 처음 요청을 보낼 때 로드 밸런서가 이 요청을 특정 서버에 할당하고, 이후로는 해당 사용자의 모든 요청을 같은 서버로 라우팅합니다. 이 방식을 사용하면, 세션 데이터가 서버의 메모리에 저장되어 있어도 문제가 되지 않습니다. 왜냐하면 모든 요청이 같은 서버로 라우팅되기 때문에 세션 데이터에 항상 접근할 수 있기 때문입니다. 하지만 이 방식은 몇 가지 단점이 있습니다. 한 서버에 과도하게 부하가 집중되는 경우가 생길 수 있고, 해당 서버가 다운되면 해당 서버에 연결된 사용자의 세션 정보가 모두 손실될 수 있습니다. 또한, 스케일링에 제약이 있을 수 있습니다. 새 서버를 추가하더라도, 기존 서버에 할당된 클라이언트의 요청은 그대로 유지되기 때문에 새 서버는 초기에는 별다른 효과를 보지 못할 수 있습니다.

- 개발하면서 쿠키를 사용해보신 적 있으신가요?
    - 네, 개발 과정에서 쿠키를 사용해본 경험이 있습니다. 특히 JWT를 구현하면서, 보안성을 높이기 위해 Refresh Token을 쿠키로 저장하는 방식을 사용했습니다.
    - JWT와 Refresh Token 방식을 사용하면서, 액세스 토큰은 짧은 유효기간을 가지도록 설정하고, Refresh Token은 긴 유효기간을 가지도록 설정했습니다. 사용자가 사이트에 접속할 때마다, Refresh Token을 이용해 새로운 액세스 토큰을 발급받게 했습니다.
    - 이 때, Refresh Token은 클라이언트 측에서 접근할 수 없도록 HttpOnly 쿠키에 저장했습니다. 이렇게 하면, XSS 공격을 통한 토큰 탈취를 방지할 수 있습니다. 또한, 중간자 공격을 방지하기 위해 Secure 쿠키 옵션을 사용하여, 쿠키가 HTTPS를 통해서만 전송되도록 했습니다.
    - 이런 방식을 통해, JWT의 편리함과 쿠키의 보안성을 동시에 활용할 수 있었습니다.

- JWT 토큰에 대해서 간단히 설명해주세요.
    - JWT는 웹 표준으로 정의된 토큰 기반의 인증 방식입니다. 
    - JWT는 JSON 형식으로 정보를 암호화하여 토큰으로 생성하며, 클라이언트와 서버 간에 인증과 정보 교류에 사용됩니다.
    - JWT는 토큰 자체에 정보를 포함하고 있어 서버에서 별도의 세션 저장소를 필요로하지 않으며, 클라이언트 측에서 토큰을 저장하여 사용합니다. JWT는 클라이언트가 발급한 토큰을 서버에서 검증하고 신뢰함으로써 인증 및 권한 부여를 수행합니다.
    - JWT는 세 부분으로 구성되어 있습니다: 헤더(Header), 페이로드(Payload), 시그니처(Signature).
        - 헤더 (Header): 헤더는 토큰의 유형과 사용되는 해시 알고리즘 정보를 포함합니다. 일반적으로 JWT와 HMAC SHA256 또는 RSA와 같은 알고리즘이 사용됩니다.
        - 페이로드 (Payload): 페이로드는 실제 전달하려는 데이터를 포함합니다. 이는 사용자의 세부 정보나 권한 같은 것들이 될 수 있습니다.
        - 시그니처 (Signature): 시그니처는 헤더와 페이로드를 비밀 키로 해싱하여 생성됩니다. 이 시그니처를 통해 토큰의 무결성을 검증할 수 있습니다.

- 세션 방식 또는 JWT 토큰을 이용해서 구현해보신 경험이 있으신가요? 있으시다면 왜 해당 방식을 채택했는지 궁금합니다.
    - 네, 제가 이전에 참여한 프로젝트에서는 OAuth 로그인 후 JWT를 사용하여 인증과 인가를 처리하는 방식을 채택했습니다. 이 방식을 선택한 이유는 다음과 같습니다.
    - 효율성과 유연성: JWT는 클라이언트의 상태를 추적할 필요가 없으므로, 서버의 리소스를 효율적으로 사용할 수 있었습니다. 또한, JWT 내에는 사용자에 대한 정보가 포함되어 있어, 추가적인 조회 없이도 사용자 인증과 인가를 처리할 수 있었습니다.
    - 보안: JWT는 자체적으로 정보의 무결성을 보장하기 때문에, 데이터의 변조를 방지할 수 있었습니다.
    - 위와 같은 이유로 JWT 방식을 채택하였고, 이를 통해 사용자 관리, 서비스 간 인증 및 인가 처리 등을 효율적으로 수행할 수 있었습니다.

- JWT를 이용할 때 RefreshToken을 같이 사용하면 좋은 점은 무엇일까요?
    - 보안 강화: JWT는 만료 시간이 지나면 더 이상 유효하지 않게 됩니다. 따라서, 만약 토큰이 탈취당하더라도, 만료 시간이 지나면 그 토큰은 더 이상 사용할 수 없게 됩니다. 하지만 만료 시간을 짧게 설정하면 사용자가 자주 로그인해야 하는 불편함이 있습니다. 이런 문제를 해결하기 위해 Refresh Token을 사용합니다. Refresh Token은 주로 긴 유효기간을 가지고 있으며, 이를 통해 새로운 JWT를 발급받을 수 있습니다. 이 방식을 사용하면, JWT의 짧은 유효기간으로 인한 보안성을 유지하면서도 사용자에게 편의성을 제공할 수 있습니다.
    - 토큰 갱신: 사용자의 권한이 변경되었을 때, 기존의 JWT는 이를 반영하지 못합니다. 이런 경우에도 Refresh Token을 사용하여 새로운 JWT를 발급받으면, 변경된 권한 정보를 새 토큰에 반영할 수 있습니다.
    - 사용자 경험 향상: Refresh Token을 사용하면, 사용자는 한 번 로그인하면 긴 시간 동안 로그인 상태를 유지할 수 있습니다. 이는 사용자가 자주 로그인해야 하는 번거로움을 줄여줍니다.
    - 따라서, JWT와 Refresh Token을 함께 사용하면 보안성, 토큰의 유연한 관리, 사용자 경험 향상 등의 장점을 얻을 수 있습니다.






<br>

# 📍 Reference
- https://github.com/VSFe/Tech-Interview/blob/main/03-NETWORK.md
- https://github.com/dev-team-study/cs-study/tree/main/%5B1%ED%9A%8C%EC%B0%A8%5D2.network/11_%EB%B3%B4%EC%95%88_%EC%9D%B8%EC%A6%9D