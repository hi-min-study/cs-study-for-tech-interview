### 로그인을 할 때 쿠키가 아닌 세션을 이용하는 이유가 뭔가요?

쿠키는 기본적으로 정보가 클라이언트 측에서 관리되기 때문에 악용될 우려가 있고, 보안에 취약하여 정보가 탈취당할 위험성이 존재합니다. 따라서 로그인 관련 정보는 클라이언트 측이 아닌, 서버측에서 관리하는 세션을 이용하는것이 바람직합니다.

### 쿠키, 세션, JWT의 차이점을 설명해 주세요.

쿠키 : stateless. 사용자의 브라우저에 저장

세션 : stateful. 서버에 별도의 저장공간 필요

jwt : stateless. 사용자의 브라우저에 저장되지만 민감한 정보는 시그니처에 암호화 되어 저장된다.

### 인증/인가의 차이가 무엇인가요? 예시를 들어서 설명해 주세요.

인증 : 식별 가능한 정보들로 서비스에 등록된 사용자의 신원을 확인하는 절차.

인가 : 어떤 리소스에 대해서 접근권한이 있는지 확인하는 절차.

인증은 식별 가능한 정보들인 아이디/비밀번호를 이용하여 사이트에 로그인 하는 것.

인가는 특정 게시판은 어떠한 등급 이상이 이용가능하다는 요구사항이 있을 때, 해당 회원의 등급을 조사하여 허용여부를 결정하는 행위.

### 프로젝트에서 인증/인가를 어떻게 구현하셨나요?

Oauth2를 이용하여 인증을 진행하고, 별도로 jwt access token, refresh 토큰을 발행하여 이후의 인증/인가를 진행했습니다.

(꼬리질문) 왜 그렇게 구현하셨나요?

먼저 로그인, 회원가입 과정은 직접 구현할 수 있었지만, 프로젝트 특성 상 다양한 개인정보를 입력받을 필요가 없다고 생각되어 소셜로그인을 이용하여 기본적인 개인정보만 빠르게 받아올 수 있는 동시에, 사용자의 아이디 비밀번호를 서버에서 별도로 관리하지 않도록 하여 보안성 또한 높이기 위해서입니다.

또한 인증은 세션,쿠키,jwt토큰을 이용하여 할 수 있는데, 세션,쿠키를 사용하지 않은 이유는

세션은 서버에 별도의 저장공간이 필요하다는 단점이 있고, 쿠키는 통신과정에서 보안상의 위험이 있기 때문에 사용하지 않았습니다.

(꼬리질문) 보안성을 어떻게 확보하셨나요?

개인정보가 담긴 시그니처를 base64url encode방식으로 인코딩 한 이후에 시크릿키로 다시한번 시그니처 암호화 알고리즘을 적용하여 jwt 기능만으로 보안성을 확보하였습니다. 만약 통신과정에 토큰이 탈취되어 변형되더라도 서버측에서 시그니처의 위/변조를 확인하여 보안성을 확보하였습니다.

### 스프링에서 세션은 서버의 어디에 저장되나요?

서블릿 컨테이너인 톰캣 내부에 저장됩니다.

### 쿠키의 장/단점에 대해 설명해 주세요

### 장점

- 간단하게 구현할 수 있으며, 서버 측에 저장하지 않고 클라이언트 측에 데이터를 저장한다.
- 쿠키는 만료일이 지나기 전까지 계속 유효하며, 클라이언트 측에서도 쉽게 삭제할 수 있다.
- 다른 도메인에서 사용할 수 있는 경우 쿠키를 공유할 수 있다.

### 단점

1. 정보가 클라이언트 측에서 관리되기 때문에 악용될 우려가 있고, 보안에 취약하여 정보가 탈취당할 위험성이 존재한다.
2. 쿠키에는 용량 제한이 있어 많은 정보를 담을 수 없다.
3. **네트워크 트래픽이 추가**되기 때문에, 쿠키의 사이즈가 커질수록 네트워크에 부하가 심해진다.
4. 웹 브라우저마다 쿠키에 대한 지원 형태가 다르기 때문에 브라우저간 공유가 불가능하다.

(꼬리질문) 쿠키의 동작순서에 대해 설명해 주세요.

1. 클라이언트가 페이지를 요청
2. 서버에서 쿠키를 생성
3. set cookie 헤더에 쿠키를 포함 시켜 응답
4. 브라우저가 종료되어도 쿠키 만료 기간이 있다면 클라이언트에서 보관하고 있음
5. 같은 요청을 할 경우 cookie 헤더에 쿠키를 함께 보냄
6. 서버에서 쿠키를 읽어 이전 상태 정보를 변경 할 필요가 있을 때 쿠키를 업데이트 하여 변경된 쿠키를 HTTP 헤더에 포함시켜 응답

### 세션의 장/단점에 대해 설명해 주세요.

### 장점

- 세션 데이터는 서버에 저장(Spring의 경우 기본적으로 톰캣 내부에 저장)되므로 보안성이 높다.
- 세션은 클라이언트 측에서 관리되지 않기 때문에 쿠키보다 안전하다.
- 데이터 용량이 제한되어 있지 않으므로 많은 양의 데이터를 저장할 수 있다.

### 단점

- 서버 측에 저장되므로, 서버의 자원을 사용한다.
- 쿠키를 포함한 요청이 외부에 노출되더라도 세션Id 자체에는 유의미한 개인정보를 담고있지 않다. 그러나, 탈취자가 세션Id 자체를 탈취하여 클라이언트인척 위장할 수 있다는 한계가 있다.
- 사용자가 많아질수록 서버의 부하가 증가할 수 있다.
- 세션은 일정 시간이 지나면 자동으로 만료되지만, 만료 시간을 지정해주지 않으면 계속해서 사용될 수 있습니다. 이 경우 보안상의 위험이 있다.
- 다중 서버 환경으로 scale out되게 되면, 같은 사용자가 두번 이상 로그인을 해야 하는 상황이 있을 수 있다. → Sticky session, 세션 클러스터링 등으로 극복.

- (꼬리질문) 세션의 동작순서에 대해 설명해 주세요.
1. 클라이언트가 서버에 접속 시 세션 ID를 발급 받음
2. 클라이언트는 세션 ID에 대해 쿠키를 사용해서 저장하고 가지고 있음
3. 클라리언트는 서버에 요청할 때, 이 쿠키의 세션 ID를 같이 서버에 전달해서 요청
4. 서버는 세션 ID를 전달 받아서 별다른 작업없이 세션 ID로 세션에 있는 클라언트 정보를 가져와서 사용
5. 클라이언트 정보를 가지고 서버 요청을 처리하여 클라이언트에게 응답

### 보안상 세션이 쿠키보다 뛰어난 것 같아요. 그러면 무조건 세션만 쓰는게 좋나요?

세션은 서버에 별도의 저장공간이 필요하다는 단점이 있습니다. 따라서 정말 보안이 필요한 개인정보를 다루는 기능을 쓸 때에는 세션을 이용하고, 그렇지 않고 단순히 광고에 필요한 사용자 트래킹 정보 등을 제공하는 데에는 쿠키를 사용하여 서버의 부담을 줄이는 데 쓰는 것이 좋다고 생각합니다.

### jwt의 구성요소에 대해 설명해 주세요.

1. 헤더
- 서명 시 사용하는 키(kid), 사용할 타입(typ), 서명 암호화 알고리즘(alg)의 정보가 담겨 있습니다.
- kid : 서명 시 사용하는 키(Public/Private Key)를 식별하는 값
- typ : 토큰 유형
- alg : 서명 암호화 알고리즘 HS256(HMAC SHA-256), HS512, RS256(RSASSA SHA-256), ES256(ECDSA P-256 curve SHA-256)
1. 페이로드
- 토큰에서 사용할 정보의 조각들인 클레임(Claim)이 담겨 있습니다.
- 클레임(Claim)은 Key/Value 형태로 된 값을 가집니다.
- 저장되는 정보에 따라 등록된 클레임(Registered Claims), 공개 클레임(Public Claims), 비공개 클레임(Private Cliams)로 구분됩니다.
- iss : 토큰 발급자(issuer) – Public Claims
- sub : 토큰 제목(subject) – Public Claims
- iat : 토큰 발급 시간(issued at) – Public Claims
- exp : 토큰 만료 시간(expiration) – Public Claims
- roles : 권한 – Private Cliams
1. 시그니쳐
- Header(헤더) 에서 정의한 알고리즘 방식(alg)을 활용합니다.
- Header(헤더)+ 페이로드(Payload)와 서버가 갖고 있는 유일한 key 값을 합친 것을 헤더에서 정의한 알고리즘으로 암호화합니다.
- Header, Payload 를 Base64 URL-safe Encode 를 한 이후 Header 에 명시된 해시함수를 적용하고, 개인키(Private Key)로 서명한 전자서명이 담겨있다.

### jwt의 장/단점에 대해 설명해 주세요.

### 장점

- Header와 Payload를 가지고 Signature를 생성하므로 데이터 위변조를 막을 수 있다.
- 인증 정보에 대한 별도의 저장소가 필요없다.
- JWT는 토큰에 대한 기본 정보와 전달할 정보 및 토큰이 검증됬음을 증명하는 서명 등 필요한 모든 정보를 자체적으로 지니고 있다.
- 클라이언트 인증 정보를 저장하는 세션과 다르게,서버는 무상태(StateLess)가 되어 서버 확장성이 우수해질 수 있다.
- 토큰 기반으로 다른 로그인 시스템에 접근 및 권한 공유가 가능하다. (쿠키와 차이)

### 단점

- Self-contained : 토큰 자체에 정보를 담고 있으므로 양날의 검이 될 수 있다.
- 토큰 길이 : 토큰의 Payload에 3종류의 클레임을 저장하기 때문에, 정보가 많아질수록 토큰의 길이가 늘어나 네트워크에 부하를 줄 수 있다.
- Payload 인코딩 : payload 자체는 암호화 된 것이 아니라 BASE64로 인코딩 된 것이기 때문에, 중간에 Payload를 탈취하여 디코딩하면 데이터를 볼 수 있으므로, payload에 중요 데이터를 넣지 않아야 한다.
- Store Token : stateless 특징을 가지기 때문에, 토큰은 클라이언트 측에서 관리하고 저장한다. 때문에 토큰 자체를 탈취당하면 대처하기가 어렵게 된다.
- 이미 발급된 JWT에 대해서는 돌이킬 수 없다. 세션 / 쿠키의 경우 만일 쿠키가 악의적으로 이용되고 있다면,해당하는 세션을 지워버리면 된다.하지만 JWT는 한번 발급되면 유효기간이 완료될 때까지 계속 사용이 가능하다.따라서 악의적인 사용자는 유효기간이 지나기 전까지 정보를 털어갈 수 있다.

- (꼬리질문) jwt의 동작순서에 대해서 말해주세요.
1. 사용자가 ID, PW를 입력하여 서버에 로그인 인증을 요청한다.
2. 서버에서 클라이언트로부터 인증 요청을 받으면, Header, PayLoad, Signature를 정의한다.
   Hedaer, PayLoad, Signature를 각각 Base64로 한 번 더 암호화하여 JWT를 생성하고 이를 쿠키에 담아 클라이언트에게 발급한다.
3. 클라이언트는 서버로부터 받은 JWT를 로컬 스토리지에 저장한다. (쿠키나 다른 곳에 저장할 수도 있음)
   API를 서버에 요청할때Authorization header에 Access Token을 담아서 보낸다.
4. 서버가 할 일은 클라이언트가 Header에 담아서 보낸 JWT가 내 서버에서 발행한 토큰인지 일치 여부를 확인하여 일치한다면 인증을 통과시켜주고 아니라면 통과시키지 않으면 된다.
   인증이 통과되었으므로 페이로드에 들어있는 유저의 정보들을 select해서 클라이언트에 돌려준다.
5. 클라이언트가 서버에 요청을 했는데, 만일 액세스 토큰의 시간이 만료되면 클라이언트는 리프래시 토큰을 이용해서 서버로부터 새로운 엑세스 토큰을 발급 받는다.

### jwt를 사용할 때 refresh token은 왜 사용하나요?

JWT 인증 방식을 만약 Access Token 만을 이용하면, Access Token은 발급된 이후 서버에 저장되지 않고 클라이언트에 저장되어 토큰 자체로 검증을 하며 사용자 권한 인증을 진행하기 때문에, Access Token이 탈취되면 토큰이 만료되기 전 까지, 토큰을 획득한 사람은 누구나 권한 접근이 가능해지는 문제점이 있었다.
그래서 토큰의 유효 시간을 부여하여 탈취 문제에 대해 대응을 하기도 하지만, 만일 유효 기간이 짧을 경우 그만큼 사용자는 로그인을 자주해야 하는 번거로움이 있다.
따라서 이러한 문제를 해결하기 위해 Refresh Token 이라는 추가적인 토큰을 활용하여 토큰을 이중 장막을 쳐서 보다 보안을 강화하는 식으로 보면 된다.

### 다중 서버 환경에서의 세션의 한계에 대해 말해 주시고, 극복 방법에 대해 설명해 주세요.

A,B,C서버가 있다고 가정하겠습니다. 어떤 사용자가 A서버에서 로그인을 진행하여 세션이 만들어지고, 이후 http 통신 중 B서버로 요청이 들어가게 되면 B서버에서는 세션이 만들어지지 않았기 때문에, 사용자는 다시 로그인을 해야 하는 문제점이 생깁니다.

이에 대해서는 stick session, session clustering, 세션 스토리지 분리 등으로 극복합니다.

### Sticky session

예를 들어, User1 이 1번부터 3번까지의 서버 중 1번 서버에 세션을 생성하였다면, 이후에 User1이 보내는 모든 요청은 1번 서버로만 보내지게 됩니다. 즉, Load Balancer는 User가 첫 번째 세션을 생성한 서버로 모든 요청을 리다이렉트 하여 고정된 세션만 사용하게 합니다.

이를 위해서 로드 밸런서는 요청을 받으면 가장 먼저 요청에 쿠키가 존재하는지 확인합니다. 쿠키가 있으면 해당 요청이 쿠키에 지정된 서버로 전송됩니다. 쿠키가 없는 경우에는 로드 밸런서가 기존 로드 밸런싱 알고리즘을 기반으로 서버를 선정합니다.

동일한 사용자가 계속 해당 서버에 요청을 보낼 수 있도록 지속적으로 서버 정보가 쿠키를 통해 응답에 삽입되어 보내집니다.

### 단점

고정된 세션을 사용한다는 것은 특정 서버에 트래픽이 집중될 위험이 있습니다.

### Session Clustering

All-to-all Session Replication과 Primary-secondary 세션 복제로 나뉜다.

### All-to-all Session Replication

all-to-all 세션 복제란 하나의 세션 저장소에 변경되는 요소가 발생하면 변경된 사항이 다른 모든 세션에 복제가 된다는 것을 말합니다.

### 단점

모든 서버가 동일한 세션 객체를 가져야 하기 때문에 많은 메모리가 필요합니다.

또한 세션 저장소에 데이터가 저장될 때마다 모든 서버에 값을 입력해야 하므로 서버 수에 비례하여 네트워크 트래픽이 증가하는 등 성능 저하가 발생하게 됩니다.

### Primary-secondary 세션 복제

Primary 서버는 Secondary(Backup) 서버에 세션 객체의 Key-Value 전체를 복제합니다. 하지만, 이외의 서버에는 Key에 해당하는 JSESSION ID만을 복제하기 때문에 메모리 사용이 all-to-all 방식보다 줄어들게 됩니다.

### 단점

세션을 복제하는데 걸리는 시간은 줄일 수 있었으나, Primay 서버와 Secondary 서버를 제외한 Proxy 서버에 세션 정보를 요청할 경우에는 다시 Primary 서버에 요청하여 해당 Key에 해당하는 객체를 받아와야만 합니다.
