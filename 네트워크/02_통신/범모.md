- 통신
    - TCP
        - 흐름제어, 혼잡제어, 오류제어
        - 3-way-handshake, 4-way-handshake
    - UDP
    - HTTP
        - HTTP status code
        - HTTP method
            - 종류
            - 멱등성
            - PUT, PATCH, POST method 차이
        - HTTP 1.1, 2.0, 3.0
        - HTTP 헤더
    - HTTPS, SSL/TLS
        - 동작 원리
        - 공개키 대칭키 방식
    - DNS

### **TCP(Transmission Control Protocol)**

1. 연결형 서비스로 **가상 회선 방식**을 제공 : 3-way handshaking 과정을 통해 연결을 설정하고,4-way handshaking 과정을 통해 연결을 해제한다.

2. 흐름 제어(Flow control) : 데이터 처리 속도를 조절하여 수신자의 버퍼 오버플로우를 방지

3. 혼잡 제어(Congestion control) : 네트워크 내의 패킷 수가 과도하게 증가하지 않도록 방지

4. 높은 신뢰성을 보장 : 신뢰성이 높은 전송을 하기 때문에 UDP보다 속도가 느림

5. 전이중(Full-Duplex), 점대점(Point to Point) 방식

- 전이중(Full-Duplex) : 전송이 양방향으로 동시에 일어날 수 있다.
- 점대점(Point to Point) : 각 연결이 정확히 2개의 종단점을 가지고 있다.

### TCP Tahoe

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/f161c15f-c5f0-4683-9793-c7551a62792f/12cb5572-88e6-497f-b932-72800e69d14f/Untitled.png)

**처음에는 동일하게 Slow Start 방식으로 윈도우를 증가시키다가 `ssthresh` 시점 이후부터는 AIMD 방식을 사용**한다.

이후 `TimeOut` 이나 `3 ACK Duplicated` 상황이 발생 시 네트워크가 혼잡하다는 것을 인지하고 ssthresh 는 혼잡상황 발생시 윈도우 사이즈의 절반으로, 윈도우 사이즈는 1로 수정하는 방식이다.

그림에서 검정색 선으로 표시된 부분이 ssthresh 를 의미하고, `TimeOut` 이나 `3 ACK Duplicated` 이 발생할 때 마다 윈도우는 1로, ssthresh는 이전 혼잡 상황 발생시 윈도우 크기의 절반으로 줄어드는 것을 확인할 수 있다.

하지만 이 방법에선 혼잡 상황이 발생할 때 마다 윈도우를 1로 초기화해 다시 증가시켜 나가는 부분이 비효율적이라 할 수 있다. 이러한 점을 개선시키기 위해 `빠른 회복` 을 적용한 `TCP Reno` 정책이 있다.

### TCP Reno

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/f161c15f-c5f0-4683-9793-c7551a62792f/7232daf3-ac62-49ce-94da-a2f45a627514/Untitled.png)

TCP Tahoe 정책과 동일하지만 차이점은 바로 **3 ACK Duplicated 와 TimeOut 을 구분해 대응한다는 점이다!**

`3 ACK Duplicated` 이 발생하면 윈도우 크기를 1로 초기화 하지 않고 **AIMD 처럼 윈도우 크기를 절반으로 줄이며 ssthresh 값 역시 줄어든 윈도우 값으로 설정한다.**

이러한 방식으로 빠르게 윈도우 사이즈를 회복시켜 네트워크 대역폭을 사용하도록 하고, 이를 빠른 회복 (Fast Recovery) 라 한다!

`TimeOut`이 발생한다면 TCP Tahoe 와 동일하게 **윈도우 사이즈를 1로 줄이고 Slow Start 를 시작하지만 ssthresh 값은 변경하지 않는다.**

그림에서도 timeout 이 발생한 경우에는 ssthresh 값이 유지되는 것을 볼 수 있다. 즉 timeout에 비해 3 ACK Duplicated 는 그리 심각한 혼잡상황이라고 판단하지 않는 듯 하다.

### **UDP(User Datagram Protocol)**

1. 비연결형 서비스로 **데이터그램 방식**을 제공한다.데이터의 전송 순서가 바뀔 수 있다.

2. 데이터 수신 여부를 확인하지 않는다.TCP의 3-way handshaking과 같은 과정 X

3. 신뢰성이 낮다.흐름 제어(flow control)가 없어서 제대로 전송되었는지, 오류가 없는지 확인할 수 없다.

4. TCP보다 속도가 빠르다.

5. 1:1 & 1:N & N:N 통신이 가능하다.

(1). UDP는 비연결형 서비스이기 때문에, 

(2). 연결을 설정하고 해제하는 과정이 존재하지 않는다.서로 다른 경로로 독립적으로 처리하며,  

(3). 흐름 제어 또는 혼잡 제어와 같은 기능을 처리하지 않기에 

(4). TCP보다 속도가 빠르며 네트워크 부하가 적다는 장점이 있지만, 신뢰성 있는 데이터 전송을 보장하지 못한다.

(5). UDP는 신뢰성보다는 연속성 있는 전송이 필요할 때 사용하는 프로토콜로 예를 들면, 실시간 서비스(streaming)에 자주 사용된다.

(6). 스트림으로 데이터를 전송하며 데이터가 손상되지 않고 도착했는지 확인하기 위한 체크섬만 있다.

(7). Port만 확인하여 소켓을 식별하고 송수신한다.

### 패킷 교환 방법 중 데이터그램 교환 방식과 가상 회선 방식에 대해 간단히 설명해 주세요.

- 데이터그램 패킷 교환 방식
    - 데이터를 전송하기 전에 논리적 연결이 설정되지 않으며 패킷이 독립적으로 전송된다.
    - 이를 데이터그램이라 한다.
    - 패킷을 수신한 라우터는 최적의 경로를 선택하여 패킷을 전송하는데 하나의 메시지에서 분할된 여러 패킷은 서로 다른 경로로 전송될 수 있다.(**비연결 지향형**)
        - **송신 측에서 전송한 순서와 수신 측에 도착한 순서가 다를 수 있다.**
- 가상회선 패킷 교환 방식
    - 데이터를 전송하기 전에 논리적 연결이 설정되는데, 이를 가상회선이라고 한다.(**연결 지향형**)
    - 각 패킷에는 가상회선 식별 번호(VCI)가 포함되고, 모든 패킷을 전송하면 가상회선이 해제되고 패킷들은 전송된 순서대로 도착한다.
    - 데이터 그램은 패킷마다 라우터가 경로를 선택하지만,
    - 가상회선 방식은 경로를 설정할 때 한 번만 수행한다.

### UDP와 TCP의 공통점과 차이점에 대해서 간단하게 설명해 주세요.

공통점

- 전송계층에서 사용되는 프로토콜입니다.
- 포트 번호를 이용하여 주소를 지정합니다.
- 데이터 오류 검사를 위한 체크섬 필드가 존재합니다.

차이점

|  | TCP | UDP |
| --- | --- | --- |
| 연결 방식 | 연결형 | 비연결형 |
| PDU | 세그먼트 | 데이터그램 |
| 패킷 교환 방식 | 가상 회선 방식 | 데이터그램 방식 |
| 전송 순서 | 보장함 | 바뀔 수 있음 |
| 수신 여부 확인 | 확인함 | 확인하지 않음 |
| 통신 방식 | 1:1 | 1:1 또는 1:N 또는 N:N |
| 신뢰성 | 높다 | 낮다 |
| 속도 | 느리다 | 빠르다 |
| 헤더의 크기 | 20바이트 | 8바이트 |
| 용도 | 신뢰성이 필요한 데이터를 전송 | 실시간 데이터 전송, 브로드캐스트, 멀티캐스트, 소량의 데이터 빈번히 전송 |

### UDP의 비신뢰성의 문제와 TCP는 어떤 방법으로 신뢰성을 확보했는지 설명해 주세요.

비신뢰성의 문제

1. **손실** : packet이 손실될 수 있는 문제
2. **순서 바뀜** : packet의 순서가 바뀌는 문제
3. **Congestion** : 네트워크가 혼잡한 문제
4. **Overload** : receiver가 overload 되는 문제

극복

흐름제어, 혼잡제어, 오류제어

### 흐름제어에 대해 설명해 주시고, 흐름제어의 기법 2가지에 대해 설명해 주세요.

- 수신측이 송신측보다 데이터 처리 속도가 빠르면 문제없지만, 송신측의 속도가 빠를 경우 문제가 생긴다.
- 수신측에서 제한된 저장 용량을 초과한 이후에 도착하는 데이터는 손실 될 수 있으며, 만약 손실 된다면 불필요하게 응답과 데이터 전송이 송/수신 측 간에 빈번이 발생한다.
- 이러한 위험을 줄이기 위해 송신 측의 데이터 전송량을 수신측에 따라 조절해야한다.

1. **Stop and Wait** : 매번 전송한 패킷에 대해 확인 응답을 받아야만 그 다음 패킷을 전송하는 방법
2. **Sliding Window**
    
    수신 측에서 설정한 윈도우 크기만큼 송신 측에서 확인 응답(ACK) 없이 패킷을 전송할 수 있게 하여 데이터 흐름을 동적으로 조절하는 제어 기법.
    
    - **Window** : TCP/IP를 사용하는 모든 호스트들은 송신하기 위한 것과 수신하기 위한 2개의 Window를 가지고 있다. 호스트들은 실제 데이터를 보내기 전에 '3 way handshaking'을 통해 수신 호스트의 receive window size에 자신의 send window size를 맞추게 된다.
    
    윈도우 크기
    
    - 최초의 윈도우 크기는 호스트들의 '3 way handshaking'을 통해 수신 측 윈도우 크기로 설정되며, 이후 수신 측의 버퍼에 남아있는 공간에 따라 변한다.
    

### 혼잡제어에 대해 설명해 주세요.

- 송신측의 데이터는 지역망이나 인터넷으로 연결된 대형 네트워크를 통해 전달된다. 만약 한 라우터에 데이터가 몰릴 경우, 자신에게 온 데이터를 모두 처리할 수 없게 된다. 이런 경우 호스트들은 또 다시 재전송을 하게되고 결국 혼잡만 가중시켜 오버플로우나 데이터 손신을 발생시키게 된다. 따라서 이러한 네트워크의 혼잡을 피하기 우해 송신측에서 보내는 데이터의 전송속도를 강제로 줄이게 되는데, 이러한 작업을 혼잡제어라고 한다.
- 또한 네트워크 내에 패킷의 수가 과도하게 증가하는 현상을 혼잡이라 하며, 혼잡 현상을 방지하거나 제거하는 기능을 **혼잡제어**라고 한다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/f161c15f-c5f0-4683-9793-c7551a62792f/3018cb78-1b61-4f36-bf2a-85aef08ca0ac/Untitled.png)

- **AIMD(Additive Increase / Multiplicative Decrease)**
    - 처음에 패킷을 하나씩 보내고 이것이 문제없이 도착하면 window 크기(단위 시간 내에 보내는 패킷의 수)를 1씩 증가시켜가며 전송하는 방법
    - 패킷 전송에 실패하거나 일정 시간을 넘으면 패킷의 보내는 속도를 절반으로 줄인다.
    - 공평한 방식으로, 여러 호스트가 한 네트워크를 공유하고 있으면 나중에 진입하는 쪽이 처음에는 불리하지만, 시간이 흐르면 평형상태로 수렴하게 되는 특징이 있다.
    - 문제점은 초기에 네트워크의 높은 대역폭을 사용하지 못하여 오랜 시간이 걸리게 되고, 네트워크가 혼잡해지는 상황을 미리 감지하지 못한다. 즉, 네트워크가 혼잡해지고 나서야 대역폭을 줄이는 방식이다.
- **Slow Start (느린 시작)**
    - AIMD 방식이 네트워크의 수용량 주변에서는 효율적으로 작동하지만, 처음에 전송 속도를 올리는데 시간이 오래 걸리는 단점이 존재했다.
    - Slow Start 방식은 AIMD와 마찬가지로 패킷을 하나씩 보내면서 시작하고, 패킷이 문제없이 도착하면 각각의 ACK 패킷마다 window size를 1씩 늘려준다. 즉, 한 주기가 지나면 window size가 2배로 된다.
    - 전송속도는 AIMD에 반해 지수 함수 꼴로 증가한다. 대신에 혼잡 현상이 발생하면 window size를 1로 떨어뜨리게 된다.
    - 처음에는 네트워크의 수용량을 예상할 수 있는 정보가 없지만, 한번 혼잡 현상이 발생하고 나면 네트워크의 수용량을 어느 정도 예상할 수 있다.
    - 그러므로 혼잡 현상이 발생하였던 window size의 절반까지는 이전처럼 지수 함수 꼴로 창 크기를 증가시키고 그 이후부터는 완만하게 1씩 증가시킨다.
- **Fast Retransmit (빠른 재전송)**
    - 빠른 재전송은 TCP의 혼잡 조절에 추가된 정책이다.
    - 패킷을 받는 쪽에서 먼저 도착해야할 패킷이 도착하지 않고 다음 패킷이 도착한 경우에도 ACK 패킷을 보내게 된다.
    - 단, 순서대로 잘 도착한 마지막 패킷의 다음 패킷의 순번을 ACK 패킷에 실어서 보내게 되므로, 중간에 하나가 손실되게 되면 송신 측에서는 순번이 중복된 ACK 패킷을 받게 된다. 이것을 감지하는 순간 문제가 되는 순번의 패킷을 재전송 해줄 수 있다.
    - 중복된 순번의 패킷을 3개 받으면(3 ACK Duplicated) TimeOut 시간이 만료되지 않았어도 ****재전송을 하게 된다. 약간 혼잡한 상황이 일어난 것이므로 혼잡을 감지하고 window size를 줄이게 된다.
- **Fast Recovery (빠른 회복)**
    - 혼잡한 상태가 되면 window size를 1로 줄이지 않고 반으로 줄이고 선형증가시키는 방법이다. 이 정책까지 적용하면 혼잡 상황을 한번 겪고 나서부터는 순수한 AIMD 방식으로 동작하게 된다.
- (꼬리질문) 흐름제어와 혼잡제어의 차이가 무엇인가요?
    - 흐름제어가 송신측과 수신측 사이의 전송속도를 다루는데 반해, 혼잡제어는 호스트와 라우터를 포함한, 보다 넓은 관점에서 전송 문제를 다루게 된다.

### **혼잡제어를 위해 송신자 전송 트래픽 전송률을 어떻게 제한하는가?**

- TCP에서는 **혼잡 윈도우를** 이용하여 송신 측에서 전송할 수 있는 트래픽을 제한한다.

이전에 TCP 흐름제어에서 다룬 내용에 의하면 송신 측은 수신 윈도우의 크기에 따라 트래픽이 결정된다고 했다. (송신 버퍼에서 확인응답이 안 된 데이터는 한 번에 보낸 데이터의 양이라고 생각할 수 있다. 이를 **송신 윈도우**라고 하자.)

이제 혼잡제어 까지 생각한다면 결국 송신 윈도우는 수신 윈도우와 혼잡 윈도우의 최솟값보다 작아야 한다.

### 혼잡 윈도우

사실 송신측의 윈도우 크기는 수신측이 보내준 윈도우 크기와 네트워크 상황을 함께 고려해서 정해지게 된다.

송신측은 자신의 최종 윈도우 크기를 정할 때, 수신측이 보내준 윈도우 크기인 `수신자 윈도우(RWND)` 와 자신이 네트워크 상황을 고려해 정한 `혼잡 윈도우(CWND)` 중에서 더 작은 값을 택한다.

결국 송신자가 조절하는 **윈도우 크기란 정확하게는 송신측이 가지고 있는 혼잡 윈도우 크기** 인 것이다.

아래 내용에서 이렇게 저렇게 조절되는 윈도우란 바로 혼잡 윈도우 라고 생각하면 되겠다.

- LastByteSent - LastByteAcked ≤ min(cwnd, rwnd)

### **혼잡을 어떻게 감지하는가?**

과도한 혼잡이 발생하면 라우터에 오버플로가 발생하고 데이터그램이 버려질 것이다. 결국 송신 측에서는 타임아웃 또는 3개의 중복된 ACK가 발생한다.

TCP에서는 타임아웃 이벤트를 중복된 3개의 ACK가 발생한 경우보다 더 혼잡한 상태로 판단한다.(TCP Tahoe 버전에서는 동일하게 처리한다.) 중복된 ACK는 적어도 손실된 세그먼트 이후의 순서번호를 가진 세그먼트들은 성공적으로 도착했다고 생각할 수 있기 때문이다.

### 오류제어에 대해 설명해 주세요.

> ARQ (Automatic Repeat Request. 자동 반복 요청): 통신에서 발생하는 오류를 감지하고 복구하여 신뢰성을 제공해주기 위해 패킷 전송 중에 재전송을 요청하는 기술 및 프로토콜
> 

TCP는 기본적으로 재전송 기반의 오류 제어를 사용한다.

2-1. Go Back N 

- 수신측에서 설정한 윈도우 크기만큼 송신측에서 확인응답 없이 세그먼트를 전송할 수 있게 하여 데이터 흐름을 동적으로 조절하는 제어기법
1. sender는 ACK를 받지 않은 상태로 동시에 최대로 보낼 수 있는 패킷의 수인 window size를 설정
2. sender는 send_base 및 nextseqnum 설정
→ send_base: 송신자가 이미 보냈지만 아직 ACK를 받지 못한 가장 첫번째 패킷의 시퀀스 번호
→ nextseqnum: 송신자가 현재 전송할 수 있는 다음 패킷의 시퀀스 번호
3. 수신자는 패킷들을 연속해서 받고, 각각의 패킷을 받을 때마다 sequence number를 확인하고 ACK를 전송
→ N번까지 잘받았다 
→ Culmulative Ack
→ 패킷이 유실되어 sequence number에 빈틈이 생기면, 빈틈이 생기기전 정상적으로 받은 가장 마지막 패킷 번호를 ACK에 담아 보낸다.
→ 수신자는 정상적으로 받은 마지막 패킷 sequence number를 rcv_base에 기록한다.
→ Go-Back-N 방식에서는 수신자가 버퍼를 가지고 있지 않는다.
    
    !https://velog.velcdn.com/images/taegon1998/post/30d0d7d0-1173-48cd-b45b-2afba13f43f0/image.png
    
4. 송신자는 보낸 패킷의 ACK가 정상적으로 왔다면, 패킷 처리 후 window를 오른쪽으로 한 칸 sliding 한다.
- 장점 : 손실된 데이터부터는 모두 송신측으로부터 재전송되므로 receiver는 해당 데이터들을 버퍼링 할 필요가 없다.
- 단점 : 제대로 전송된 데이터들도 다시 보내야 하기 때문에 비효율적이다.
- Cumulative Acknowledge
    - 수신자가 n번 패킷까지 정상적으로 받았다면 ACK(n)을 피드백하는것.
- 예시
    
    !https://velog.velcdn.com/images/taegon1998/post/71a227e6-7daf-4f7d-b79a-c7f444cb176f/image.png
    
    1. window size: 4
    2. sender: 0, 1, 2, 3번 패킷을 한꺼번에 전송→ 2번 패킷 loss
    3. receiver는 패킷들을 받고 0, 1번 패킷에 대해서는 ACK→ rcv_base에 1 저장
    4. rcv_base + 1 = 2가 아닌 3번을 수신했음으로 packet loss 감지 & ACK(1)를 보낸다.
    5. sender는 ACK(0)과 ACK(1) 을 받고 중복된 ACK가 아니라면, 해당 번호의 패킷을 완료처리 & sliding window를 진행한다.→ 4번 패킷 & 5번 패킷 전송
    6. 이후 다시 ACK(1)이 들어오게 되면 중복된 ACK를 감지하고 window를 sliding하지 않고 무시한다.
    7. ACK를 받지 못한 2번 패킷에 대해 timeout이 발생하면 2번 패킷부터 모든 패킷을 재전송한다.

2-2. Selective Repeat

- 등장배경
    - 정상적으로 도착한 패킷이더라도 손실 패킷 이후 모든 패킷들을 재전송해야 하기 때문에 비효율적일 수 있다.
        
        이를 개선하여 Selective Repeat 방식이 등장했다.
        

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/f161c15f-c5f0-4683-9793-c7551a62792f/e6178e38-0fef-4309-ba30-dcccff7d5ae4/Untitled.png)

1. sender는 window size 설정
2. window size 내에 들어있는 패킷들을 전부 송신 후 ACK을 기다림→ 각각의 패킷에 대해 타이머를 가지고 있어 time-out을 활용해 재전송 한다.
3. Selective repeat 방식에서는 수신자가 버퍼를 가지고 있다.
    - 수신 패킷 처리: 수신자는 들어오는 패킷의 시퀀스 번호를 확인하여 rcv_base에 저장된 시퀀스 번호와 어긋난다면 패킷들을 임시로 버퍼에 저장해 둔다
    - 순서에 맞는 패킷 도착 & ACK 전송: 이후에 순서에 맞는 패킷이 도착하면, 수신자는 버퍼에 저장된 패킷들을 모아 상위 계층으로 전달한다.
    - 윈도우 슬라이딩: ACK 전송 횟수만큼 송신자의 윈도우가 슬라이딩된다.
4. 특정 패킷에 대해 ACK가 들어오면 그 패킷을 완료 기록→ 송신자가 보낸 패킷들 중 아직 ACK되지 않은 패킷들 중 가장 번호가 작은 패킷이 ACK되면 window를 sliding
- 예시
    
    !https://velog.velcdn.com/images/taegon1998/post/37cf66e1-6176-4c05-b058-84e72a932518/image.png
    
    1. 송신자는 아직 2번 패킷에 대해 ACK가 오지 않았기 때문에, ACK3에 대해 완료 처리를 하지만 window는 이동시키지 않는다.
    2. 수신자의 경우 3, 4, 5번 패킷에 대해서 ACK를 보내지만, 상위 레이어에 deliver 하지는 않는다.
    3. 2번 패킷이 들어와 순서대로 패킷이 나열되었을 때, 버퍼에 저장한 패킷들과 상위 레이어로 한꺼번에 보내며 ACK들도 송신자에게 한꺼번에 보낸다.
    4. ACK2가 송신자에게 도착하면 2번 패킷을 완료처리 & window를 한 칸 sliding한다.→ 6번 패킷 전송

### Go BacK N과 SR의 차이 : 수신자의 버퍼에 패킷 저장 유무

(꼬리질문) SR의 문제점에 대해서 설명해 주세요.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/f161c15f-c5f0-4683-9793-c7551a62792f/b98d1085-3a87-4486-9e8e-c0fa3bca212b/Untitled.png)

- 답변
    - 0 1 2 3 0 1 2의 패킷이 들어와야 한다고 가정하겠습니다.
    - 0 1 2 3패킷의 ACK이 모두 유실되어 맨 처음의 0이 타임아웃돼서 다시 보내지만, 수신자는 네번째에 들어와야 하는 0번패킷이 들어온 것으로 착각해 버리는 문제가 발생합니다.
- 해결
    - window size를 (sequence number 갯수 / 2) 이하로 잡는다.

### TCP의 보안 취약점에 대해 설명해 주세요.

https://blog.naver.com/techtrip/222561492285

https://daengsik.tistory.com/30

### **1.4 보안 취약점**

이러한 Handshaking 과정들을 연결 수립, 종료마다 수행하기 때문에 속도가 비교적 느리다는 단점을 가지지만 굉장히 안정적인 시스템으로 보입니다. 하지만 보안 취약점 역시 존재합니다. 대표적으로 **SYN Flooding** 공격이 있는데 이 생소해 보이는 공격이 바로 **DDoS(분산 서비스 거부) 공격의 일종** 입니다.

연결을 맺을 때 서버는 클라이언트의 SYN을 받고 연결작업 수행을 위해 서버의 자원인 메모리를 할당합니다. 이 할당된 부분을 Queue 라고 하는데, 엄청나게 많은 수의 클라이언트가 SYN 요청을 보내고, 서버가 SYN, ACK를 보냈음에도 불구하고 다시 ACK를 보내지 않는다면 서버는 많은 수의 클라이언트들의 응답을 기다리며 메모리를 계속 할당한 상태로 있게 됩니다.

결국 메모리가 바닥나면 서버가 제 기능을 하지 못하게 되겠죠. 3 Way Handshake를 안 할 수도 없고, 공격을 당하고 있을수만도 없으니 아래와 같은 방어대책을 세우게 됩니다.

### **1. 백로그 큐 늘리기**

메모리를 늘려서 수용 인원을 늘립니다. 비용이 많이 들고 무한정 확장시킬 수 없으니 근본적인 해결책은 아니겠습니다. 원래 예측되는 사용자 수를 충분히 수용하고도 남을 정도의 메모리를 확보하지만 보안공격은 일반적인 상황이 아니기에 완벽히 대처할 수 없습니다.

### **2. Anti-DDoS 사용**

특정 IP에서 SYN 요청이 갑자기 수십개 수백개가 온다면 접속을 일정시간 차단시키는 방법입니다. 이를 임계치 기반 방어라 합니다.

### **3. SYN Cookie 사용**

서버와 사용자간에 방화벽을 두고 방화벽이 정상적인 사용자인지 먼저 확인합니다. 방화벽과 먼저 3 Way Handshake를 해보고, 정상적이면 연결을 수립할 수 있게 트래픽을 서버로 넘겨주는겁니다. 결과적으로 방화벽과 한번, 서버와 한번 하여 Handshake를 두번 하게 되겠지만 일반적으로 사용자는 이 지연시간을 체감하기 힘듭니다.

### **4. SYN Proxy 사용**

3과 비슷한 방식입니다. 굳이 체감은 못하지만 Handshake를 두번 하는게 굉장히 불편하죠. 방화벽과 Handshake를 성공적으로 수행하면 서버에서 굳이 한번 더 Handshake 할 필요가 없으니 방화벽이 서버에게 Handshake를 재현시켜주어서 한번의 Handshake로 연결을 수립할 수 있게 하는 방식입니다.

### **3-way handshake 과정에 대해 설명해 주세요.**

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/f161c15f-c5f0-4683-9793-c7551a62792f/115403b4-8387-4ab1-88ea-c372c477ab20/Untitled.png)

1. 클라이언트는 접속을 요청하는 SYN 패킷을 보낸다. 이때 클라이언트는 응답을 기다리기위해 SYN_SENT 상태로 변한다.
2. LISTEN 상태였던 서버는 SYN 요청을 받으면, 클라이언트에게 요청을 수락하는 ACK 패킷과 SYN 패킷을 보낸다. (서버도 클라이언트에 접속해야 양방향 통신이 되기 때문에)
그리고 SYN_RCVD(SYN_RECEIVED)상태로 변하여 클라이언트가 ACK 패킷을 보낼 때 까지 기다리게 된다.
3. 클라이언트는 다시 서버에 ACK 패킷을 보내고, 이 후 ESTABLISHED 상태가 되어 데이터 통신이 가능하게 된다.

### **4-way handshake 과정에 대해 설명해 주세요.**

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/f161c15f-c5f0-4683-9793-c7551a62792f/bff8a49d-079f-484d-b4ea-f60fb9496791/Untitled.png)

1. 서버와 클라이언트가 TCP 연결이 되어있는 상태에서 클라이언트가 접속을 끊기 위해 CLOSE() 함수를 호출한다. 그러면 FIN 플래그를 보내게 되고 클라이언트는 FIN_WAIT1 상태로 변한다.
2. 서버는 클라이언트가 CLOSE() 한다는 것을 알게되고 CLOSE_WAIT 상태로 바꾼 후 ACK 플래그를 전송한다.
만일 서버에서 클라이언트로 보낼 남은 데이터가 있을 경우 이때 나머지를 모두 전송시킨다.
3. ACK를 받은 클라이언트는 FIN_WAIT2로 변환되고, 이때 서버는 CLOSE() 함수를 호출하고 FIN 플래그를 클라이언트에게 보낸다.
4. 서버도 연결을 닫았다는 신호를 클라이언트가 수신하면 ACK 플래그를 보낸 후 TIME_WAIT 상태로 전환된다. 이후 모든것이 끝나면 CLOSED 상태로 변환된다.

### TCP는 왜 패킷의 도착순서를 보장하고, UDP는 보장하지 못할까요?

TCP의 패킷 교환 방식은 가상회선 패킷 교환 방식입니다. 가상회선 방식은 경로를 설정할 때 한 번만 수행하여 모든 패킷을 그 경로로만 보내지만,

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/f161c15f-c5f0-4683-9793-c7551a62792f/a2c0fb87-3e9e-4bde-a67c-7dd4c3610a37/Untitled.png)

UDP의 패킷 교환 방식은 데이터그램 패킷 교환 방식이기 때문에, 하나의 메시지에서 분할된 여러 패킷은 서로 다른 경로로 전송될 수 있습니다. 따라서 도착 순서를 보장할 수 없습니다.

### Http에 대해서 설명해 주세요

***HTTP(Hypertext Transfer Protocol)***는 인터넷상에서 데이터를 주고 받기 위한 **서버/클라이언트 모델**을 따르는 프로토콜 입니다. 응용 계층에서 작동하는 프로토콜입니다.

- (꼬리질문) Http의 특징은 어떤것이 있나요?
    - **서버/클라이언트 모델**
        - 서비스 제공자 (service provider)과 서비스 요청자 (service requester)로 구분되는 네트워크 모델
    - 비연결성 (**Connectionless**)
        - 서버에 연결하고, 요청해서 응답을 받으면 연결을 끊어버린다. 기본적으로는 자원 하나에 대해서 하나의 연결을 만든다.
        - 장점: 서버의 자원을 효율적으로 관리하고, 수 많은 클라이언트의 요청에도 대응할 수 있게 한다.수십만명이 웹 서비스를 사용하더라도 접속유지는 최소한으로 할 수 있기 때문에, 더 많은 유저의 요청을 처리할 수 있다.
        - 단점: 연결이 끊어짐에 따라 새로 연결될 때 TCP/IP 연결을 새로 맺어야 하므로 3-way handshake에 따른 시간이 추가된다.
            - **Persistent Connection**을 이용하여 비연결성의 단점을 어느정도 커버한다.
                - 한 object를 보내고 연결을 끊는 것이 아니라, 일정 시간동안 동일한 TCP 연결을 사용하며 여러 개의 http request를 처리하는 방식.
                - Http header에 `Keep-alive` 옵션을 넣어서 Persistent Connection을 맺는다.
    - 무상태성 (**stateless**)
        - 서버가 클라이언트의 이전 상태를 보존하지 않는다.
        - 장점 : 서버의 확장성이 높다 → 서버에 상태를 저장하지 않으므로 서버의 인스턴스를 늘려도 인스턴스끼리 상태를 공유할 필요가 없기 때문.
        - 단점 : 클라이언트의 이전 상태를 알 수가 없기 때문에, 클라이언트가 과거에 로그인을 성공하더라도 로그 정보를 유지할 수가 없어서 클라이언트가 데이터를 추가 전송해야 한다. HTTP는 **cookie, 세션을** 이용해서 이 문제를 해결하고 있다.

### Http Status Code

- **1XX: Informational(정보 제공)**
    - 임시 응답으로 현재 클라이언트의 요청까지는 처리되었으니 계속 진행하라는 의미입니다. HTTP 1.1 버전부터 추가되었습니다.
- **2XX: Success(성공)**
    - 클라이언트의 요청이 서버에서 성공적으로 처리되었다는 의미입니다.
- **3XX: Redirection(리다이렉션)**
    - 완전한 처리를 위해서 추가 동작이 필요한 경우입니다. 주로 서버의 주소 또는 요청한 URI의 웹 문서가 이동되었으니 그 주소로 다시 시도하라는 의미입니다.
- **4XX: Client Error(클라이언트 에러)**
    - 없는 페이지를 요청하는 등 클라이언트의 요청 메시지 내용이 잘못된 경우를 의미합니다.
- **5XX: Server Error(서버 에러)**
    - 서버 사정으로 메시지 처리에 문제가 발생한 경우입니다. 서버의 부하, DB 처리 과정 오류, 서버에서 익셉션이 발생하는 경우를 의미합니다.

| 200 | OK | 성공 | 서버가 요청을 성공적으로 처리하였다. |
| --- | --- | --- | --- |
| 201 | Created | 생성됨 | 요청이 처리되어서 새로운 리소스가 생성되었다.응답 헤더 Location에 새로운 리소스의 절대 URI를 기록합니다. |
| 202 | Accepted | 허용됨 | 요청은 접수하였지만, 처리가 완료되지 않았다.응답 헤더의 Location, Retry-After를 참고하여 클라이언트는 다시 요청을 보냅니다. |
| 301 | Moved Permanently | 영구 이동 | 지정한 리소스가 새로운 URI로 이동하였다.이동할 곳의 새로운 URI는 응답 헤더 Location에 기록합니다. |
| 303 | See Other | 다른 위치 보기 | 다른 위치로 요청하라.요청에 대한 처리 결과를 응답 헤더 Location에 표시된 URI에서 GET으로 취득할 수 있습니다. 브라우저의 폼 요청을 POST로 처리하고 그 결과 화면으로 리다이렉트시킬 때 자주 사용하는 응답 코드입니다. |
| 307 | Temporary Redirect | 임시 리다이렉션 | 임시로 리다이렉션 요청이 필요하다.요청한 URI가 없으므로 클라이언트 메소드를 그대로 유지한 채 응답 헤더 Location에 표시된 다른 URI로 요청을 재송신할 필요가 있습니다. 클라이언트는 향후 요청 시 원래 위치를 계속 사용해야 합니다. 302의 의미를 정확하게 재정의해서 HTTP/1.1의 307 응답으로 추가되었습니다. |
| 400 | Bad Request | 잘못된 요청 | 요청의 구문이 잘못되었다.클라이언트가 모르는 4xx 계열 응답 코드가 반환된 경우에도 클라이언트는 400과 동일하게 처리하도록 규정하고 있습니다. |
| 401 | Unauthorized | 권한 없음 | 지정한 리소스에 대한 액세스 권한이 없다.응답 헤더 WWW-Authenticate에 필요한 인증 방식을 지정합니다. |
| 403 | Forbidden | 금지됨 | 지정한 리소스에 대한 액세스가 금지되었다.401 인증 처리 이외의 사유로 리소스에 대한 액세스가 금지되었음을 의미합니다. 리소스의 존재 자체를 은폐하고 싶은 경우는 404 응답 코드를 사용할 수 있습니다. |
| 404 | Not Found | 찾을 수 없음 | 지정한 리소스를 찾을 수 없다. |
| 500 | Internal Server Error | 내부 서버 오류 | 서버에 에러가 발생하였다.클라이언트가 모르는 5xx 계열의 응답 코드가 반환된 경우에도 클라이언트는 500과 동일하게 처리하도록 규정하고 있습니다. |
| 501 | Not Implemented | 구현되지 않음 | 요청한 URI의 메소드에 대해 서버가 구현하고 있지 않다. |
| 502 | Bad Gateway | 불량 게이트웨이 | 게이트웨이 또는 프록시 역할을 하는 서버가 그 뒷단의 서버로부터 잘못된 응답을 받았다. |

### URI란?

**URI는 자원의 위치를 알려주기 위한 프로토콜**이다. *Uniform Resource Identifiers* 의 줄임으로, World Wide Web 상에서 접근하고자 하는 자원의 위치를 나타내기 위해서 사용한다. 자원은 "문서", "이미지", "동영상", "프로그램", "이메일"등 모든 것이 될 수 있다.

> http://www.example.co.kr/index.html
> 
> 
> 1. http : 자원에 접근하기 위해서 http 프로토콜을 사용한다.
> 
> 2. www.example.co.kr, 도메인 주소 : 자원의 인터넷 상에서의 위치이다. 도메인은 ip 주소로 변환되므로, ip 주소로 서버의 위치를 찾을 수 있다.
> 
> 3. index.html : 요청할 자원의 이름이다.
> 

### Http Method의 종류에 대해 설명해 주세요

Http 메서드는 요청의 종류를 서버에게 알려주기 위해서 사용한다.

- **GET** : 주어진 URL에서 자원을 요청
- **POST** : 주어진 URL로 자원의 생성을 요청
- **PUT** : 주어진 URL로 자원의 대체를 요청
- **DELETE** : 주어진 URL로 자원의 삭제를 요청
- **HEAD** : 주어진 URL에서 자원의 헤더만을 요청, 해당 자원이 존재하는지 혹은 서버에 문제가 없는지를 확인하기 위해서 사용한다.
- **OPTIONS** : 주어진 URL에서 처리 가능한 메소드의 목록을 요청
- (꼬리질문) HTTP 메소드의 특성에 대해 설명해 주세요. ([https://velog.io/@msung99/HTTP-메소드의-속성-안전-멱등Idempotent-캐시Cacheable](https://velog.io/@msung99/HTTP-%EB%A9%94%EC%86%8C%EB%93%9C%EC%9D%98-%EC%86%8D%EC%84%B1-%EC%95%88%EC%A0%84-%EB%A9%B1%EB%93%B1Idempotent-%EC%BA%90%EC%8B%9CCacheable))
    - 안전
    - 멱등
    - 캐시가능

### 멱등성에 대해 설명해 주세요.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/f161c15f-c5f0-4683-9793-c7551a62792f/5de7ef63-8ce9-4b6c-8122-87e17b13834d/Untitled.png)

같은 연산을 여러번 실행한다고 해도 그 결과가 달라지지 않는 성질.

**동일한 요청을 한번 보내는 것과, 여러번 보내는 것이 서로 동일한 효과를 지니고, 서버의 상태도 동일하게 남을 때 해당 HTTP Method 가 멱등성을 갖는다고 이야기한다. (단, 서버의 상태를 변경시킬 수는 있다. 요청에 대한 서버의 상태가 항상 같아야 한다.)**

- (꼬리질문) 멱등성을 갖는 Http 메소드는 무엇이 있나요? 왜 멱등성을 보장한다고 생각하시나요?
- 멱등성 O
    - **`GET`** : 서버에 존재하는 리소스를 단순히 읽어오기만 하는 메소드이기 때문에 당연히 여러번 수행되어도 결과값은 변하지 않는다. 마찬가지로 **`HEAD`**, **`OPTIONS`** 메소드도 조회에 대한 메소드이기 때문에 멱등하다고 할 수 있다.
    - **`PUT`** : 서버에 존재하는 리소스를 요청에 담긴 내용대로 통째로 대체해버리므로 올바르게 구현하였다면 여러번 수행되어도 결과 값은 변하지 않을 것 이다.
    - **`DELETE`** : 존재하는 데이터를 삭제한 결과와 이미 존재하지 않은 결과를 삭제하려는 시도에 대한 응답 코드는 서로 다르겠지만, (200 OK 또는 404 NOT FOUND) N번 호출해도 항상 리소스가 없는 동일한 상태이다.
- 멱등성 X
    - `**POST**` : **`POST`** 메소드가 호출될 때 마다 데이터베이스 등에 요청된 데이터가 추가될 것 이고, 이는 곧 멱등성의 ***요청에 대한 서버의 상태가 동일하게 남아야 한다***.를 위배함. (서버의 상태가 동일하지 않다.)
    - `**PATCH` :**
    - 예를 들어 name에 해당하는 값을 변경하고자 할 때 PATCH를 사용할 수 있다. 예를 들어 우리는 아래와 같이 요청을 N번 날려도 항상 동일한 결과를 응답받게 된다. 
    PATCH → {name: ”MangKyu”}
    PATCH → {name: ”MangKyu”}
    - 그래서 PATCH를 멱등하다고 착각할 수 있는데, 문제는 PATCH가 보다 범용적으로 사용된다는 것이다. 예를 들어 “name” 필드를 보내면 값을 추가(append)하는 요청 역시 PATCH가 사용된다. 그러면 PATCH 요청에 의한 결과는 매번 달라지게 될 것이다. 그러므로 PATCH 메소드는 항상 멱등하다고 볼 수 없다.
    PATCH → name: [”MangKyu”]
    PATCH → name: [”MangKyu”, ”MangKyu”]
    PATCH → name: [”MangKyu”, ”MangKyu”, ”MangKyu”]
- (꼬리질문) 안전한 메소드와 멱등성을 갖는 메소드의 차이는 무엇인가요?
    - 안전한 메소드는 서버의 상태를 변경시키지 않습니다. 하지만 멱등성을 갖는 메소드는 서버의 상태를 변경시킬 수도 있습니다. 따라서 안전한 메소드는 항상 멱등성을 갖지만, 역으로 멱등성을 갖는 메소드는 항상 안전한 메소드임이 보장되지 않습니다.
- (꼬리질문) 멱등성이 필요한 이유는 무엇일까요?
    - HTTP 멱등성이 필요한 이유는 요청의 재시도 때문이다. 만약 HTTP 요청이 멱등하다면, 요청이 실패한 경우에 주저없이 재시도 요청을 하면 된다. 하지만 만약 HTTP 요청이 멱등하지 않다면, 리소스가 이미 처리되었는데 중복 요청을 보낼 수 있다. 예를 들어 이미 결제된 요청인데, 중간에 연결이 끊겨서 다시 결제 요청을 보내서 문제를 일으킬 수 있는 것이다. 그래서 클라이언트는 무지성으로 재시도 요청을 보내면 안되고, 멱등성을 고려하여 재시도 요청을 해야 한다.

참고 : 안전한 메소드는 서버측의 상태 정보를 변경하지 않는 메소드를 가리킨다. 안전한 메소드와 멱등성을 갖는 메소드는 서로 다름을 유의한다. **`GET`**, **`OPTIONS`**, **`HEAD`** 와 같이 조회에 사용되는 메소드를 안전하다고 이야기할 수 있다.

### Http와 Https의 차이를 설명해 주세요.

- HTTPS URL은 "https://" 로 시작한다. 기본 포트번호는 443이다. HTTP URL은 "http://" 로 시작한다. 기본 포트번호는 80이다.
- HTTP는 평문 데이터를 기반으로 하기 때문에, 유저정보와 같은 민감한 정보가 인터넷 상에 그대로 노출된다. 이 정보는 수집되거나 변조될 수 있다. HTTPS는 이러한 공격을 견딜 수 있도록 설계돼 있다.
- HTTPS는 인증서를 이용해서, 접속 사이트를 신뢰할 수 있는지 평가할 수 있다.
- 일반적으로 HTTPS는 HTTP에 비해서 (매우 많이)느리다. 많은 양의 데이터를 처리할 경우 성능의 차이를 체감할 수 있다. 많은 웹 사이트들이 민감한 정보를 다루는 페이지 (로그인 혹은 유저정보) 페이지를 HTTPS로 전송하고, 기타 페이지는 HTTP로 전송하는 방법을 사용한다.

### PUT vs PATCH vs POST의 차이를 설명해 주세요.

- PUT
    - 요청한 URI의 payload(ex. Request Body)에 있는 자원으로 **대체**하는 메서드. 여기서 대체하는 메서드라는 것은 대상을 저장하기도, 변경한다는 것을 의미한다.
    
    ### **요청한 URI 아래에 자원이 존재하지 않는 경우**
    
    자원이 존재하지 않는 경우는 단순하다. POST와 마찬가지로 새로운 자원으로써 저장하고 클라이언트에게 Http Status Code를 `201(Created)` 응답을 보내주면 된다.
    
    ### **요청한 URI 아래에 자원이 존재하는 경우자원이 존재하는 경우**
    
    payload에 담긴 정보를 이용해서 새로운 자원을 만들어 기존에 존재하던 자원을 대체한다.그리고 해당 요청이 잘 적용되었다는 것을 클라이언트에게 `200(ok)` 혹은 `204(no content)`를 이용해서 알려주면 된다
    
- PATCH
    - **부분적인 수정을 적용**하기 위한 HTTP 메서드.
- PUT vs PATCH
    - PUT은 전송하는 payload만으로 자원의 전체 상태를 나타낼 수 있어야 하지만,
    - PATCH는 자원의 일부분만 payload로 실어서 요청한다.
- POST
    - 무조건 자원을 생성하는 HTTP 메서드.
- POST vs PUT
    - POST는 멱등하지 않은 반면, PUT은 멱등하다.
    - PUT은 요청 URI에 entity의 ID가 필요하다. (해당 엔티티가 존재한다면 ID를 기반으로 찾아서 수정을 할 것이기 때문.)

### HTTP 버전별 특징/장단점을 설명해 주세요.

- HTTP 1.0
    - 브라우저 친화적인 프로토콜
    - 요청 및 응답에 대한 메타 데이터를 포함하는 헤더 필드 제공(Status code, Content-Type 등)
    - Response: Content-Type에 Http 파일 외에도 스크립트, 스타일 시트, 미디어 등을 전송 가능
    - Method: GET, HEAD, POST
    - Connection 특징: 응답 직후 종료
    - 단점 : Connectionless → 각 모든 요청에 따라 새로운 연결을 열고, 응답이 전송된 후 즉시 닫기 때문에 새로운 연결이 설정 될 때마다 TCP 3-way Handshake가 발생함.
    → Network Latency를 발생 (2 * RTT * 요청의 수)
- HTTP 1.1
    - ***Persistent Connection***
        - 지정한 timeout 동안 커넥션을 닫지 않는 방식
        - Persistent 기능을 이용하여 한 개의 TCP 세션을 통해 여러 개의 컨텐츠 요청이 가능
        - 요청 컨텐츠마다 TCP 세션을 맺어야하는 HTTP 1.0에 반해 HTTP 1.1은 TCP 세션 처리 부하를 줄일 수 있고, 그만큼 클라이언트 응답속도가 개선된다.
    - ***Pipelining***
        - 하나의 커넥션에서 응답을 기다리지 않고 순차적인 여러 요청을 연속적으로 보내 그 순서에 맞춰 응답을 받는 방식으로 지연 시간을 줄이는 방식 (TCP 안에 두 개 이상의 HTTP 요청을 담음)
        - 파이프라이닝 또한 순차적으로 패킷을 보내고 받는 방식이므로, HOL Blocking이 생길 수 밖에 없음.
        - 이론적으로는, 두 개의 HTTP 요청을 하나의 TCP 메시지 안에 채워서(be packed) 성능을 더 향상
    - HTTP Response Time : 1 + 1 * RTT * 요청의 수 (HTTP 1.0에 비해 response time이 많이 줄어들었다.)
    - 장점 : Persistent Connection으로 응답시간이 줄어들었다.
    - 단점 : HOL Blocking, Header의 비대함
        
        HTTP 1.1에서는 헤더를 중복해서 보낼 뿐만 아니라 cookie 정보 역시 매 요청마다 헤더에 포함되어 전송된다. 즉, 불필요한 데이터를 주고 받는데 네트워크 자원이 소비되는 문제가 발생한다
        
- HTTP 2.0
    1. ***HTTP 메시지 전송 방식의 변화***
        - 기존의 메시지 전송 방식인 평문(Plain Text)에서 바이너리 프레이밍(binary framing) 으로 인코딩된 메시지, 프레임 사용 → 파싱, 전송 속도 ⬆️, 오류 발생 가능성 ⬇️
    2. ***Request and response multiplexing (I/O Multiplexing)***
        - HTTP 1.1의 HTTP Pipelining의 개선안으로 하나의 Connection을 통해 동시에 여러 개의 메세지를 주고 받을 수 있음
        - 또한, 응답은 요청 순서에 상관없이 Stream으로 받기 때문에 HOL Blocking 문제도 해결
        - 즉 여러 개의 스트림을 병렬적으로 사용하여 송수신한다는 것. 이를 통해 특정 스트림의 패킷이 손실되었다고 하더라도 해당 스트림에만 영향을 미치고 나머지 스트림은 멀쩡하게 동작할 수 있음
        - 하지만 HTTP는 7계층 위에서 동작하지만, 동시에 TCP/IP위에서도 동작하기 때문에 기존 TCP에서 HOL Blocking을 극복해야 진정으로 HOL Blocking이 없다고 할 수 있다.
            - 기존 TCP는 패킷이 유실되거나, 오류가 있을 때 재전송한다. 재전송 과정에서 패킷의 지연이 발생하게 된다. → HOL Blocking을 극복하지는 못했다.
    3. ***Stream Prioritization***
        - 리소스간 우선 순위를 설정 가능
        - 응답에 대한 우선순위를 정해 우선순위가 높을수록 응답을 빨리 함
    4. ***Server Push***
        
        ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/f161c15f-c5f0-4683-9793-c7551a62792f/84a90343-1f0e-4468-a159-08d326dfe3f3/Untitled.png)
        
        - 클라이언트가 요청하기 전에 HTTP/2 호환 서버가 리소스를 HTTP/2 호환 클라이언트에 보낼 수 있음
        - 서버 푸시는 클라이언트가 리소스가 필요할지 알기도 전에 미리 리소스를 로드하여 대기 시간을 줄이는 것을 목표로 하는 성능 기술
        - 즉, 서버가 클라이언트의 요청없이 응답을 보내는 방법으로 클라이언트의 요청을 최소화하여 **서버가 리소스를 보내주는 방식**
    5. ***Header Compression***
        - HTTP 1.1의 경우 이전 요청과 중복되는 Header도 똑같이 전송하느라 네트워크 자원을 불필요하게 낭비하였음
        - HTTP 2.0의 경우, **헤더의 크기를 줄여 페이지 로드 시간 감소**
        - Header Table과 [Huffman Encoding](https://en.wikipedia.org/wiki/Huffman_coding)을 사용하는 HPACK 압축방식으로 이를 개선하였음
        - 클라이언트와 서버는 각각 Header Table을 관리하고 이전 요청과 동일한 필드는 table의 index만 보내고, 변경되는 값은 Huffman Encoding 후 보냄으로서 Header의 크기를 경량화
- HTTP 3.0
    - 2020년 등장하였으며, TCP 위에서 돌아가는 이전 버전과 달리 HTTP3는 QUIC이라는 계층 위에서 돌아가며, TCP 기반이 아닌 UDP 기반으로 돌아간다.
    - http/3.0에서는 무조건 https를 사용한다.
    - HTTP/2.0 에서 장점이었던 멀티플렉싱을 가지고 있으며, "초기 연결 설정 시 지연 시간 감소"라는 대표적 특성이 있음
- QUIC (Quick UDP Internet Connections)
    - 전송 계층 프로토콜 (2013년에 구글에서 공개)
    - 순방향 오류 수정 메커니즘(FEC, Forward Error Correction) 적용
        - 전송한 패킷이 손실되었다면 수신 측에서 에러를 검출하고 수정하는 방식이며 열악한 네트워크 환경에서도 낮은 패킷 손실률을 자랑
    - TCP가 아닌 UDP를 선택한 이유?
        - TCP 헤더는 신뢰성을 확보하지만 지연을 줄이기 힘든 구조
        - UDP는 데이터 전송에 집중한 설계로 별도의 기능이 없음
        - 따라서, 원하는 기능의 구현이 가능하며, TCP의 Latency를 줄이면서 TCP만큼 신뢰성 확보 가능
        - Youtube의 라이브 스트리밍, 동영상 서비스
    - 헤더 압축 또한 HPACK이 아닌 QPACK을 사용
    
    ## QUIC의 장점
    
    - 전송 속도 향상
        - 첫 연결 설정에서 필요한 정보와 함께 데이터를 전송
        - > 연결 성공 시 설정을 캐싱하여 다음 연결 때 바로 성립 가능
    - Connection UUID라는 고유한 식별자로 서버와 연결
        - 커넥션 수립 필요가 없음
    - TLS (전송 계층 보안, Transport Layer Security) 기본 적용
    - IP Spoofing / Replay Attack을 방지하여 보안성을 향상
        
        > Spoofing?- 스푸핑의 사전적 의미는 '속이다'이다. 네트워크에서 스푸핑 대상은 MAC 주소, IP주소, 포트 등 네트워크 통신과 관련된 모든 것이 될 수 있고, 스푸핑은 속임을 이용한 공격을 총칭한다.- 근거리 통신망(LAN) 하에서 주소 결정 프로토콜(ARP) 메시지를 이용하여 상대방의 데이터 패킷을 중간에서 가로채는 중간자 공격 기법이다.
        > 
    - 독립 스트림을 이용하여 향상된 멀티플렉스 기능을 제공
    
    !https://velog.velcdn.com/images/minu/post/b77c8371-7cf9-4220-b75a-70da35a47442/image.png
    

### HTTP 헤더란?

HTTP 헤더는 클라이언트와 서버가 요청 또는 응답으로 부가적인 정보를 전송할 수 있도록 해줍니다.

### HTTPS 사용이유

사용이유

- 기존의 HTTP 방식은 전송중인 데이터를 가로채면 누구나 데이터를 읽을 수 있었다.
- 따라서 전송중인 데이터를 다른 누군가 훔쳐보지 못하도록 하기 위함

SSL(Secure Socket Layer)/TLS(Transport Layer Security)를 웹 서버에 설치하여 SSL핸드셰이크 이후 HTTPS 통신한다.

### HTTPS는 언제 사용하는게 좋을까요?

매번 HTTPS를 사용하는 것은 암호화/복호화 과정이 들어가기 때문에 속도가 느려질 수 있습니다.

따라서, 개인정보 혹은 유출되면 안되는 자원을 다룰 때는 https통신으로 하고, 노출되어도 문제 없는 자원들을 다룰 때는 http통신을 하는 것이 좋을것 같습니다.

### HTTPS를 사용한다고 무조건 안전한가요?

HTTPS는 웹에서 보안을 적용하기 위한 가장 기본적인 단계이고, 이것으로 모든 보안성이 완벽하게 지켜졌다고 할 수 없습니다. 예를 들면, 웹 서버가 해커의 다양한 공격에 의해 루트 권한을 탈취당했다면 모든 기밀 데이터를 열람할 수 있는 권한이 넘어갈 수도 있습니다. 또한 HTTPS는 전달 구간에 대한 보안 기술인데, 전달 구간 중간에 해커가 중간자 공격(Man in the middle attack)을 수행할 수 있는 취약점이 있다면 HTTPS는 유지되지만 전달하는 내용은 고스란히 노출되기 때문입니다.

### 대칭키 비대칭키에 대해서 설명해주세요.

## 대칭키

암호화/복호화 할 때 서로 키가 같은경우를 말합니다

- 장점: 빠른연산
- 단점: 하나의 키로 암호화/복호화를 하므로 키 노출시 암호화 무의미

## 비대칭키(공개키)

**공개키, 개인키 이렇게 두 개의 키를 한 쌍(key pair)으로 각각 암호화/복호화에 사용**한다. 일반적으로 공개키로 암호화한 것을 개인키로 복호화한다. 개인키를 먼저 만들고, 여기서 공개키를 파생하여 한 쌍의 키를 만들기 때문에 key pair라 부르는 것이다. 만약 같은 쌍이 아닌 다른 키를 사용하려 한다면 암호화/복호화가 불가능하다.

- 장점: 공개키가 노출되더라도 개인키로만 복호화가 가능하므로 안전
- 단점: 연산시간이 길어 서버의 성능에 영향을 줌

### DNS란?

도메인 이름을 IP주소로 변환해주는 시스템. 사용자가 일일이 IP주소를 알고있지 않아도 된다.

DNS는 상위 기관과 하위 기관과 같은 **‘계층 구조’**를 가지는 **분산 데이터베이스 구조**를 가진다.

- 분산 데이터베이스 구조로 갖는 이유
    - 여러 DNS 서버를 두어서 도메인 네임 → IP주소 변환작업의 로드량을 줄이기 위함.

### DNS의 구성요소에 대해서 설명해 주세요.

- **도메인 네임 스페이스**(Domain Name Space)
    - 도메인 주소를 관리하기 위한 전체 트리 구조. 각각의 노드에는 여러 네임 서버들이 모여서 도메인 주소의 일부분을 관리하게 된다.
- **네임 서버**(Name Server)
    - 도메인 주소를 관리하기 위해 사용하는 DNS 전용 서버
- **리졸버**(Resolver) : 권한 없는 DNS 서버
    - DNS 클라이언트 요청을 네임 서버로 전달하고 찾은 정보를 클라이언트에게 제공하는 기능을 수행한다.
- 네임 서버의 종류
    - **1. Root DNS Server**
        - DNS 서버의 최상위 네임서버로 DNS 해석부터 발생한 DNS 요청에 대하여 적절한 TLD 네임서버 정보를 반환한다.
    - **2. Top-Level Domain(TLD) DNS Server**
        - 도메인 등록 기관이 관리하는 서버로 Authoritative DNS 서버의 주소를 저장하고 안내하는 역할을 한다.
        - • .kr, .jp, .net, .com, org 등
    - **3. Second-Level Domain(SLD) DNS Server (Authoritative DNS Server)**
        - 실제 개인 도메인과 IP 주소의 관계가 기록(저장, 변경)되는 서버다.
        - • .co (일반회사), .ac (교육기관), .go (정부기관) 등
    - **4. Anauthoritative DNS Server**
        - 권한이 없는 DNS 서버로 리졸버 서버, 리컬시브 서버, 리커서가 있다.

### 웹브라우저에 도메인 네임을 입력한 이후에 실제 DNS Resolver의 동작 순서에 대해서 설명해 주세요.

1. DNS Resolver는 우선 자신의 캐시에 해당 도메인 이름에 대한 IP 주소가 저장되어 있는지 확인한다.
    - 캐시에 저장된 IP 주소가 있다면, DNS Resolver는 바로 해당 IP 주소를 반환한다.
    - 캐시에 저장된 IP 주소가 없거나, 캐시에 저장된 IP 주소가 만료되었다면, DNS Resolver는 DNS 서버에 요청한다.
2. Root DNS Server에 쿼리를 날린다.
    
    Root DNS Server는 TLD DNS Server에 대한 정보를 가지고 있으며, 해당 TLD DNS Server의 IP 주소를 DNS Resolver에게 전달한다.
    
3. TLD Server에 쿼리를 날린다.
    
    TLD DNS Server는 해당 도메인 이름이 저장된 SLD DNS Server의 IP 주소를 DNS Resolver에게 반환한다.
    
4. 마지막으로, DNS Resolver는 SLD DNS Server에 요청한다.
SLD DNS Server는 해당 도메인 이름에 대한 IP 주소를 가지고 있으며, 이를 DNS Resolver에게 반환한다.
DNS Resolver는 이제 해당 IP 주소를 캐시에 저장하고, 이후 동일한 도메인 이름에 대한 질의가 들어올 때 캐시에 저장된 IP 주소를 사용한다.

### ref

- https://dev-coco.tistory.com/144
- 흐름제어 혼잡제어 : [https://gyoogle.dev/blog/computer-science/network/흐름제어 & 혼잡제어.html](https://gyoogle.dev/blog/computer-science/network/%ED%9D%90%EB%A6%84%EC%A0%9C%EC%96%B4%20&%20%ED%98%BC%EC%9E%A1%EC%A0%9C%EC%96%B4.html)
- GO BACK N & Selective Repeat : [https://velog.io/@taegon1998/컴퓨터망-12](https://velog.io/@taegon1998/%EC%BB%B4%ED%93%A8%ED%84%B0%EB%A7%9D-12)
- TCP 혼잡제어 : [https://velog.io/@nnnyeong/Network-TCP-혼잡제어-Congestion-Control](https://velog.io/@nnnyeong/Network-TCP-%ED%98%BC%EC%9E%A1%EC%A0%9C%EC%96%B4-Congestion-Control)
- [https://inpa.tistory.com/entry/NW-🌐-아직도-모호한-TCP-UDP-개념-❓-쉽게-이해하자](https://inpa.tistory.com/entry/NW-%F0%9F%8C%90-%EC%95%84%EC%A7%81%EB%8F%84-%EB%AA%A8%ED%98%B8%ED%95%9C-TCP-UDP-%EA%B0%9C%EB%85%90-%E2%9D%93-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EC%9E%90)
- 가상 회선 패킷교환방식, 데이터그램 패킷 교환 방식 : https://woovictory.github.io/2018/12/28/Network-Packet-Switching-Method/
- HTTP : [https://velog.io/@dnjscksdn98/HTTP-프로토콜에-대하여](https://velog.io/@dnjscksdn98/HTTP-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC)
- HTTP 멱등성 : https://mangkyu.tistory.com/251, https://hudi.blog/http-method-idempotent/
- PUT vs PATCH : https://tecoble.techcourse.co.kr/post/2020-08-17-put-vs-patch/
- HTTP 1.0 1.1 2.0 3.0 QUIC : https://velog.io/@minu/HTTP1.0-HTTP1.1-HTTP2-and-QUIC
- HTTPS : [https://velog.io/@alscjf6315/HTTPS-의-동작원리](https://velog.io/@alscjf6315/HTTPS-%EC%9D%98-%EB%8F%99%EC%9E%91%EC%9B%90%EB%A6%AC)
- DNS : [https://velog.io/@zinukk/9kpyzbdt#️dnsdomain-name-system란](https://velog.io/@zinukk/9kpyzbdt#%EF%B8%8Fdnsdomain-name-system%EB%9E%80)