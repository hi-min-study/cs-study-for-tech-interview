# 2주차 스터디

- 통신
    - TCP
        - 흐름제어, 혼잡제어, 오류제어
        - 3-way-handshake, 4-way-handshake
    - UDP
    - HTTP
        - HTTP status code
        - HTTP method
            - 종류
            - 멱등성
            - PUT, PATCH, POST method 차이
        - HTTP 1.1, 2.0, 3.0
        - HTTP 헤더
    - HTTPS, SSL/TLS
        - 동작 원리
        - 공개키 대칭키 방식
    - DNS

# TCP(Transmission Control Protocol)란?

`TCP`는 서버와 클라이언트 간에 데이터를 **신뢰성 있게 전달**하기 위해 만들어진 프로토콜이다.

데이터를 전송하기 전에 데이터 전송을 위한 연결을 만드는 **연결지향 프로토콜**이다.

**데이터는 네트워크 선로를 통해 전달되는 과정에서 손실되거나 순서가 바뀌어서 전달**될 수 있는데, TCP는 손실을 검색해서 이를 교정하고 **순서를 재조합할 수 있도록 도와준다.**

> TCP/IP란?
> 
> 
> `TCP/IP`는 전송계층의 TCP와 네트워크 계층의 IP프로토콜을 합친 프로토콜 스위트(모음)으로, TCP는 데이터의 정확성 확인, IP는 패킷을 목적지까지 전송하는 역할을 한다.
> 
> 인터넷 접속을 위한 기본 프로토콜이다.

## **TCP의 특징**

- 신뢰성 있는 데이터 통신을 가능하게 한다. (Sequence Number, Ack Number)
- 데이터의 경계를 구분하지 않는다. (바이트 스트림 서비스)
- 데이터의 전송 순서를 보장한다. (순서 유지를 위해 각 바이트마다 번호를 부여)
- 데이터 흐름 제어(수신자 버퍼 오버플로우 방지) 및 혼잡 제어(패킷 수가 과도하게 증가하는 현상 방지)
- 연결의 설정 (3-way handshake)해제 (4-way handshake)
- 전이중(Full-Duplex), 점대점(Point to Point) 서비스
- `UDP`에 비해 전송 속도가 느리다.

TCP는 크게 3가지 제어 기능이 있다.

- 전송되는 데이터의 양을 조절하는 **흐름 제어**
- 데이터가 유실되거나 잘못된 데이터가 수신되었을 경우 대처하는 방법인 **오류 제어**
- 네트워크 혼잡에 대처하는 **혼잡 제어**

이 기능들 덕분에 예외 상황에 크게 신경쓰지 않고 상위 레이어 동작에 집중할 수 있다.

## **흐름 제어**

송신 측과 수신 측의 데이터 처리 속도가 다를 수 있다.

송신 측이 빠를 때 수신 측 버퍼가 넘치는 **오버플로우** 문제가 발생한다.

이러한 문제를 줄이기 위해 윈도우 크기로 **송신 측의 데이터 전송량을 조절**한다.

- **윈도우 크기** : 자신이 처리할 수 있는 데이터의 양

### **stop and wait**

상대방에게 데이터를 보낸 후 잘 받았다는 응답이 올 때까지 기다리는 방식

### **sliding winodw**

**송신 측이 수신 측에서 받은 윈도우 크기를 참고해서 데이터의 흐름을 제어하는 방식**

- 수신 측이 한 번에 처리할 수 있는 데이터의 양(**윈도우 크기)을 3 way handshake할 때 송신 측에 전달**한다.
- 상대방에게 **응답을 받지 않아도 범위 내에서 데이터를 보낼 수 있다.**
- 패킷의 왕복 시간(RTT)이 크다면 **네트워크가 혼잡하다고 생각하여 윈도우 크기를 실제 버퍼의 크기보다 작게 설정**한다.
- 통신 과정 중에도 네트워크 혼잡 등의 조건을 통해 **윈도우 크기는 유동적으로 설정**된다.

## **오류 제어**

TCP는 통신 중에 오류가 발생하면 해당 데이터를 재전송한다.

즉, **재전송 기반 오류 제어 ARQ(Automatic Repeat Request)**를 사용한다.

재전송은 비효율적이므로 적을수록 좋다.

### **오류를 알 수 있는 방법**

- 송신 측이 ACK(긍정응답)을 받지 못함
    - 송신 측이 보낸 데이터가 유실되거나, 수신 측이 보낸 ACK 데이터가 유실될 경우
- 중복된 ACK를 받는다.
- 수신 측이 NACK(부정응답)을 보냄
    - ACK만으로 오류를 추정하기 위해 사용하지 않기도 한다.

### **Stop and Wait**

**ACK를 받고 나서 다음 데이터를 보내는 방식**이다.

일정 시간을 지나 timeout이 발생하면 이전 데이터를 재전송한다.

흐름 제어에서의 슬라이딩 윈도우를 사용할 수 없으므로 더 효율적인 ARQ가 필요하다.

### **Go Back N**

연속으로 데이터를 보내다가 **오류가 발생한 지점부터 재전송하는 방식**이다.

아래처럼 4번 데이터에서 에러가 발생했다면 4번 이후의 데이터는 모두 삭제한다.

**성공적으로 전송된 데이터까지 재전송하기 때문에 조금 비효율적**이다.

### **Selective Repeat**

**오류가 발생한 데이터만 재전송하는 방식**이다.

Selective Repeat의 단점은 수신 측 **버퍼의 데이터가 순차적이지 않다**는 것이다.

정렬의 과정이 추가로 필요하고 별도의 버퍼가 필요하다.

Go Back N과 비교하여 상황에 따라 더 유리한 방법을 선택하면 된다.

## **혼잡 제어**

네트워크 내에 패킷의 수가 과도하게 증가하는 현상을 **혼잡**이라고 한다.

혼잡 제어는 **혼잡 현상을 방지하고 제거하기 위한 기능**이다.

흐름 제어는 송신 측과 수신 측의 전송 속도를 다루고, 혼잡 제어는 라우터를 포함한 넓은 범위의 전송 문제를 다룬다.

### **AIMD (Additive Increase / Multiplicative Decrease)**

- 처음에 패킷을 하나씩 보내고 문제가 발생하지 않으면 윈도우 크기를 1씩 증가하는 방법
- 패킷 전송에 실패하거나 일정 시간을 넘으면 패킷 전송 속도를 절반으로 줄인다.
- 네트워크에 늦게 들어온 호스트가 처음에는 불리하지만, 시간이 흐르면서 평형상태로 수렴한다.
- 단점
    - 처음에 전송 속도를 올리는 데 시간이 오래걸린다.
    - 네트워크가 혼잡해지는 상황을 미리 감지하지 못한다. 즉, 네트워크가 혼잡해지고 나서야 대역폭을 줄인다.

### **Slow Start (느린 시작)**

- AIMD와 같이 패킷을 하나씩 보내고 문제가 발생하지 않으면 각 ACK 패킷마다 윈도우 크기를 1씩 늘려준다. 즉, 한 주기가 지나면 윈도우 크기는 2배가 된다.
- AIMD와 달리 전송 속도를 지수 함수 꼴로 증가시켜서 윈도우 크기를 더 빠르게 증가시킨다.
- 혼잡이 감지되면 윈도우 크기를 1로 줄인다.
- 처음에는 네트워크 수용량을 예상할 수 있는 정보가 없지만, 한 번 혼잡 현상이 발생한 후에는 네트워크의 수용량을 어느 정도 예상할 수 있다.
- 그래서 혼잡 현상이 발생하는 윈도우 크기의 절반가지는 지수 함수 꼴로 윈도우 크기를 증가시키고 그 이후에는 완만하게 1씩 증가시킨다.

### **Fast Retransmit (빠른 재전송)**

- TCP는 지금가지 받은 데이터 중 연속되는 패킷의 마지막 순번 이후를 ACK 패킷에 실어서 보낸다.
- 그래서 송신 측이 아래처럼 3, 4번을 보내더라도 ACK 2 를 중복해서 받는다.
- 그러면 timeout이 발생하기 전이라도 송신 측은 문제가 되는 2번 패킷을 재전송한다.
- 그리고 혼잡한 상황이라고 판단해서 윈도우 크기를 줄인다.
- 3 ACK Duplicated : 송신 측이 3번 이상 중복된 ACK 번호를 받은 상황

### **Fast Recovery (빠른 회복)**

- 혼잡한 상태가 되면 윈도우 크기를 1이 아니라 반으로 줄이고, 선형 증가시킨다.
- 혼잡 상황을 한번 겪은 이후로는 AIMD 방식으로 동작한다.

## 3-way handshake & 4-way handshake

### **1. TCP 3-way Handshake 란?**

TCP는 장치들 사이에 논리적인 접속을 성립(establish)하기 위하여 three-way handshake를 사용한다.

**TCP 3 Way Handshake는 TCP/IP프로토콜을 이용해서 통신을 하는 응용프로그램이 데이터를 전송하기 전에**

**먼저 정확한 전송을 보장하기 위해 상대방 컴퓨터와 사전에 세션을 수립하는 과정을 의미한다..**

Client > Server : **TCP SYN**

Server > Client : **TCP SYN, ACK**

Client > Server : **TCP ACK**

여기서 SYN은 'synchronize sequence numbers', 그리고 ACK는'acknowledgment' 의 약자이다.

이러한 절차는 TCP 접속을 성공적으로 성립하기 위하여 반드시 필요하다.

- **TCP의 3-way Handshaking 역할**
- 양쪽 모두 데이타를 전송할 준비가 되었다는 것을 보장하고, 실제로 데이타 전달이 시작하기전에

한쪽이 다른 쪽이 준비되었다는 것을 알수 있도록 한다.

- 양쪽 모두 상대편에 대한 초기 순차일련변호를 얻을 수 있도록 한다.

- **TCP의 3-way Handshaking 과정**

**[STEP 1]**

A클라이언트는 B서버에 접속을 요청하는 SYN 패킷을 보낸다.

이때 A클라이언트는 SYN 을 보내고 SYN/ACK 응답을 기다리는 **SYN_SENT** 상태, **B서버는 Wait for Client** 상태이다.

**[STEP 2]**

B서버는 SYN요청을 받고 A클라이언트에게 요청을 수락한다는 ACK 와 SYN flag 가 설정된 패킷을 발송하고

A가 다시 ACK으로 응답하기를 기다린다. 이때 **B서버**는 **SYN_RECEIVED** 상태가 된다.

**[STEP 3]**

A클라이언트는 B서버에게 ACK을 보내고 이후로부터는 연결이 이루어지고 데이터가 오가게 되는것이다.

이때의 **B서버 상태가 ESTABLISHED** 이다.

위와 같은 방식으로 통신하는것이 신뢰성 있는 연결을 맺어 준다는 TCP의 3 Way handshake 방식이다.

### **2. 4-way Handshaking**

3-Way handshake는 TCP의 연결을 초기화 할 때 사용한다면,

4-Way handshake는 세션을 종료하기 위해 수행되는 절차.

- **TCP의 4-way Handshaking 과정**

**[STEP 1]**

클라이언트가 연결을 종료하겠다는 FIN플래그를 전송한다. 이때 **A클라이언트는  FIN-WAIT** 상태가 된다.

**[STEP 2]**

B서버는 FIN플래그를 받고, 일단 확인메시지 ACK 보내고 자신의 통신이 끝날때까지 기다리는데 이 상태가

**B서버의 CLOSE_WAIT**상태다.

**[STEP 3]**

연결을 종료할 준비가 되면, 연결해지를 위한 준비가 되었음을 알리기 위해  클라이언트에게 FIN플래그를 전송한다. 이때 B서버의 상태는 **LAST-ACK**이다.

**[STEP 4]**

클라이언트는 해지준비가 되었다는 ACK를 확인했다는 메시지를 보낸다.

**A클라이언트의 상태가 FIN-WAIT ->TIME-WAIT** 으로 변경된다.

그런데 만약 "Server에서 FIN을 전송하기 전에 전송한 패킷이 Routing 지연이나 패킷 유실로 인한 재전송 등으로 인해 FIN패킷보다 늦게 도착하는 상황"이 발생한다면 어떻게 될까?

Client에서 세션을 종료시킨 후 뒤늦게 도착하는 패킷이 있다면 이 패킷은 Drop되고 데이터는 유실될 것.

**A클라이언트**는 이러한 현상에 대비하여 Client는 Server로부터 FIN을 수신하더라도 일정시간(디폴트 240초) 동안 세션을 남겨놓고 잉여 패킷을 기다리는 과정을 거치게 되는데 이 과정을 **"TIME_WAIT"** 라고 한다. 일정시간이 지나면, 세션을 만료하고 연결을 종료시키며, **"CLOSE"** 상태로 변화.

**UDP 통신이란?**

- User Datagram Protocol의 약자로 데이터를 데이터그램 단위로 처리하는 프로토콜이다.
- 비연결형, 신뢰성 없는 전송 프로토콜이다.
- 데이터그램 단위로 쪼개면서 전송을 해야하기 때문에 전송 계층이다.
- Transport layer에서 사용하는 프로토콜.
- **TCP와 UDP가 어떻게 오류를 해결하는가?**
    - **TCP**
        
        데이터의 분실, 중복, 순서가 뒤바뀜 등을 자동으로 보정해줘서 송수신 데이터의 정확한 전달을 할 수 있도록 해준다.
        
    - **UDP**
        
        IP가 제공하는 정도의 수준만을 제공하는 간단한 IP 상위 계층의 프로토콜이다. TCP와는 다르게 에러가 날 수도 있고, 재전송이나 순서가 뒤바뀔 수도 있어서 이 경우, 어플리케이션에서 처리하는 번거로움이 존재한다.
        
- **UDP는 왜 사용할까?**
    - UDP의 결정적인 장점은 데이터의 신속성이다. 데이터의 처리가 TCP보다 빠르다.
    - 주로 실시간 방송과 온라인 게임에서 사용된다. 네트워크 환경이 안 좋을때, 끊기는 현상을 생각하면 된다.
- **DNS(Domain Name Service)에서 UDP를 사용하는 이유**
    - Request의 양이 작음 -> UDP Request에 담길 수 있다.
    - 3 way handshaking으로 연결을 유지할 필요가 없다. (오버헤드 발생)
    - Request에 대한 손실은 Application Layer에서 제어가 가능하다.
    - DNS : port 53번
    - But, TCP를 사용할 때가 있다! 크기가 512(UDP 제한)이 넘을 때, TCP를 사용해야한다.

TCP 보다 용량이 가볍고 송신 속도가 빠르게 작동됨.

그러나 확인 응답을 못하므로, TCP보다 신뢰도가 떨어짐.

UDP는 비연결성, TCP는 연결성으로 정의할 수 있음.

## HTTP

직역하면 하이퍼텍스트 전달 프로토콜이다.하이퍼텍스트(HyperText)는 인터넷 사용자가 필요한 정보의 자유로운 검색을 가능하도록 해주는 텍스트의 전개 방식이다.

HTTP는 이러한 하이퍼텍스트 방식의 정보를 교환하기 위한 하나의 규칙이다.

즉, HTML과 같은 문서를 전송하기 위해 사용되며 OSI 7 계층에서 응용 계층에 있는 프로토콜이다.

HTTP는 웹 브라우저와 웹 서버의 소통을 위해 디자인되었으며, 전통적인 클라이언트-서버 아키텍처 모델에서 클라이언트가 HTTP 메시지 양식에 맞춰 요청을 보내면, 

이에 서버는 HTTP 메시지 양식에 맞춰 응답을 한다.

HTTP는 특정 상태를 유지하지 않는 무상태성(Stateless)이 특징이다.

## **HTTP 상태 코드**

- **1xx(정보) :** 요청을 받았으며 프로세스를 계속 진행합니다.
- **2xx(성공) :** 요청을 성공적으로 받았으며 인식했고 수용하였습니다.
- **3xx(리다이렉션) :** 요청 완료를 위해 추가 작업 조치가 필요합니다.
- **4xx(클라이언트 오류) :** 요청의 문법이 잘못되었거나 요청을 처리할 수 없습니다.
- **5xx(서버 오류) :** 서버가 명백히 유효한 요청에 대한 충족을 실패했습니다.

# **멱등성(Idempotent)이란?**

멱등성은 수학이나 전산학에서 연산을 여러 번 적용하더라도 결과가 달라지지 않는 성질을 의미한다.

이 멱등성을 HTTP Method에 적용하면 동일한 요청을 연속으로 보낸 결과가 같은 효과를 지니면서 서버의 상태도 동일하게 남을 때, 해당 HTTP Method가 멱등성을 가졌다고 말한다.(멱등성을 만족하는 메서드에는 통계 기록 등을 제외하면 어떠한 부수 효과(side effect)도 존재해서는 안된다.)

# **멱등성을 만족하는 HTTP Method는?**

멱등성을 만족하는지 확인할 땐 서버의 백엔드 상태만 보면된다. 다만 서버는 멱등성을 보장하지 않으며, 일부 애플리케이션은 개발자의 잘못된 구현으로 멱등성 제약을 어길 수도 있다. 올바르게 구현된 REST API의 `GET`, `HEAD`, `OPTIONS`, `PUT`, `DELETE` 메서드는 멱등성이 보장된다.

# **HTTP 버전**

### **1) HTTP 1.0**

- **단기 커넥션(shrot-live connections)** : 요청 날릴때마다 커넥션 맺고 끊어짐

- Request를 날릴 때마다 Connection을 새로 생성해야 함
- Data를 압축해서 전달 가능하도록 하여 전달하는 Data 양이 감소

### **2) HTTP 1.1**

- **지속 커넥션(Persistent connection)** : 커넥션 재사용 가능
- **HTTP 파이프라이닝(Pipelining)** : Request를 미리 여러 개 서버에 날릴 수 있음 (이전엔 리퀘스트 하나보내고, Response 받고, 그 다음 request 보내는 방식이었는데, 파이프라이닝 방식에서는 Request를 연속적으로 보내놓고 Reponse를 받는 방식)
- **단점 : Head Of Line Blocking**  => 요청한 Request에 문제가 생겨 응답이 늦어지면 그 다음 Request의 응답들도 같이 늦어짐

### **3) HTTP 2.0**

- **Multiplexing :** 프레임 단위로 나눠서 전송 관리 가능하게 됨 **(다수의 요청과 응답이 가능한 구조)**
- **데이터 전송 방식 :** 바이너리로 인코딩하여 전송
- **ServerPush 사용** : 브라우저에서 필요한 리소스들을 서버가 알아서 찾아다가 내려주는 것
- 캐싱되지 않은 리소스를 받아올 때
- 페이지에서 필요한 리소스가 페이지를 내려주는 서버에 있을 때

### 4) HTTP 3.0

• TCP 위에서 돌아가는 HTTP/2.0와는 달리 **QUIC**라는 계층 위에서 돌아가며 TCP기반이 아닌 UDP 기반
• HTTP/2.0의 장점(멀티플렉싱 등)의 기능을 가지고 있음
• 초기 연결 설정 시 지연 시간 감소라는 대표적 특징 (UTP기반)
    ◦ 초기 연결(통신 시작) 시 3-way handshaking 과정을 거치지 않아 1-RTT만 소요
    ◦ 클라이언트와 서버거 한번 신호를 주고받은 후 바로 통신 시작
• TCP의 stream은 하나의 chain으로 연결되는 것과 달리 각 stream당 독립된 stream chain을 구성하여 TCP의 HOL Blocking을 해결

# Http header

헤더는 크게 4가지로 분류된다.

- **General Header**(공통 헤더)
- **Request Header**(요청 헤더)
- **Response Header**(응답 헤더)
- **Entity Header**(엔티티 헤더)

### General Header

공통 헤더는 요청 및 응답의 메시지 모두에서 사용되지만 **컨텐츠에는 적용되지 않는 헤더**이다.

흔하게 우리가 사용하는 공통 헤더는 `Date`, `Cache-Control`, `Connection`등이 있다.

### Request Header

요청 헤더는 HTTP 요청에서 사용되지만 메시지의 컨텐츠와 관련이 없는 HTTP 헤더이다.

보통 Fetch될 리소스나 클라이언트 자체에 대한 정보를 포함하여 서버로 보내진다.

### Response Header

위치 또는 서버 자체에 대한 정보(이름, 버전)과 같이 응답에 대한 부가적인 정보를 갖는 헤더이다.


### Entity Header

컨텐츠 길이나 MIME 타입과 같이 Entity Body에 대한 자세한 정보를 포함하는 헤더이다.

**Hypertext Transfer Protocol Secure** 의 준말로, 컴퓨터 네트워크를 통한 보안 통신에 사용되며 인터넷에서 널리 사용된다. HTTPS에서 통신 프로토콜은 **TLS**(Transport Layer Security) 또는 이전에는 **SSL**(Secure Sockets Layer)을 사용하여 암호화된다. 따라서 "HTTP over TLS" 또는 "HTTP over SSL" 이라고도 불린다.

HTTPS 를 사용하는 웹 사이트는 https://~ 와 같은 주소를 갖는다.

HTTPS 프로토콜을 사용하기 위해서는 인증기관(CA)으로 부터 **SSL 인증서**를 발급받아야 한다.

## TLS/SSL 핸드셰이크 프로세스

1. 각각의 TLS 인증서는 공개 키와 개인 키로 이루어진 키 쌍으로 구성되어 있습니다.이 키들은 웹사이트 트랜잭션 동안 보이지 않는 곳에서 상호작용하기 때문에 중요합니다.
2. 웹사이트를 방문할 때마다 클라이언트 서버와 웹 브라우저는 서로 통신하여 보안 TLS/SSL 암호화 연결을 사용하는지 확인합니다.
3. 웹 브라우저(또는 클라이언트)가 보안 웹사이트로 향할 때 웹사이트 서버는 자신의 TLS/SSL 인증서와 공개 키를 클라이언트와 공유하여 안전한 연결과 고유한 세션 키를 설정합니다.
4. 브라우저는 SSL 인증서의 인증 기관인 발급자(여기서는 DigiCert)를 인식하고 확인합니다. 또한 브라우저는 TLS/SSL 인증서가 만료, 해지되지 않았으며 신뢰할 수 있는지를 확인합니다.
5. 브라우저는 대칭 세션 키(symmetric session key)를 돌려 보내고 서버는 자신의 개인 키를 사용해 해당 대칭 세션 키를 해독합니다. 이후 서버는 다시 세션 키로 암호화된 승인을 보내 암호화된 세션을 시작합니다.
6. 서버와 브라우저는 이제 전송되는 모든 데이터를 세션 키로 암호화하고. 메시지 프라이버시, 메시지 무결성, 서버 보안을 보호하는 보안 세션을 시작합니다.

SSL, Secure Sockets Layer 은 암호화 기반의 인터넷 보완 프로토콜이다. TCP transport 위에 위치한 Layer이며

TLS(Transport Layer Security) 암호화의 전신이라고 한다. SSL/TLS를 사용하는 웹사이트의 URL에는 HTTP가 아닌 HTTPS가 붙는다.

### SSL 디지털 인증서란?

클라이언트와 서버간의 통신을 제 3자가 보증해주는 전자화된 문서이다. 클라이언트가 서버에 접속하면 서버는 클라이언트에게 이 인증서 정보를 전달한다.

### 대칭키

대칭키는 동일한 키로 암호화와 복호화를 같이 할 수 있는 방식의 암호화 기법을 의미한다.

직관적이고 간단하다. 서로 정보를 주고 받는 쪽이 같은 키를 갖고 있으면서 이를 암호화, 복호화 할 때마다 사용할 수 있다.

### 공개키

공개키는 두 개의 키가 존재하는데 A라는 키로 암호화를 하면 B라는 키로만 복호화 할 수 있고, B라는 키로 암호화하면 A라는 키로 복화할 수 있는 방식이다.

두 키 중 하나를 공개키, 다른 하나를 비공개키로 지정하여 비공개키는 나만 갖고 있고, 공개키는 다른 타인들에게 공개한다.

서로 안전하게 정보를 주고 받기 위한 암호가 필요한데 해당 암호는 노출되지 않도록 공개-비공개 키 방식으로 주고 받게 되며 암호인 대칭키를 주고 받은 이후로는 해당 암호(대칭키)로 안전하게 데이터를 주고 받을 수 있다.

### DNS

Domain Name System의 약자 DNS는 인터넷의 전화번호부이다. 
사용자가 'naver.com' 또는 'google.com'과 같은 도메인 이름을 웹 브라우저에 입력하는 경우 DNS는 해당 사이트의 **올바른 IP 주소**를 찾는 역할을 한다.

**DNS 구성 요소**

**도메인 네임 스페이스(Domain Name Space)
네임 서버(Name Server) = 권한 있는 DNS 서버
리졸버(Resolver) = 권한 없는 DNS 서버**

## 동작 과정

1. 브라우저에서 요청
2. 브라우저 캐시를 조회해보고 있으면 반환
3. 사용하고 있는 isp에 해당 도메인에 메핑되어있는 ip 주소를 요청한다.
4. 마찬가지로 캐시를 조회해 있으면 반환
5. root dns와 tld, 도메인 제공 업체를 recursive하게 조회하여 ip 주소를 얻어온다.

# 면접 질문

### **Q. 웹 통신의 큰 흐름: https://www.google.com/ 을 접속할 때 일어나는 일을 설명해보세요**

1) Host가 google.com을 검색하면 OS에서 NIC(network Interface Card, 이거 하나 당 IP하나씩 받을 수 있음)를 통해

요청을 보내야 한다. Host는 google의 IP주소를 알아야 한다.

2) 내가 IP주소를 아는지 모르는지 판단하기 위해 hosts와 DNS cache에서 mapping 정보를 확인한다.(DNS Lookup)

3) 2)에서 없으면 DNS서버로 요청을 보내서 응답을 받는다. (공유기 / 라우터가 DNS를 알고있음. 인터넷 망을 통해 DNS서버로 요청을 한다.)

4) 그 IP주소로 http request를 보내고 응답을 받는다. (해당 IP로 가는 경로는 중간중간의 Router들의 Routing Table에 저장되어있다.)

### **Q. TCP와 UDP의 차이점에 대해서 설명해보세요.**

- TCP는 Connection Oriented Protocol(연결 지향형 프로토콜)로, 신뢰성있는 데이터전송을 보장한다.
- UDP는 Connectionless Protocol로 빠르지만 데이터의 유실 가능성이 존재한다.
- 그래서 일반적인 경우, TCP를 사용하고 데이터가 유실되더라도 실시간성이 중요한 스트리밍방송, 통화 등에서는 UDP를 사용한다.

### **Q. UDP는 항상 신뢰성을 보장하지 않나요?**

- UDP도 신뢰성을 UDP자체에서 보장하지 않는 것 뿐이지, 개발자가 직접 신뢰성을 보장하도록 할 수 있습니다. HTTP/3의 경우, UDP 기반의 QUIC이라는 프로토콜을 사용합니다. UDP 자체는 신뢰성을 보장하지 않지만, 추가적인 정의를 통해 신뢰성을 보장받을 수 있습니다.

### **Q. 혼잡제어란?**

- 송신측의 데이터 전달과 네트워크의 데이터 처리 속도를 해결하기 위한 기법
- **네트워크의 혼잡을 피하기 위해 송신측에서 보내는 데이터의 전송 속도를 제어**하는 것이 혼잡 제어의 개념이다.

### **Q. HTTP 프로토콜에 대해 설명해주세요.**

HTTP(Hyper Text Transfer Protocol)이란 데이터를 주고 받기 위한 프로토콜이며, 서버/클라이언트 모델을 따릅니다.

HTTP는 상태 정보를 저장하지 않는 Stateless의 특징과 클라이언트의 요청에 맞는 응답을 보낸 후 연결을 끊는 Connectionless의 특징을 가지고 있습니다.

- 장점
    - 통신간의 연결 상태 처리나 상태 정보를 관리할 필요가 없어 서버 디자인이 간단하다.
    - 각각의 HTTP 요청에 독립적으로 응답만 보내주면 OK
- 단점
    - 이전 통신의 정보를 모르기 때문에 매번 인증을 해줘야 한다.
    - 이를 해결하기 위해 쿠키(cookie)나 세션(session)을 사용해서 데이터를 처리한다.


### **Q. HTTP와 HTTPS의 차이점은 무엇인가요?**

HTTP는 평문 데이터를 전송하는 프로토콜이기 때문에, HTTP로 중요한 정보를 주고 받으면 제 3자에 의해 조회될 수 있습니다.

이러한 문제를 해결하기 위해 HTTP에 암호화가 추가된 프로토콜이 HTTPS입니다.

HTTPS는 SSL의 껍질을 덮어쓴 HTTP라고 할 수 있습니다.

※ SSL(Secure Socket Layer) 인터넷을 통해 전달되는 정보를 보호하기 위해 개발한 통신 규약

HTTP는 원래 TCP와 직접 통신했지만, HTTPS에서 HTTP는 SSL과 통신하고 SSL이 TCP와 통신함으로써 암호화와 증명서, 안전성 보호를 이용할 수 있게 됩니다.

### **Q. SSL 동작원리는?**

사용자가 웹브라우저로 사이트에 접속하면 웹서버는 인증서를 웹 브라우저에게 보낸다. 

이 인증서에는 인증기관의 개인키로 암호화된 사이트의 정보와 공개키가 들어 있다.  

웹 브라우저는 이미 가지고 있는 인증기관의 공개키로 웹 서버에서 받은 인증서를 복호화 해서 확인한다.

웹 브라우저는 실제 데이터의 암호화에 사용될 대칭키를 생성하고, 인증서에서 꺼낸 웹 서버 측의 공개키로 암호화 해서 웹 서버로 보낸다.

웹서버는 자신이 가지고 있는 개인키로 웹 브라우저가 보내온 대칭키를 복호화 해서 얻는다. 

이제 이 대칭키로 데이터를 암호화해서 주고 받게 된다.

### **Q. HTTP Method와 각각이 사용되는 경우에 대해서 설명해주세요.**

| 종류 | 기능 |
| --- | --- |
| GET | 데이터 조회 |
| POST | 요청 데이터 처리(보통 데이터 등록 사용) |
| PUT | 데이터 변경 (해당 데이터가 없으면 생성) |
| PATCH | 일부 데이터만 변경 |
| DELETE | 데이터 삭제 |

### **Q. GET과 POST의 차이점에 대해 설명해주세요.**

- **GET**은 데이터를 조회하기 위해 사용되는 방식으로 데이터를 헤더에 추가하여 전송하는 방식이다.

URL에 데이터가 노출되므로 보안적으로 중요한 데이터를 포함해서는 안된다.

- **POST**는 데이터를 추가, 수정하기 위해 사용되는 방식으로 데이터를 바디에 추가하여 전송하는 방식이다.

완전히 안전하다는 것은 아니지만 URL에 데이터가 노출되지 않아 GET 보다는 안전하다.


# Ref

TCP : 

[https://velog.io/@younghyun/TCP란](https://velog.io/@younghyun/TCP%EB%9E%80)

https://benlee73.tistory.com/186

https://evan-moon.github.io/2019/11/22/tcp-flow-control-error-control/
https://seongonion.tistory.com/74 

면접 질문 : https://land-turtler.tistory.com/154

HTTP : 

https://gyoogle.dev/blog/computer-science/network/UDP.html 

https://ittrue.tistory.com/192

https://zu-techlog.tistory.com/113
SSL :

https://offbyone.tistory.com/274

DNS : [https://hanamon.kr/dns란-도메인-네임-시스템-개념부터-작동-방식까지/](https://hanamon.kr/dns%EB%9E%80-%EB%8F%84%EB%A9%94%EC%9D%B8-%EB%84%A4%EC%9E%84-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EA%B0%9C%EB%85%90%EB%B6%80%ED%84%B0-%EC%9E%91%EB%8F%99-%EB%B0%A9%EC%8B%9D%EA%B9%8C%EC%A7%80/) 
