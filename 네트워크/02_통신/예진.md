# 2주차 스터디

- 통신
    - TCP
        - 흐름제어, 혼잡제어, 오류제어
        - 3-way-handshake, 4-way-handshake
    - UDP
    - HTTP
        - HTTP status code
        - HTTP method
            - 종류
            - 멱등성
            - PUT, PATCH, POST method 차이
        - HTTP 1.1, 2.0, 3.0
        - HTTP 헤더
    - HTTPS, SSL/TLS
        - 동작 원리
        - 공개키 대칭키 방식
    - DNS

# TCP(Transmission Control Protocol)란?

`TCP`는 서버와 클라이언트 간에 데이터를 **신뢰성 있게 전달**하기 위해 만들어진 프로토콜이다.

데이터를 전송하기 전에 데이터 전송을 위한 연결을 만드는 **연결지향 프로토콜**이다.

**데이터는 네트워크 선로를 통해 전달되는 과정에서 손실되거나 순서가 바뀌어서 전달**될 수 있는데, TCP는 손실을 검색해서 이를 교정하고 **순서를 재조합할 수 있도록 도와준다.**

> TCP/IP란?
> 
> 
> `TCP/IP`는 전송계층의 TCP와 네트워크 계층의 IP프로토콜을 합친 프로토콜 스위트(모음)으로, TCP는 데이터의 정확성 확인, IP는 패킷을 목적지까지 전송하는 역할을 한다.
> 
> 인터넷 접속을 위한 기본 프로토콜이다.

## **TCP의 특징**

- 신뢰성 있는 데이터 통신을 가능하게 한다. (Sequence Number, Ack Number)
- 데이터의 경계를 구분하지 않는다. (바이트 스트림 서비스)
- 데이터의 전송 순서를 보장한다. (순서 유지를 위해 각 바이트마다 번호를 부여)
- 데이터 흐름 제어(수신자 버퍼 오버플로우 방지) 및 혼잡 제어(패킷 수가 과도하게 증가하는 현상 방지)
- 연결의 설정 (3-way handshake)해제 (4-way handshake)
- 전이중(Full-Duplex), 점대점(Point to Point) 서비스
- `UDP`에 비해 전송 속도가 느리다.

TCP는 크게 3가지 제어 기능이 있다.

- 전송되는 데이터의 양을 조절하는 **흐름 제어**
- 데이터가 유실되거나 잘못된 데이터가 수신되었을 경우 대처하는 방법인 **오류 제어**
- 네트워크 혼잡에 대처하는 **혼잡 제어**

이 기능들 덕분에 예외 상황에 크게 신경쓰지 않고 상위 레이어 동작에 집중할 수 있다.

## **흐름 제어**

송신 측과 수신 측의 데이터 처리 속도가 다를 수 있다.

송신 측이 빠를 때 수신 측 버퍼가 넘치는 **오버플로우** 문제가 발생한다.

이러한 문제를 줄이기 위해 윈도우 크기로 **송신 측의 데이터 전송량을 조절**한다.

- **윈도우 크기** : 자신이 처리할 수 있는 데이터의 양

### **stop and wait**

상대방에게 데이터를 보낸 후 잘 받았다는 응답이 올 때까지 기다리는 방식

### **sliding winodw**

**송신 측이 수신 측에서 받은 윈도우 크기를 참고해서 데이터의 흐름을 제어하는 방식**

- 수신 측이 한 번에 처리할 수 있는 데이터의 양(**윈도우 크기)을 3 way handshake할 때 송신 측에 전달**한다.
- 상대방에게 **응답을 받지 않아도 범위 내에서 데이터를 보낼 수 있다.**
- 패킷의 왕복 시간(RTT)이 크다면 **네트워크가 혼잡하다고 생각하여 윈도우 크기를 실제 버퍼의 크기보다 작게 설정**한다.
- 통신 과정 중에도 네트워크 혼잡 등의 조건을 통해 **윈도우 크기는 유동적으로 설정**된다.

## **오류 제어**

TCP는 통신 중에 오류가 발생하면 해당 데이터를 재전송한다.

즉, **재전송 기반 오류 제어 ARQ(Automatic Repeat Request)**를 사용한다.

재전송은 비효율적이므로 적을수록 좋다.

### **오류를 알 수 있는 방법**

- 송신 측이 ACK(긍정응답)을 받지 못함
    - 송신 측이 보낸 데이터가 유실되거나, 수신 측이 보낸 ACK 데이터가 유실될 경우
- 중복된 ACK를 받는다.
- 수신 측이 NACK(부정응답)을 보냄
    - ACK만으로 오류를 추정하기 위해 사용하지 않기도 한다.

### **Stop and Wait**

**ACK를 받고 나서 다음 데이터를 보내는 방식**이다.

일정 시간을 지나 timeout이 발생하면 이전 데이터를 재전송한다.

흐름 제어에서의 슬라이딩 윈도우를 사용할 수 없으므로 더 효율적인 ARQ가 필요하다.

### **Go Back N**

연속으로 데이터를 보내다가 **오류가 발생한 지점부터 재전송하는 방식**이다.

아래처럼 4번 데이터에서 에러가 발생했다면 4번 이후의 데이터는 모두 삭제한다.

**성공적으로 전송된 데이터까지 재전송하기 때문에 조금 비효율적**이다.

### **Selective Repeat**

**오류가 발생한 데이터만 재전송하는 방식**이다.

Selective Repeat의 단점은 수신 측 **버퍼의 데이터가 순차적이지 않다**는 것이다.

정렬의 과정이 추가로 필요하고 별도의 버퍼가 필요하다.

Go Back N과 비교하여 상황에 따라 더 유리한 방법을 선택하면 된다.

## **혼잡 제어**

네트워크 내에 패킷의 수가 과도하게 증가하는 현상을 **혼잡**이라고 한다.

혼잡 제어는 **혼잡 현상을 방지하고 제거하기 위한 기능**이다.

흐름 제어는 송신 측과 수신 측의 전송 속도를 다루고, 혼잡 제어는 라우터를 포함한 넓은 범위의 전송 문제를 다룬다.

### **AIMD (Additive Increase / Multiplicative Decrease)**

- 처음에 패킷을 하나씩 보내고 문제가 발생하지 않으면 윈도우 크기를 1씩 증가하는 방법
- 패킷 전송에 실패하거나 일정 시간을 넘으면 패킷 전송 속도를 절반으로 줄인다.
- 네트워크에 늦게 들어온 호스트가 처음에는 불리하지만, 시간이 흐르면서 평형상태로 수렴한다.
- 단점
    - 처음에 전송 속도를 올리는 데 시간이 오래걸린다.
    - 네트워크가 혼잡해지는 상황을 미리 감지하지 못한다. 즉, 네트워크가 혼잡해지고 나서야 대역폭을 줄인다.

### **Slow Start (느린 시작)**

- AIMD와 같이 패킷을 하나씩 보내고 문제가 발생하지 않으면 각 ACK 패킷마다 윈도우 크기를 1씩 늘려준다. 즉, 한 주기가 지나면 윈도우 크기는 2배가 된다.
- AIMD와 달리 전송 속도를 지수 함수 꼴로 증가시켜서 윈도우 크기를 더 빠르게 증가시킨다.
- 혼잡이 감지되면 윈도우 크기를 1로 줄인다.
- 처음에는 네트워크 수용량을 예상할 수 있는 정보가 없지만, 한 번 혼잡 현상이 발생한 후에는 네트워크의 수용량을 어느 정도 예상할 수 있다.
- 그래서 혼잡 현상이 발생하는 윈도우 크기의 절반가지는 지수 함수 꼴로 윈도우 크기를 증가시키고 그 이후에는 완만하게 1씩 증가시킨다.

### **Fast Retransmit (빠른 재전송)**

- TCP는 지금가지 받은 데이터 중 연속되는 패킷의 마지막 순번 이후를 ACK 패킷에 실어서 보낸다.
- 그래서 송신 측이 아래처럼 3, 4번을 보내더라도 ACK 2 를 중복해서 받는다.
- 그러면 timeout이 발생하기 전이라도 송신 측은 문제가 되는 2번 패킷을 재전송한다.
- 그리고 혼잡한 상황이라고 판단해서 윈도우 크기를 줄인다.
- 3 ACK Duplicated : 송신 측이 3번 이상 중복된 ACK 번호를 받은 상황

### **Fast Recovery (빠른 회복)**

- 혼잡한 상태가 되면 윈도우 크기를 1이 아니라 반으로 줄이고, 선형 증가시킨다.
- 혼잡 상황을 한번 겪은 이후로는 AIMD 방식으로 동작한다.

## 3-way handshake & 4-way handshake

### **1. TCP 3-way Handshake 란?**

TCP는 장치들 사이에 논리적인 접속을 성립(establish)하기 위하여 three-way handshake를 사용한다.

**TCP 3 Way Handshake는 TCP/IP프로토콜을 이용해서 통신을 하는 응용프로그램이 데이터를 전송하기 전에**

**먼저 정확한 전송을 보장하기 위해 상대방 컴퓨터와 사전에 세션을 수립하는 과정을 의미한다..**

Client > Server : **TCP SYN**

Server > Client : **TCP SYN, ACK**

Client > Server : **TCP ACK**

여기서 SYN은 'synchronize sequence numbers', 그리고 ACK는'acknowledgment' 의 약자이다.

이러한 절차는 TCP 접속을 성공적으로 성립하기 위하여 반드시 필요하다.

- **TCP의 3-way Handshaking 역할**
- 양쪽 모두 데이타를 전송할 준비가 되었다는 것을 보장하고, 실제로 데이타 전달이 시작하기전에

한쪽이 다른 쪽이 준비되었다는 것을 알수 있도록 한다.

- 양쪽 모두 상대편에 대한 초기 순차일련변호를 얻을 수 있도록 한다.

- **TCP의 3-way Handshaking 과정**

**[STEP 1]**

A클라이언트는 B서버에 접속을 요청하는 SYN 패킷을 보낸다.

이때 A클라이언트는 SYN 을 보내고 SYN/ACK 응답을 기다리는 **SYN_SENT** 상태, **B서버는 Wait for Client** 상태이다.

**[STEP 2]**

B서버는 SYN요청을 받고 A클라이언트에게 요청을 수락한다는 ACK 와 SYN flag 가 설정된 패킷을 발송하고

A가 다시 ACK으로 응답하기를 기다린다. 이때 **B서버**는 **SYN_RECEIVED** 상태가 된다.

**[STEP 3]**

A클라이언트는 B서버에게 ACK을 보내고 이후로부터는 연결이 이루어지고 데이터가 오가게 되는것이다.

이때의 **B서버 상태가 ESTABLISHED** 이다.

위와 같은 방식으로 통신하는것이 신뢰성 있는 연결을 맺어 준다는 TCP의 3 Way handshake 방식이다.

### **2. 4-way Handshaking**

3-Way handshake는 TCP의 연결을 초기화 할 때 사용한다면,

4-Way handshake는 세션을 종료하기 위해 수행되는 절차.

- **TCP의 4-way Handshaking 과정**

**[STEP 1]**

클라이언트가 연결을 종료하겠다는 FIN플래그를 전송한다. 이때 **A클라이언트는  FIN-WAIT** 상태가 된다.

**[STEP 2]**

B서버는 FIN플래그를 받고, 일단 확인메시지 ACK 보내고 자신의 통신이 끝날때까지 기다리는데 이 상태가

**B서버의 CLOSE_WAIT**상태다.

**[STEP 3]**

연결을 종료할 준비가 되면, 연결해지를 위한 준비가 되었음을 알리기 위해  클라이언트에게 FIN플래그를 전송한다. 이때 B서버의 상태는 **LAST-ACK**이다.

**[STEP 4]**

클라이언트는 해지준비가 되었다는 ACK를 확인했다는 메시지를 보낸다.

**A클라이언트의 상태가 FIN-WAIT ->TIME-WAIT** 으로 변경된다.

그런데 만약 "Server에서 FIN을 전송하기 전에 전송한 패킷이 Routing 지연이나 패킷 유실로 인한 재전송 등으로 인해 FIN패킷보다 늦게 도착하는 상황"이 발생한다면 어떻게 될까?

Client에서 세션을 종료시킨 후 뒤늦게 도착하는 패킷이 있다면 이 패킷은 Drop되고 데이터는 유실될 것.

**A클라이언트**는 이러한 현상에 대비하여 Client는 Server로부터 FIN을 수신하더라도 일정시간(디폴트 240초) 동안 세션을 남겨놓고 잉여 패킷을 기다리는 과정을 거치게 되는데 이 과정을 **"TIME_WAIT"** 라고 한다. 일정시간이 지나면, 세션을 만료하고 연결을 종료시키며, **"CLOSE"** 상태로 변화.

**UDP 통신이란?**

- User Datagram Protocol의 약자로 데이터를 데이터그램 단위로 처리하는 프로토콜이다.
- 비연결형, 신뢰성 없는 전송 프로토콜이다.
- 데이터그램 단위로 쪼개면서 전송을 해야하기 때문에 전송 계층이다.
- Transport layer에서 사용하는 프로토콜.
- **TCP와 UDP가 어떻게 오류를 해결하는가?**
    - **TCP**
        
        데이터의 분실, 중복, 순서가 뒤바뀜 등을 자동으로 보정해줘서 송수신 데이터의 정확한 전달을 할 수 있도록 해준다.
        
    - **UDP**
        
        IP가 제공하는 정도의 수준만을 제공하는 간단한 IP 상위 계층의 프로토콜이다. TCP와는 다르게 에러가 날 수도 있고, 재전송이나 순서가 뒤바뀔 수도 있어서 이 경우, 어플리케이션에서 처리하는 번거로움이 존재한다.
        
- **UDP는 왜 사용할까?**
    - UDP의 결정적인 장점은 데이터의 신속성이다. 데이터의 처리가 TCP보다 빠르다.
    - 주로 실시간 방송과 온라인 게임에서 사용된다. 네트워크 환경이 안 좋을때, 끊기는 현상을 생각하면 된다.
- **DNS(Domain Name Service)에서 UDP를 사용하는 이유**
    - Request의 양이 작음 -> UDP Request에 담길 수 있다.
    - 3 way handshaking으로 연결을 유지할 필요가 없다. (오버헤드 발생)
    - Request에 대한 손실은 Application Layer에서 제어가 가능하다.
    - DNS : port 53번
    - But, TCP를 사용할 때가 있다! 크기가 512(UDP 제한)이 넘을 때, TCP를 사용해야한다.

TCP 보다 용량이 가볍고 송신 속도가 빠르게 작동됨.

그러나 확인 응답을 못하므로, TCP보다 신뢰도가 떨어짐.

UDP는 비연결성, TCP는 연결성으로 정의할 수 있음.

## HTTP

직역하면 하이퍼텍스트 전달 프로토콜이다.하이퍼텍스트(HyperText)는 인터넷 사용자가 필요한 정보의 자유로운 검색을 가능하도록 해주는 텍스트의 전개 방식이다.

HTTP는 이러한 하이퍼텍스트 방식의 정보를 교환하기 위한 하나의 규칙이다.

즉, HTML과 같은 문서를 전송하기 위해 사용되며 OSI 7 계층에서 응용 계층에 있는 프로토콜이다.

HTTP는 웹 브라우저와 웹 서버의 소통을 위해 디자인되었으며, 전통적인 클라이언트-서버 아키텍처 모델에서 클라이언트가 HTTP 메시지 양식에 맞춰 요청을 보내면, 

이에 서버는 HTTP 메시지 양식에 맞춰 응답을 한다.

HTTP는 특정 상태를 유지하지 않는 무상태성(Stateless)이 특징이다.

## **HTTP 상태 코드**

- **1xx(정보) :** 요청을 받았으며 프로세스를 계속 진행합니다.
- **2xx(성공) :** 요청을 성공적으로 받았으며 인식했고 수용하였습니다.
- **3xx(리다이렉션) :** 요청 완료를 위해 추가 작업 조치가 필요합니다.
- **4xx(클라이언트 오류) :** 요청의 문법이 잘못되었거나 요청을 처리할 수 없습니다.
- **5xx(서버 오류) :** 서버가 명백히 유효한 요청에 대한 충족을 실패했습니다.

# **멱등성(Idempotent)이란?**

멱등성은 수학이나 전산학에서 연산을 여러 번 적용하더라도 결과가 달라지지 않는 성질을 의미한다.

이 멱등성을 HTTP Method에 적용하면 동일한 요청을 연속으로 보낸 결과가 같은 효과를 지니면서 서버의 상태도 동일하게 남을 때, 해당 HTTP Method가 멱등성을 가졌다고 말한다.(멱등성을 만족하는 메서드에는 통계 기록 등을 제외하면 어떠한 부수 효과(side effect)도 존재해서는 안된다.)

# **멱등성을 만족하는 HTTP Method는?**

멱등성을 만족하는지 확인할 땐 서버의 백엔드 상태만 보면된다. 다만 서버는 멱등성을 보장하지 않으며, 일부 애플리케이션은 개발자의 잘못된 구현으로 멱등성 제약을 어길 수도 있다. 올바르게 구현된 REST API의 `GET`, `HEAD`, `OPTIONS`, `PUT`, `DELETE` 메서드는 멱등성이 보장된다.

# **HTTP 버전**

### **1) HTTP 1.0**

- **단기 커넥션(shrot-live connections)** : 요청 날릴때마다 커넥션 맺고 끊어짐

- Request를 날릴 때마다 Connection을 새로 생성해야 함
- Data를 압축해서 전달 가능하도록 하여 전달하는 Data 양이 감소

### **2) HTTP 1.1**

- **지속 커넥션(Persistent connection)** : 커넥션 재사용 가능
- **HTTP 파이프라이닝(Pipelining)** : Request를 미리 여러 개 서버에 날릴 수 있음 (이전엔 리퀘스트 하나보내고, Response 받고, 그 다음 request 보내는 방식이었는데, 파이프라이닝 방식에서는 Request를 연속적으로 보내놓고 Reponse를 받는 방식)
- **단점 : Head Of Line Blocking**  => 요청한 Request에 문제가 생겨 응답이 늦어지면 그 다음 Request의 응답들도 같이 늦어짐

### **3) HTTP 2.0**

- **Multiplexing :** 프레임 단위로 나눠서 전송 관리 가능하게 됨 **(다수의 요청과 응답이 가능한 구조)**
- **데이터 전송 방식 :** 바이너리로 인코딩하여 전송
- **ServerPush 사용** : 브라우저에서 필요한 리소스들을 서버가 알아서 찾아다가 내려주는 것
- 캐싱되지 않은 리소스를 받아올 때
- 페이지에서 필요한 리소스가 페이지를 내려주는 서버에 있을 때

### 4) HTTP 3.0

• TCP 위에서 돌아가는 HTTP/2.0와는 달리 **QUIC**라는 계층 위에서 돌아가며 TCP기반이 아닌 UDP 기반
• HTTP/2.0의 장점(멀티플렉싱 등)의 기능을 가지고 있음
• 초기 연결 설정 시 지연 시간 감소라는 대표적 특징 (UTP기반)
    ◦ 초기 연결(통신 시작) 시 3-way handshaking 과정을 거치지 않아 1-RTT만 소요
    ◦ 클라이언트와 서버거 한번 신호를 주고받은 후 바로 통신 시작
• TCP의 stream은 하나의 chain으로 연결되는 것과 달리 각 stream당 독립된 stream chain을 구성하여 TCP의 HOL Blocking을 해결

# Http header

헤더는 크게 4가지로 분류된다.

- **General Header**(공통 헤더)
- **Request Header**(요청 헤더)
- **Response Header**(응답 헤더)
- **Entity Header**(엔티티 헤더)

### General Header

공통 헤더는 요청 및 응답의 메시지 모두에서 사용되지만 **컨텐츠에는 적용되지 않는 헤더**이다.

흔하게 우리가 사용하는 공통 헤더는 `Date`, `Cache-Control`, `Connection`등이 있다.

### Request Header

요청 헤더는 HTTP 요청에서 사용되지만 메시지의 컨텐츠와 관련이 없는 HTTP 헤더이다.

보통 Fetch될 리소스나 클라이언트 자체에 대한 정보를 포함하여 서버로 보내진다.

### Response Header

위치 또는 서버 자체에 대한 정보(이름, 버전)과 같이 응답에 대한 부가적인 정보를 갖는 헤더이다.


### Entity Header

컨텐츠 길이나 MIME 타입과 같이 Entity Body에 대한 자세한 정보를 포함하는 헤더이다.

**Hypertext Transfer Protocol Secure** 의 준말로, 컴퓨터 네트워크를 통한 보안 통신에 사용되며 인터넷에서 널리 사용된다. HTTPS에서 통신 프로토콜은 **TLS**(Transport Layer Security) 또는 이전에는 **SSL**(Secure Sockets Layer)을 사용하여 암호화된다. 따라서 "HTTP over TLS" 또는 "HTTP over SSL" 이라고도 불린다.

HTTPS 를 사용하는 웹 사이트는 https://~ 와 같은 주소를 갖는다.

HTTPS 프로토콜을 사용하기 위해서는 인증기관(CA)으로 부터 **SSL 인증서**를 발급받아야 한다.

SSL, Secure Sockets Layer 은 암호화 기반의 인터넷 보완 프로토콜이다. TCP transport 위에 위치한 Layer이며

TLS(Transport Layer Security) 암호화의 전신이라고 한다. SSL/TLS를 사용하는 웹사이트의 URL에는 HTTP가 아닌 HTTPS가 붙는다.

### SSL 디지털 인증서란?

클라이언트와 서버간의 통신을 제 3자가 보증해주는 전자화된 문서이다. 클라이언트가 서버에 접속하면 서버는 클라이언트에게 이 인증서 정보를 전달한다.

### 대칭키

대칭키는 동일한 키로 암호화와 복호화를 같이 할 수 있는 방식의 암호화 기법을 의미한다.

직관적이고 간단하다. 서로 정보를 주고 받는 쪽이 같은 키를 갖고 있으면서 이를 암호화, 복호화 할 때마다 사용할 수 있다.

### 공개키

공개키는 두 개의 키가 존재하는데 A라는 키로 암호화를 하면 B라는 키로만 복호화 할 수 있고, B라는 키로 암호화하면 A라는 키로 복화할 수 있는 방식이다.

두 키 중 하나를 공개키, 다른 하나를 비공개키로 지정하여 비공개키는 나만 갖고 있고, 공개키는 다른 타인들에게 공개한다.

서로 안전하게 정보를 주고 받기 위한 암호가 필요한데 해당 암호는 노출되지 않도록 공개-비공개 키 방식으로 주고 받게 되며 암호인 대칭키를 주고 받은 이후로는 해당 암호(대칭키)로 안전하게 데이터를 주고 받을 수 있다.

### DNS

Domain Name System의 약자 DNS는 인터넷의 전화번호부이다. 
사용자가 'naver.com' 또는 'google.com'과 같은 도메인 이름을 웹 브라우저에 입력하는 경우 DNS는 해당 사이트의 **올바른 IP 주소**를 찾는 역할을 한다.

**DNS 구성 요소**

**도메인 네임 스페이스(Domain Name Space)
네임 서버(Name Server) = 권한 있는 DNS 서버
리졸버(Resolver) = 권한 없는 DNS 서버**

# 면접 질문

- TCP와 UDP의 차이점에 대해서 설명해보세요.
- 3 way hank shake 와 4 way hand shake에 대해 설명해주세요.
- UDP는 항상 신뢰성을 보장하지 않나요?
- 혼잡제어란?
- HTTP 프로토콜에 대해 설명해주세요.
- HTTP와 HTTPS의 차이점은 무엇인가요?
- HTTP Method와 각각이 사용되는 경우에 대해서 설명해주세요.
- SSL 동작원리는?
- DNS가 무엇이고 어떻게 동작하는지 설명해주세요.

# Ref

TCP : 

[https://velog.io/@younghyun/TCP란](https://velog.io/@younghyun/TCP%EB%9E%80)

https://benlee73.tistory.com/186

https://evan-moon.github.io/2019/11/22/tcp-flow-control-error-control/
https://seongonion.tistory.com/74 

면접 질문 : https://land-turtler.tistory.com/154

HTTP : 

https://gyoogle.dev/blog/computer-science/network/UDP.html 

https://ittrue.tistory.com/192

https://zu-techlog.tistory.com/113
SSL :

https://offbyone.tistory.com/274

DNS : [https://hanamon.kr/dns란-도메인-네임-시스템-개념부터-작동-방식까지/](https://hanamon.kr/dns%EB%9E%80-%EB%8F%84%EB%A9%94%EC%9D%B8-%EB%84%A4%EC%9E%84-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EA%B0%9C%EB%85%90%EB%B6%80%ED%84%B0-%EC%9E%91%EB%8F%99-%EB%B0%A9%EC%8B%9D%EA%B9%8C%EC%A7%80/) 
