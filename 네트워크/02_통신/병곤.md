# 통신

- TCP
    - TCP
        - TCP란
            - 두개의 호스트 내 프로세스 상호 간에 신뢰적인 연결지향성 서비스를 제공
                - IP의 비신뢰적인 최선형 서비스(Best-Effort Service)를 이용하여 신뢰적인 연결지향성 서비스를 제공
            - TCP/IP 프로토콜 중 하나
                - OSI 계층모델의 관점에서 4 계층에 해당
        - 특징
            - 신뢰성(reliable, reliability) 있는 데이터 전송
                
                ### 데이터 패킷의 신뢰적 전달
                
                - 네트워크를 통한 패킷 전달을 완전히 보장(소실, 중복, 지연, 순서역전 등의 방지)
                
                ### 신뢰성 조건
                
                - 순서 제어(Sequencing Control)
                - 흐름 제어(Flow Control)
                - 재전송 기반 에러제어, ARQ(Automatic Repeat Request)
                - 에러 제어
            - 연결지향적(Connection-oriented)
                - 강한 연결을 의미하는 가상회선이라는 표현 보다는, 오히려 연결지향적이라고 말함
                - 연결 관리를 위한 연결설정 및 연결해제 필요
            - TCP 연결 식별
                - 2개의 IP 주소 및 2개의 포트 번호에 의한 4개가 하나의 연결을 식별함
            - 혼잡 제어 (Congestion Control)
                - 네트워크가 혼잡하다고 판단될 때 송신률을 감속
                - TCP는 혼잡제어를 위해 수신 윈도우(rwnd) 및 혼잡 윈도우(cwnd) 2개의 변수를 관리
                - 이 중 최소가되는 크기를 윈도우 크기로 잡게 됨
            - 세트먼트화 처리(데이터를 패키징 해서 처리)
                - 바이트들을 모아서 세그먼트화하고 이에 TCP 헤더를 붙이고, 이들을 순서제어함
            - 비 실시간적 응용
                - TCP는 데이터의 전달에 대한 보장을 하지만, 전달에 따른 지연에 취약하다.
                - 따라서 실시간적 응용에는 UDP를 사용 한다.
        - 작동방식
            - **1. 연결 설정**: 3-way Handshake
                
                ## TCP 연결 설정 (3-way Handshake)
                
                TCP 연결 설정은 '3-way handshake'라는 과정을 통해 이루어집니다. 이 과정은 안정적인 통신 채널을 설정하고, 데이터 전송 전 양쪽 모두가 준비되었음을 확인하기 위해 필요합니다.
                
                1. **SYN**: 클라이언트가 서버에 연결을 요청하기 위해 SYN(synchronize sequence numbers) 패킷을 보냅니다. 이 패킷에는 클라이언트가 데이터 전송을 시작하는 데 사용할 초기 시퀀스 번호가 포함됩니다.
                2. **SYN-ACK**: 서버는 SYN 요청을 받고, 클라이언트에게 SYN-ACK(SYN과 ACKnowledgement) 패킷을 보내 연결 요청을 수락함과 동시에 자신의 시퀀스 번호를 알립니다.
                3. **ACK**: 클라이언트는 서버의 SYN-ACK 패킷을 받고, ACK 패킷을 서버로 보내 연결 과정을 완료합니다. 이 시점부터 클라이언트와 서버 간의 데이터 전송이 시작됩니다.
            1. **데이터 전송**: 연결이 설정되면, 데이터를 세그먼트로 나누어 네트워크를 통해 전송합니다. 각 세그먼트에는 순서 번호가 포함되어 있어, 수신 측에서는 이 번호를 통해 데이터를 재조립합니다.
            - **3. 연결 종료**: 4-way Handshake
                
                TCP 연결 종료는 '4-way handshake' 과정을 통해 이루어집니다. 이 과정은 연결을 정상적으로 종료하고, 양쪽 모두가 데이터 전송이 완료되었음을 확인하기 위해 필요합니다.
                
                1. **FIN**: 통신을 종료하고자 하는 측(일반적으로 클라이언트)이 FIN(finish) 패킷을 보내 연결 종료 의사를 전달합니다.
                2. **ACK**: 상대방(서버)은 FIN 패킷을 받고, ACK 패킷을 보내 이를 확인합니다. 이 시점에서 서버는 클라이언트로부터 더 이상의 데이터를 받지 않지만, 서버가 아직 전송하지 않은 데이터가 있다면 이 시점에 전송할 수 있습니다.
                3. **FIN**: 서버가 모든 데이터를 클라이언트에게 전송하면, 서버 역시 FIN 패킷을 클라이언트에게 보내 연결 종료 의사를 전달합니다.
                4. **ACK**: 클라이언트는 서버의 FIN 패킷을 받고, 마지막 ACK 패킷을 보냄으로써 연결 종료 과정을 완료합니다. 이 후, TCP 연결은 완전히 종료됩니다.
        - TCP 구조
            
            IP datagram 안에 TCP data가 캡슐화 됨
            
            - TCP 패킹 헤더
                
                ### Source/Destination Port Number (각 16 비트)
                
                - IP 주소와 포트 번호의 조합은 소켓 주소를 형성합니다.
                - 이를 통해 양쪽 호스트 내 종단 프로세스를 식별합니다.
                
                ### Sequence Number (32 비트)
                
                - 바이트 단위로 구분되어 순서화되는 번호입니다.
                - TCP에서 신뢰성 및 흐름제어 기능을 제공합니다.
                - 시작은 임의 값에서 시작하여 최대값 이후에는 0으로 되돌아갑니다.
                
                ### Acknowledgement Number (32 비트)
                
                - 수신을 기대하는 다음 바이트 번호입니다.
                - [[확인응답(Acknowledgement)]] 참조
                
                ### 헤더 길이 필드 (4 비트)
                
                - TCP 헤더의 길이를 4 바이트 단위로 표시합니다.
                
                ### 6개의 Flag bits
                
                - URG, ACK, PSH, RST, SYN, FIN 플래그는 TCP 회선 및 데이터 관리 제어 기능을 합니다.
                
                ### 윈도우 크기 (16 비트)
                
                - 흐름제어를 위해 사용되며, 송신자에게 수신 버퍼의 여유 용량을 알립니다.
                
                ### Checksum (16 비트)
                
                - 데이터 전송 중 오류를 검출하는 데 사용됩니다.
                
                ### Urgent pointer (16 비트)
                
                - 긴급 데이터의 끝을 알려주는 일련번호입니다.
                
                ### 옵션
                
                - 최대 40 바이트까지 다양한 옵션을 포함할 수 있습니다.
            - TCP 포트의 식별 번호
                
                ### TCP/IP에서 포트 번호의 식별, 길이, 전달
                
                ### 포트 번호의 식별 대상
                
                - 응용 또는 사용자 프로세스를 식별하여 주며, 목적지 호스트 내 실행 중인 특정 서비스나 어플리케이션을 지칭합니다.
                - `Port Address (포트 주소) / Port Number (포트 번호)`에 의해 구별됩니다.
                
                ### 포트 번호의 길이
                
                - 포트 번호(Port Address)는 16 비트 길이를 갖게 되어, 이론상 \(2^{16} = 65,536\) (0~65,535)개의 서로 다른 TCP 또는 UDP 연결이 가능합니다.
                
                ### 포트 번호의 전달
                
                - 포트 번호는 `UDP 헤더` 또는 `TCP 헤더` 내에 포함되어 전달됩니다.
                - 전달 주체(TCP, UDP)에 따라 TCP 소켓, UDP 소켓으로 다르게 식별됩니다.
                - 같은 포트 번호라도, 사용 전송 프로토콜이 TCP이냐 UDP이냐에 따라 다르게 식별됩니다.
                
                ### TCP/IP에서 포트 번호의 유형
                
                ### Well Known Port (0 ~ 1023)
                
                - IANA에서 관리되는 잘 알려진 포트번호입니다.
                - 예: DHCP (출발:67, 목적:68), DNS (53), FTP (control:20, data:21), HTTP (80), HTTPS (443), POP3 (110), SMB (137-139), SMTP (25), SSH (22), Telnet (23) 등
                
                ### Registered Port (1024 ~ 49151)
                
                - 등록된 포트 범위입니다.
                
                ### Dynamic and/or Private Port (49152 ~ 65535)
                
                - 동적 및/또는 개인 포트 범위입니다.
        - TCP 활용
            - 상위 프로토콜 지원: HTTP, FTP, SMTP 등
            - 응용 지원: TELNET, 웹, 전자우편 등
        - UDP 와 차이
            - TCP는 신뢰성과 순서 보장이 필요한 애플리케이션에 주로 사용되며, UDP(User Datagram Protocol)는 빠른 속도가 요구되지만, 신뢰성이 덜 중요한 경우 사용됩니다.
            - 예를 들어, TCP는 이메일과 웹 페이지 로딩에 사용되며, UDP는 스트리밍과 온라인 게임에 적합합니다.
    - 제어
        - 흐름 제어
            - Stop & Wait
                - **작동 방식**: 송신측은 단일 데이터 프레임을 전송하고, 해당 프레임에 대한 수신측의 확인 응답(ACK)을 기다립니다. ACK를 받은 후에만 다음 데이터 프레임을 전송합니다.
                - **장점**: 구현이 단순하고, 송수신 상태 관리가 용이합니다.
                - **단점**: 매 프레임 전송 후 ACK를 기다려야 하므로, 네트워크 대역폭과 지연 시간을 고려할 때 효율성이 낮습니다. 특히, 높은 지연 시간을 가진 네트워크에서 성능 저하가 두드러집니다.
            - Sliding Window
                
                ### TCP에서 슬라이딩 윈도우 방식
                
                이 방식은 송신자와 수신자 사이에서 유지되는 버퍼의 크기를 동적으로 조절하여, 네트워크의 혼잡 상태나 수신자의 처리 능력에 따라 데이터 전송 속도를 최적화합니다.
                
                ### 슬라이딩 윈도우의 핵심 요소
                
                - **윈도우 크기(Window Size)**: 한 번에 전송할 수 있는 데이터의 양을 결정합니다. 윈도우 크기는 송신측과 수신측 양쪽에서 관리되며, 네트워크 상황에 따라 동적으로 조절됩니다.
                - **송신 윈도우(Send Window)**: 송신측에서 아직 ACK를 받지 못한 데이터 세그먼트의 집합을 관리합니다. 이 윈도우는 데이터를 연속적으로 전송할 수 있는 범위를 결정하며, ACK의 수신에 따라 이동하거나 크기가 조정됩니다.
                - **수신 윈도우(Receive Window)**: 수신측에서 한 번에 받아들일 수 있는 데이터의 최대 양을 나타냅니다. 이는 수신측의 버퍼 크기에 의해 결정되며, 송신측에 이 정보를 전달하여 송신 윈도우의 크기를 조절하는 데 사용됩니다.
                
                ### 슬라이딩 윈도우의 작동 방식
                
                1. **데이터 전송 시작**: 송신측은 수신측으로부터 받은 윈도우 크기 정보를 바탕으로, 해당 윈도우 크기 내에서 데이터를 전송합니다.
                2. **ACK의 수신**: 수신측은 데이터를 받을 때마다 해당 데이터의 끝 부분을 나타내는 순서 번호를 포함한 ACK를 송신측으로 보냅니다.
                3. **윈도우의 이동**: 송신측은 ACK를 받을 때마다 송신 윈도우를 "슬라이드" 하여 다음에 전송할 데이터의 범위를 업데이트합니다. 이 과정에서 윈도우 크기가 네트워크 상황에 따라 조절될 수 있습니다.
                4. **흐름 제어와 혼잡 제어**: 슬라이딩 윈도우 방식은 네트워크의 혼잡 상태를 감지하고, 수신측의 데이터 처리 능력을 고려하여 데이터 전송 속도를 조절함으로써 효율적인 통신을 유지합니다.
            - Selective Repeat
                
                ### Selective Repeat ARQ
                
                송신측이 데이터 세그먼트를 순차적으로 전송하고, 수신측이 개별 세그먼트의 수신을 확인하여 오류가 발생한 세그먼트만을 선택적으로 재요청(repeat)하게 합니다.
                
                ### Selective Repeat ARQ의 주요 특징
                
                - **개별 ACK**: 수신측은 각 세그먼트에 대해 개별적으로 확인 응답(ACK)을 보냅니다. 이를 통해 송신측은 어떤 세그먼트가 성공적으로 수신되었는지 정확히 알 수 있습니다.
                - **선택적 재전송**: 오류가 감지된 세그먼트나 수신되지 않은 세그먼트만을 대상으로 재전송을 요청합니다. 이는 불필요한 데이터 전송을 최소화하고 네트워크 효율을 높입니다.
                - **순서 유지**: 수신측은 재정렬 버퍼(reordering buffer)를 사용하여 순서가 뒤바뀐 세그먼트를 올바른 순서로 재조합할 수 있습니다.
                
                ### Selective Repeat ARQ의 작동 방식
                
                1. **데이터 전송**: 송신측은 여러 개의 데이터 세그먼트를 네트워크를 통해 수신측으로 전송합니다.
                2. **개별 세그먼트 확인**: 수신측은 각 세그먼트를 개별적으로 확인하고, 해당 세그먼트에 대한 ACK를 송신측으로 전송합니다.
                3. **오류 감지 및 재전송 요청**: 오류가 발생한 세그먼트나 누락된 세그먼트에 대해 수신측은 NACK(부정 확인 응답)을 보내거나, 송신측이 타임아웃을 통해 재전송을 결정합니다.
                4. **선택적 재전송 실행**: 송신측은 오류가 감지된 세그먼트만을 선택적으로 재전송합니다.
                5. **데이터 재조합**: 수신측은 받은 세그먼트를 올바른 순서로 재조합하여 최종 데이터를 복구합니다.
                
                ### Selective Repeat ARQ의 장점
                
                - 네트워크 대역폭과 자원을 효율적으로 사용합니다.
                - 오류 발생 시 필요한 세그먼트만을 재전송함으로써 전체적인 전송 시간을 단축할 수 있습니다.
                - 데이터의 순서가 변경되어도 수신측에서 올바르게 재조합할 수 있어, 데이터 전송의 신뢰성을 보장합니다.
                
                Selective Repeat ARQ는 특히 패킷 손실이나 오류가 빈번한 네트워크 환경에서 데이터 전송의 신뢰성과 효율성을 크게 개선할 수 있는 방식입니다.
                
            - Go Back N
                - **일괄 재전송**: 오류가 감지된 첫 번째 세그먼트와 그 이후 모든 세그먼트를 재전송합니다.
                - **간단한 구현**: 수신측은 순서가 맞지 않는 세그먼트를 버퍼링하지 않고 버립니다. 이후 송신측은 재전송을 통해 순서대로 다시 전송합니다.
                - **오버헤드**: 재전송되는 데이터 양이 많아질 수 있어, 네트워크 자원의 낭비가 발생할 수 있습니다. 특히, 오류율이 높은 네트워크에서 효율성이 떨어집니다.
        - 혼잡 제어
            - TCP (Transmission Control Protocol) 혼잡 제어는 네트워크의 혼잡 상태를 감지하고, 이를 완화하기 위해 데이터 전송률을 조절하는 방법 입니다.
            - TCP 혼잡 제어의 주요 목적은 네트워크의 효율성과 공정성을 유지하면서 데이터 전송률을 최적화하는 것입니다.
            - 주요 알고리즘으로는 **AIMD (Additive Increase/Multiplicative Decrease)**, **슬로우 스타트 (Slow Start)**, **혼잡 회피 (Congestion Avoidance)**, **빠른 회복 (Fast Recovery)** 등이 있습니다.
            - AIMD (Additive Increase/Multiplicative Decrease)
                - **적용 원리**: 네트워크 혼잡이 발생하지 않을 때는 데이터 전송률을 점진적으로 증가시키고 (Additive Increase), 패킷 손실이 감지되면 전송률을 급격히 감소시킵니다 (Multiplicative Decrease).
                - **동작 방식**:
                    - **Additive Increase**: 각 RTT(Round-Trip Time)마다 cwnd(congestion window)를 1 MSS(Maximum Segment Size)만큼 증가시킵니다.
                    - **Multiplicative Decrease**: 패킷 손실이 감지되면 cwnd를 현재 값의 절반으로 줄입니다.
                
            - 슬로우 스타트 (Slow Start)
                - **목적**: 네트워크 혼잡 상태를 고려하지 않고 전송률을 급격히 증가시키는 것이 아니라, 점진적으로 증가시키며 네트워크 용량을 탐색합니다.
                - **동작 방식**:
                    - 연결 초기에 cwnd를 1 MSS로 설정하고, 각 ACK(acknowledgement) 수신마다 cwnd를 1 MSS만큼 증가시킵니다. 이로 인해 전송률은 지수적으로 증가합니다.
                    - cwnd가 ssthresh(slow start threshold)에 도달하면 혼잡 회피 단계로 전환합니다.
            - 혼잡 회피 (Congestion Avoidance)
                - **목적**: 네트워크의 혼잡이 발생할 가능성을 줄이기 위해 전송률의 증가 속도를 점진적으로 늦춥니다.
                - **동작 방식**:
                    - cwnd가 ssthresh에 도달하면, 각 RTT마다 cwnd를 `cwnd/cwnd`만큼 증가시킵니다. 이는 사실상 cwnd가 1 MSS만큼만 증가하는 것을 의미합니다.
            - 빠른 회복 (Fast Recovery)
                - **목적**: 패킷 손실이 감지되었을 때, 네트워크의 혼잡 상태를 신속하게 회복하고, 데이터 전송률을 재조정합니다.
                - **동작 방식**:
                    - 패킷 손실이 3개의 중복 ACK를 통해 감지되면, ssthresh를 현재 cwnd의 절반으로 설정하고, cwnd를 `ssthresh + 3 MSS`로 조정합니다.
                    - 이후 중복 ACK가 계속 수신되면 cwnd를 1 MSS만큼 계속 증가시킵니다.
                    - 새로운 데이터 ACK를 받으면 cwnd를 ssthresh 값으로 재설정하고 혼잡 회피 단계로 돌아갑니다.
        - 오류 제어
            
            TCP (Transmission Control Protocol)는 신뢰성 있는 통신을 제공하기 위해 오류가 발생했을 때 이를 감지하고 수정하는 여러 방법을 사용
            
            ### 1. 재전송 (Retransmission)
            
            - **동작 방식:**
                - TCP는 데이터 세그먼트를 전송한 후, 해당 세그먼트에 대한 수신측의 확인응답(ACK)을 기다립니다.
                - 타임아웃이 발생하거나 순서에 맞지 않는 세그먼트가 도착하면, 데이터가 손실되었거나 오류가 발생했다고 간주하고 해당 데이터를 재전송합니다.
            - **목적:** 데이터 손실이나 오류 발생 시, 원본 데이터를 수신측에 정확하게 전달하기 위함입니다.
            
            ### 2. 순서 번호 (Sequence Numbers)
            
            - **동작 방식:**
                - TCP는 전송되는 각 바이트에 고유한 순서 번호를 할당합니다. 수신측은 이 순서 번호를 사용하여 세그먼트의 순서를 재구성하고, 누락된 세그먼트를 감지합니다.
            - **목적:** 데이터의 순서가 바뀌거나 세그먼트가 중복되는 경우를 방지하고, 데이터의 정확한 순서대로 재조합할 수 있도록 합니다.
            
            ### 3. 확인 응답 (Acknowledgements)
            
            - **동작 방식:** 수신측은 정상적으로 받은 세그먼트의 순서 번호를 ACK로 송신측에 전송하여, 해당 데이터를 성공적으로 수신했음을 알립니다. 만약 특정 세그먼트가 누락되면, 누락된 세그먼트의 순서 번호를 포함하는 ACK를 보내 재전송을 요청합니다.
            - **목적:** 송신측이 어떤 세그먼트가 성공적으로 수신되었는지, 또 어떤 세그먼트가 재전송되어야 하는지 파악할 수 있게 합니다.
            
            ### 
            
- UDP
    
    ### UDP (User Datagram Protocol)
    
    UDP는 인터넷 프로토콜 스위트의 일부로, 간단하면서도 신뢰성이 없는 데이터그램 서비스를 제공하는 통신 프로토콜입니다. TCP와 대비되는 특징을 가지며, 특정 상황에서 더 유리하게 사용됩니다.
    
    ### UDP의 주요 특징
    
    - **비연결 지향**: UDP는 연결 설정 과정 없이 데이터를 전송합니다. 이는 빠른 데이터 전달을 가능하게 하지만, 데이터 손실 위험을 증가시킵니다.
    - **신뢰성 없는 전송**: 전송된 데이터의 도착을 보장하지 않으며, 순서대로 도착하거나 중복 없이 도착한다는 보장도 없습니다.
    - **오버헤드가 낮음**: TCP에 비해 헤더 크기가 작고, 연결 설정 및 유지에 필요한 추가 정보가 없기 때문에 오버헤드가 낮습니다.
    - **흐름제어 및 혼잡 제어 미제공**: 데이터 전송 속도 조절이나 네트워크 혼잡 상태에 대응하는 메커니즘이 없습니다.
    - **멀티캐스트 및 브로드캐스트 지원**: 한 번의 전송으로 여러 목적지에 데이터를 보낼 수 있습니다.
    
    ### UDP 헤더 구조
    
    - **Source Port (16 비트)**: 송신자의 포트 번호.
    - **Destination Port (16 비트)**: 수신자의 포트 번호.
    - **Length (16 비트)**: 헤더와 데이터를 포함한 UDP 데이터그램의 총 길이.
    - **Checksum (16 비트)**: 데이터의 무결성을 검사하기 위한 체크섬.
    
    ### UDP의 사용 사례
    
    - **실시간 애플리케이션**: VoIP(Voice over IP), 실시간 비디오 스트리밍, 온라인 게임 등 지연 시간이 중요한 애플리케이션에서 사용됩니다.
    - **간단한 요청 응답 서비스**: DNS 조회 등 짧은 메시지를 주고받는 서비스에 적합합니다.
    - **멀티캐스트 전송**: 네트워크 내 여러 장치에 동시에 데이터를 전송해야 하는 상황에 유용합니다.
    
    ### UDP의 한계
    
    - **데이터 손실 처리**: UDP 자체는 데이터 손실이나 순서 변경을 처리하지 않기 때문에, 필요한 경우 애플리케이션 레벨에서 별도의 로직을 구현해야 합니다.
    - **신뢰성과 순서 유지**: 중요한 데이터 전송에는 TCP나 신뢰성을 보장하는 다른 프로토콜의 사용을 고려해야 합니다.
    
    UDP는 그 특성상 특정 유형의 네트워크 통신에 매우 유용하며, 애플리케이션 개발자가 요구하는 네트워크 성능과 신뢰성에 따라 적절히 선택되어 사용됩니다.
    
- HTTP
    - HTTP
        - HTTP는 웹에서 데이터를 교환하기 위한 기본 프로토콜입니다.
        - 클라이언트와 서버 간의 통신을 가능하게 하며, 주로 HTML 문서와 같은 리소스를 전송하는 데 사용됩니다.
    - HTTP status code
        
        HTTP 상태 코드는 서버가 클라이언트의 요청을 처리한 결과를 나타내는 코드입니다. 이 코드들은 다섯 개의 클래스(응답 그룹)로 분류됩니다.
        
        - 1xx: 정보 응답
            - `100 Continue`: 클라이언트가 나머지 요청을 계속해도 좋음을 나타냅니다.
            - `101 Switching Protocols`: 서버가 클라이언트의 프로토콜 전환 요청을 승인했음을 나타냅니다.
        - 2xx: 성공
            - `200 OK`: 요청이 성공적으로 처리되었습니다.
            - `201 Created`: 요청이 성공적으로 이루어져 새로운 리소스가 생성되었습니다.
            - `204 No Content`: 요청은 성공적이지만, 클라이언트에게 전달할 콘텐츠가 없습니다.
        - 3xx: 리다이렉션
            - `301 Moved Permanently`: 요청된 리소스가 영구적으로 새 위치로 이동했습니다.
            - `302 Found`: 요청된 리소스가 일시적으로 다른 위치로 이동했습니다.
            - `304 Not Modified`: 이전에 방문한 적이 있는 클라이언트에게 리소스가 수정되지 않았음을 나타냅니다.
        - 4xx: 클라이언트 오류
            - `400 Bad Request`: 서버가 요청을 이해할 수 없습니다.
            - `401 Unauthorized`: 요청이 인증을 요구합니다.
            - `403 Forbidden`: 서버가 요청을 거부합니다.
            - `404 Not Found`: 서버가 요청한 리소스를 찾을 수 없습니다.
            - `408 Request Timeout`: 클라이언트가 요청을 시작한 후 서버가 요청을 기다리는 시간을 초과했습니다.
        - 5xx: 서버 오류
            - `500 Internal Server Error`: 서버 내부 오류로 요청을 처리할 수 없습니다.
            - `501 Not Implemented`: 서버가 요청 메소드를 지원하지 않습니다.
            - `502 Bad Gateway`: 서버가 게이트웨이로 작동 중 오류가 발생했습니다.
            - `503 Service Unavailable`: 서버가 일시적으로 서비스를 제공할 수 없습니다.
    - HTTP method
        - 종류
            - **GET**: 지정된 리소스를 요청합니다.
            - **POST**: 서버로 데이터를 전송하여 새 리소스를 생성합니다.
            - **PUT**: 지정된 리소스를 업데이트합니다.
            - **DELETE**: 지정된 리소스를 삭제합니다.
            - **HEAD**: GET과 유사하지만, 리소스의 본문 없이 헤더 정보만을 요청합니다.
            - **OPTIONS**: 대상 리소스에 대한 통신 옵션을 설명합니다.
        - 멱등성
            
            ### 멱등성 (Idempotence)
            
            - 멱등성은 수학과 컴퓨터 과학에서 사용되는 개념으로, 어떤 작업을 여러 번 수행해도 결과가 달라지지 않는 성질을 의미합니다.
            - HTTP 메서드의 컨텍스트에서 멱등성은 같은 요청을 여러 번 보냈을 때, 첫 번째 요청 이후에는 서버의 상태가 추가적으로 변하지 않음을 보장합니다.
            
            ### HTTP 메서드와 멱등성
            
            ### 멱등한 HTTP 메서드
            
            - **GET**: 리소스를 조회하는 메서드로, 멱등합니다. 여러 번 요청해도 서버의 상태가 변경되지 않습니다.
            - **HEAD**: GET과 유사하지만, 응답 본문 없이 헤더 정보만을 반환합니다. 멱등합니다.
            - **PUT**: 지정된 리소스를 업데이트하거나 생성합니다. 동일한 PUT 요청을 여러 번 보내도 최종적인 서버의 상태는 같으므로 멱등합니다.
            - **DELETE**: 지정된 리소스를 삭제합니다. 첫 번째 요청에서 리소스가 성공적으로 삭제되면, 이후의 동일한 DELETE 요청은 리소스가 없다는 응답을 반환하지만 상태 변경은 없으므로 멱등합니다.
            
            ### 비멱등한 HTTP 메서드
            
            - **POST**: 리소스를 생성하거나 데이터를 서버에 제출할 때 사용합니다. POST 요청은 같은 요청을 여러 번 보낼 경우, 서버에 여러 개의 리소스가 생성될 수 있으므로 비멱등합니다.
            
            ### 멱등성의 예외
            
            - 멱등성은 서버의 상태에 대한 것이며, 클라이언트가 받는 응답 내용이 항상 동일하다는 것을 보장하지 않습니다
            - 예를 들어, DELETE 요청을 처음 보낼 때와 두 번째 보낼 때 서버의 상태 변화는 없지만, 응답은 다를 수 있습니다(첫 번째는 성공, 두 번째는 리소스가 없음).
        - PUT, PATCH, POST method 차이
            
            `PUT`, `PATCH`, `POST`는 모두 데이터를 서버에 제출할 때 사용되지만, 각각의 목적과 사용 방식에 차이가 있습니다.
            
            ## POST
            
            - **목적**: 새로운 리소스를 생성합니다.
            - **동작**: 서버에 데이터를 제출하여 새 리소스를 생성하거나, 데이터 처리를 요청합니다. POST 요청은 보통 데이터 추가에 사용됩니다.
            - **특징**: 같은 POST 요청을 반복할 경우, 동일한 데이터에 대해 여러 번의 요청이 이루어져도 매번 새로운 리소스가 생성될 수 있습니다.
            
            ## PUT
            
            - **목적**: 지정된 리소스를 업데이트하거나 존재하지 않으면 생성합니다.
            - **동작**: 서버에 데이터를 제출하여 지정된 리소스를 업데이트합니다. 리소스의 전체를 교체하기 위해 사용됩니다.
            - **특징**: 같은 PUT 요청을 반복할 경우, 첫 번째 요청 이후에는 리소스의 상태가 변경되지 않습니다(멱등성). 즉, 동일한 요청은 여러 번 수행해도 결과가 같습니다.
            
            ## PATCH
            
            - **목적**: 리소스의 부분적인 업데이트를 수행합니다.
            - **동작**: 서버에 데이터를 제출하여 리소스의 일부분만을 업데이트합니다. 리소스의 전체를 대체하지 않고, 일부분만 변경하고 싶을 때 사용됩니다.
            - **특징**: PUT 메서드와 비교했을 때, PATCH는 리소스의 일부만을 수정하므로, 전체 리소스를 업로드할 필요가 없어 네트워크 효율성이 더 높을 수 있습니다.
    - HTTP version
        - **HTTP/1.0**: 초기 버전으로, 각 요청마다 새로운 TCP 연결을 수립합니다.
        - **HTTP/1.1**: 지속 연결, 파이프라이닝, 호스트 헤더 등의 기능을 도입하여 효율성을 개선했습니다.
        - **HTTP/2**: 이진 프레이밍, 서버 푸시, 헤더 압축 등을 통해 성능을 크게 향상시켰습니다.
        - **HTTP/3**: QUIC 프로토콜을 기반으로, 연결 설정 시간을 단축하고, 패킷 손실 시의 성능 저하를 줄였습니다.
    - HTTP header
        - HTTP Body 이외에, 추가적인 정보를 교환 할 수 있도록
        - HTTP 메세지 선두에 삽입되는 요소로 다양한 종류를 갖음
        
        ### 1. 일반 헤더 (General Header)
        
        - 요청과 응답 모두에 공통적으로 사용되며, 메시지 전체에 적용되는 정보를 담는다.
        - 예: `Date`, `Cache-Control`
        
        ### 2. 요청 헤더 (Request Header)
        
        - 클라이언트가 서버에게 전송하는 요청의 세부 정보를 포함
        - 요청의 컨텍스트, 클라이언트의 선호도, 클라이언트 자체에 대한 정보 등을 제공
        - 예: `User-Agent`, `Accept`, `Host`, `Cookie`
        
        ### 3. 응답 헤더 (Response Header)
        
        - 서버가 클라이언트에게 전송하는 응답의 추가 정보를 포함
        - 응답의 컨텍스트와 서버 자체에 대한 정보를 제공
        - 예: `Server`, `Set-Cookie`
        
        ### 4. 엔티티 헤더 (Entity Header)
        
        - 전송되는 리소스 자체에 대한 정보를 포함
        - 요청과 응답 메시지의 본문(엔티티 본문)에 대한 세부 정보를 제공
        - 예: `Content-Type`, `Content-Length`, `Last-Modified`
        
        ### 주요 HTTP 헤더 예시
        
        - **Content-Type**: 엔티티 본문의 미디어 타입을 지정
        - **Content-Length**: 엔티티 본문의 길이나 크기를 바이트 단위로 지정
        - **User-Agent**: 요청을 생성한 클라이언트의 응용 프로그램 유형, 운영 체제, 소프트웨어 버전 등을 식별
        - **Accept**: 클라이언트가 이해하고 처리할 수 있는 미디어 타입을 지정
        - **Authorization**: 사용자 인증 정보를 서버에 전송하기 위해 사용
        - **Cookie**: 서버에서 클라이언트로 전송된 쿠키를 저장하고, 후속 요청에서 이 쿠키를 서버로 다시 전송
- HTTPS
    - HTTPS
        
        HTTPS는 웹 상에서 정보를 안전하게 교환하기 위한 프로토콜입니다. 기본적으로 HTTP의 보안 버전이며, 데이터의 암호화 및 인증을 통해 보안을 강화합니다.
        
        ## HTTPS의 주요 특징
        
        - **암호화**: 데이터를 전송하는 동안 정보를 암호화하여, 중간에 누군가 데이터를 가로채더라도 내용을 해석할 수 없도록 합니다. 이는 SSL(Secure Sockets Layer) 또는 TLS(Transport Layer Security) 프로토콜을 사용하여 구현됩니다.
        - **데이터 무결성**: 데이터가 전송 중에 변경되거나 손상되지 않았음을 보장합니다.
        - **인증**: 클라이언트는 서버가 실제로 자신이 연결하려고 하는 서버임을 확인할 수 있습니다. 이는 일반적으로 SSL/TLS 인증서를 통해 이루어집니다.
        
        ## HTTPS 작동 방식
        
        1. **클라이언트(브라우저)가 HTTPS를 통해 웹 사이트에 접속을 시도**할 때, 서버는 자신의 공개키와 함께 SSL/TLS 인증서를 클라이언트에게 제공합니다.
        2. **클라이언트는 제공된 인증서가 신뢰할 수 있는 인증 기관(CA)에 의해 발급된 것인지 검증**합니다.
        3. 인증서가 유효하면, 클라이언트는 **서버의 공개키를 사용하여 세션 키를 암호화**하여 서버에 전송합니다.
        4. **서버는 자신의 비밀키를 사용하여 세션 키를 복호화**하고, 이 세션 키를 사용하여 세션 동안 클라이언트와의 통신을 암호화합니다.
        
        ## HTTPS의 장점
        
        - 사용자의 정보를 보호하고, 데이터 도난 및 변조를 방지합니다.
        - 사용자가 방문하는 사이트의 신뢰성과 안전성을 높여줍니다.
        - SEO(검색 엔진 최적화) 측면에서도 긍정적인 영향을 미칩니다. Google은 HTTPS를 사용하는 웹사이트를 더 높게 평가합니다.
        
        ## HTTPS의 단점
        
        - 암호화 과정에서 약간의 성능 저하가 발생할 수 있습니다.
        - SSL/TLS 인증서를 구매하고 유지 관리해야 하는 비용이 발생할 수 있습니다. 그러나, Let's Encrypt와 같은 서비스를 통해 무료 인증서를 발급받을 수도 있습니다.
    - 인증서 정보
        
        HTTPS 통신에서 서버 인증서는 클라이언트와 서버 간의 안전한 통신을 보장하기 위해 사용됩니다. 인증서는 신뢰할 수 있는 인증 기관(Certificate Authority, CA)에 의해 발급되며, 여러 중요한 정보를 포함하고 있습니다.
        
        ## 주요 정보
        
        ### 1. 서버의 정보
        
        - **일반적인 이름(Common Name, CN)**: 인증서가 발급된 서버의 도메인 이름입니다. 예를 들어, `www.example.com`.
        - **조직 이름(Organization, O)**: 인증서를 신청한 기업이나 조직의 정식 명칭입니다.
        - **조직 단위(Organizational Unit, OU)**: 조직 내에서 인증서를 관리하는 부서나 단위입니다.
        
        ### 2. 인증 기관(CA)의 정보
        
        - **발급자 이름(Issuer Name)**: 인증서를 발급한 CA의 이름입니다.
        - **인증서의 유효 기간**: 인증서가 발급된 날짜와 만료되는 날짜를 포함합니다. 이 기간 동안 인증서는 유효합니다.
        
        ### 3. 인증서의 고유 정보
        
        - **시리얼 번호(Serial Number)**: CA에 의해 인증서에 할당된 고유 번호입니다.
        - **버전(Version)**: 인증서의 버전을 나타냅니다. 현재 널리 사용되는 인증서는 버전 3(V3)입니다.
        
        ### 4. 암호화 정보
        
        - **공개 키(Public Key)**: 서버의 공개 키. 이 키는 클라이언트가 서버에 안전하게 정보를 전송하기 위해 사용됩니다.
        - **서명 알고리즘(Signature Algorithm)**: 인증서의 발급자(CA)가 인증서를 서명하는 데 사용한 암호화 알고리즘입니다.
        - **서명(Signature)**: CA에 의해 생성된 인증서의 디지털 서명. 이는 인증서의 진위와 데이터의 무결성을 보증합니다.
        
        ### 5. 확장(Extensions)
        
        - **주체 대안 이름(Subject Alternative Name, SAN)**: 인증서가 유효한 추가 도메인 이름을 포함할 수 있습니다. 예를 들어, 같은 사이트의 여러 도메인을 포함할 수 있습니다.
        - **키 사용(Key Usage)**: 인증서의 키가 사용될 수 있는 목적을 나타냅니다. 예를 들어, 디지털 서명, 키 암호화 등이 있습니다.
        - **확장 키 사용(Extended Key Usage, EKU)**: 특정 애플리케이션에서 공개 키가 사용되는 더 구체적인 방법을 나타냅니다.
    - 암호화 방식
        - 공개키
            
            공개키 방식은 암호화와 복호화에 서로 다른 두 개의 키를 사용하는 암호화 기법입니다. 이 방식은 공개키와 비밀키(개인키)라는 두 가지 키를 사용하며, 이 두 키는 수학적으로 관련되어 있지만, 한 키로부터 다른 키를 유도하기는 계산상 불가능합니다.
            
            ## 공개키 방식의 주요 특징
            
            - **비대칭 암호화**: 공개키로 암호화된 데이터는 비밀키를 사용해야만 복호화할 수 있으며, 그 반대의 경우도 마찬가지입니다.
            - **키의 공개성**: 공개키는 이름 그대로 공개되어 있어 누구나 접근할 수 있지만, 비밀키는 소유자만이 알고 있어야 합니다.
            
            ## 공개키 방식의 사용 사례
            
            - **암호화와 복호화**: 데이터를 안전하게 전송하기 위해, 발신자는 수신자의 공개키로 데이터를 암호화합니다. 수신자만이 자신의 비밀키로 데이터를 복호화할 수 있습니다.
            - **디지털 서명**: 문서나 메시지에 대한 발신자의 신원을 확인하고, 데이터의 무결성을 보장하기 위해 사용됩니다. 발신자는 자신의 비밀키로 메시지를 서명하고, 수신자는 발신자의 공개키를 사용하여 서명을 검증할 수 있습니다.
            
            ## 공개키 방식의 장점
            
            - **키 관리의 용이성**: 대칭키 방식에 비해 많은 수의 사용자 간에 안전한 통신을 위한 키 관리가 훨씬 쉽습니다.
            - **안전한 통신**: 데이터의 암호화와 복호화, 디지털 서명 등을 통해 안전한 데이터 전송과 신원 확인이 가능합니다.
            
            ## 공개키 방식의 단점
            
            - **처리 속도**: 대칭키 방식에 비해 암호화 및 복호화 과정이 더 복잡하고 시간이 많이 소요됩니다.
            - **키의 길이**: 같은 수준의 보안을 제공하기 위해, 공개키 방식은 대칭키 방식보다 훨씬 긴 키를 사용해야 합니다.
            
            ## 주요 알고리즘
            
            - **RSA (Rivest-Shamir-Adleman)**: 가장 널리 사용되는 공개키 암호화 알고리즘 중 하나입니다.
            - **ECC (Elliptic Curve Cryptography)**: RSA에 비해 상대적으로 짧은 키 길이로 같은 수준의 보안을 제공합니다.
            - **Diffie-Hellman**: 주로 키 교환에 사용되는 알고리즘으로, 안전한 통신 채널의 설정에 사용됩니다.
        - 대칭키
            
            대칭키 암호화 방식은 암호화와 복호화 과정에 같은 키를 사용하는 암호화 기법입니다. 이 방식은 데이터를 안전하게 전송하거나 저장하기 위해 널리 사용됩니다.
            
            ## 대칭키 암호화 방식의 주요 특징
            
            - **단일 키 사용**: 암호화와 복호화에 동일한 키를 사용합니다. 이 키를 대칭키라고 합니다.
            - **속도**: 대칭키 암호화 방식은 공개키 암호화 방식에 비해 계산이 더 간단하고 빠릅니다.
            
            ## 사용 사례
            
            - **데이터 암호화**: 파일, 데이터베이스 내용, 네트워크 통신 등의 데이터를 암호화하여 안전하게 보관하거나 전송할 때 사용됩니다.
            - **VPN**: 가상 사설 네트워크(VPN)에서 데이터를 안전하게 전송하기 위해 대칭키 암호화를 사용합니다.
            - **디지털 결제 시스템**: 신용 카드 정보와 같은 민감한 결제 정보를 보호하기 위해 사용됩니다.
            
            ## 대칭키 암호화 방식의 장점
            
            - **효율성**: 빠른 처리 속도로 인해 대량의 데이터를 신속하게 암호화하고 복호화할 수 있습니다.
            - **구현의 단순성**: 알고리즘이 비교적 단순하여 소프트웨어 및 하드웨어에 쉽게 구현할 수 있습니다.
            
            ## 대칭키 암호화 방식의 단점
            
            - **키 관리**: 암호화와 복호화에 같은 키를 사용하기 때문에, 키를 안전하게 배포하고 관리하는 것이 중요합니다. 대규모 시스템에서 많은 사용자 간에 안전하게 키를 공유하는 것은 어려울 수 있습니다.
            - **보안성**: 키가 노출되면 암호화된 데이터의 보안이 취약해집니다.
            
            ## 주요 알고리즘
            
            - **AES (Advanced Encryption Standard)**: 현재 가장 널리 사용되는 대칭키 암호화 알고리즘입니다.
            - **DES (Data Encryption Standard)**: 오래된 알고리즘으로, 현재는 AES에 의해 대체되었습니다.
            - **3DES (Triple DES)**: DES의 보안을 강화하기 위해 데이터를 세 번 암호화하는 방식입니다.
- DNS
    
    DNS는 인터넷상에서 도메인 이름을 IP 주소로 변환하는 분산형 데이터베이스 시스템입니다. 사용자가 웹 브라우저에 도메인 이름을 입력할 때, DNS는 해당 이름을 컴퓨터가 이해할 수 있는 IP 주소로 변환하여 웹사이트에 접속할 수 있도록 합니다.
    
    ## DNS의 주요 기능
    
    - **도메인 이름 해석**: 사용자 친화적인 도메인 이름을 컴퓨터가 이해할 수 있는 숫자로된 IP 주소로 변환합니다.
    - **로드 밸런싱**: 여러 서버에 걸쳐 트래픽을 분산시키는 기능을 제공하여, 하나의 도메인에 대해 여러 IP 주소를 할당할 수 있습니다.
    
    ## DNS 작동 원리
    
    1. **사용자가 웹 브라우저에 URL 입력**
    2. **브라우저는 DNS 서버에 도메인 이름의 IP 주소 요청**
    3. **DNS 서버는 요청 받은 도메인 이름에 해당하는 IP 주소를 찾아 응답**
    4. **브라우저는 받은 IP 주소로 웹사이트에 접속**
    
    ## DNS 구성 요소
    
    - **도메인 이름**: 인터넷 상의 컴퓨터, 서비스 또는 자원을 가리키는 주소입니다. 예: `www.example.com`
    - **DNS 서버**: 도메인 이름을 IP 주소로 변환하는 서비스를 제공하는 서버입니다.
        - **루트 DNS 서버**: 도메인 이름의 최상위 레벨을 관리합니다.
        - **TLD (Top-Level Domain) 서버**: 최상위 도메인(.com, .net, .org 등)의 정보를 관리합니다.
        - **권한 있는 DNS 서버**: 특정 도메인에 대한 구체적인 정보를 가지고 있습니다.
    
    ## DNS 쿼리 타입
    
    - **재귀 쿼리**: 클라이언트가 DNS 서버에 도메인 이름에 대한 IP 주소를 요청하고, DNS 서버가 최종 결과를 반환할 때까지 다른 DNS 서버에 요청을 계속하는 방식입니다.
    - **반복 쿼리**: DNS 서버가 클라이언트의 요청에 대해 직접 알고 있는 정보를 바탕으로 응답하거나, 다른 DNS 서버의 주소를 클라이언트에 알려주고 클라이언트가 해당 서버에 직접 요청을 하는 방식입니다.
    
    ## DNS의 중요성
    
    - **인터넷 사용의 편리성**: 사용자가 기억하기 쉬운 도메인 이름으로 웹사이트에 접근할 수 있게 합니다.
    - **인터넷의 구조와 운영**: 인터넷상의 수많은 웹사이트와 서비스가 효율적으로 운영될 수 있는 기반을 제공합니다.
    
    DNS는 인터넷의 핵심적인 부분이며, 웹사이트 접속, 이메일 전송, 온라인 서비스 이용 등 거의 모든 인터넷 활동에 필수적인 역할을 합니다.