- TCP
  - 흐름제어, 혼잡제어, 오류제어
  - 3-way-handshake, 4-way-handshake  
- UDP
- HTTP
  - HTTP status code
  - HTTP method 종류
  - 멱등성
  - PUT, PATCH, POST method 차이
  - HTTP 1.1, 2.0, 3.0
  - HTTP 헤더
- HTTPS, SSL/TLS
  - 동작 원리
  - 공개키 대칭키 방식
- DNS

# TCP
## 3-way-handshake
***정확한 데이터 전송을 위해 연결을 성립하는 과정(connection establish)***
**클라이언트(A) → 서버(B)**

1. A -> B: SYN
  - 접속 요청 프로세스 A가 연결 요청 메시지 전송 (SYN)
  - 송신자가 최초로 데이터를 전송할 때 Sequence Number를 임의의 랜덤 숫자로 지정하고, SYN 플래그 비트를 1로 설정한 세그먼트를 전송한다.
  - PORT 상태 - B: LISTEN, A: CLOSED
2. B -> A: SYN + ACK
  - 접속 요청을 받은 프로세스 B가 요청을 수락했으며, 접속 요청 프로세스인 A도 포트를 열어 달라는 메시지 전송 (SYN + ACK)
  - 수신자는 Acknowledgement Number 필드를 (Sequence Number + 1)로 지정하고, SYN과 ACK 플래그 비트를 1로 설정한 세그먼트를 전송한다.
  - PORT 상태 - B: SYN_RCV, A: CLOSED
3. A -> B: ACK
  - PORT 상태 - B: SYN_RCV, A: ESTABLISHED
  - 마지막으로 접속 요청 프로세스 A가 수락 확인을 보내 연결을 맺음 (ACK)
  - 이때, 전송할 데이터가 있으면 이 단계에서 데이터를 전송할 수 있다.
  - PORT 상태 - B: ESTABLISHED, A: ESTABLISHED

## 4-way-handshake
***TCP의 연결을 해제(Connection Termination) 과정***

1. A -> B: FIN
  - 프로세스 A가 연결을 종료하겠다는 FIN 플래그를 전송
  - 프로세스 B가 FIN 플래그로 응답하기 전까지 연결을 계속 유지
2. B -> A: ACK
  - 프로세스 B는 일단 확인 메시지를 보내고 자신의 통신이 끝날 때까지 기다린다. (이 상태가 CLOSE_WAIT 상태)
  - 수신자는 Acknowledgement Number 필드를 (Sequence Number + 1)로 지정하고, ACK 플래그 비트를 1로 설정한 세그먼트를 전송한다.
  - 그리고 자신이 전송할 데이터가 남아있다면 이어서 계속 전송한다.
3. B -> A: FIN
  - 프로세스 B가 통신이 끝났으면 연결 종료 요청에 합의한다는 의미로 프로세스 A에게 FIN 플래그를 전송
4. A -> B: ACK
  - 프로세스 A는 확인했다는 메시지를 전송


## 흐름제어(Flow Control)
***데이터를 송신하는 쪽과 수신하는 쪽의 데이터 처리 속도를 조절하여 수신 쪽 버퍼 오버플로우를 방지하기 위한 것***

- Stop and Wait: 매번 전송한 패킷에 대해 확인 응답을 받아야만 그 다음 패킷을 전송하는 방법
- Sliding Window: 수신측에서 설정한 윈도우 크기(단위 시간 내에 보내는 패킷의 수)만큼 송신측에서 확인응답 없이 세그먼트를 전송할 수 있게 하는 방식

## 혼잡제어(Congestion Control)
***송신측의 데이터 전달 속도와 네트워크의 데이터 처리 속도 차이를 해결하기 위한 기법***
네트워크 혼잡: 네트워크 상에 패킷의 수가 넘치게 많아지는 상황

- Slow start
  - 패킷을 하나씩 보내면서 시작하고, 패킷이 문제없이 도착하면 각각의 ACK 패킷마다 window size를 1씩 늘려준다. 혼잡 현상이 발생하면 window size를 1로 떨어뜨리게 된다.
- Fast Retransmit
  - 패킷을 받는 쪽에서 먼저 도착해야할 패킷이 도착하지 않고 다음 패킷이 도착한 경우에도 ACK 패킷을 보내게 된다.
  - 단, 순서대로 잘 도착한 마지막 패킷의 다음 패킷의 순번을 ACK 패킷에 실어서 보내게 되므로, 중간에 하나가 손실되게 되면 송신 측에서는 순번이 중복된 ACK 패킷을 받게 된다. 이것을 감지하는 순간 문제가 되는 순번의 패킷을 재전송 해줄 수 있다.
  - 중복된 순번의 패킷을 3개 받으면 재전송을 하게 된다. 약간 혼잡한 상황이 일어난 것이므로 혼잡을 감지하고 window size를 줄이게 된다.
- Fast Recovery
  - 혼잡한 상태가 되면 window size를 1로 줄이지 않고 반으로 줄이고 선형증가시키는 방법이다.

## 오류 제어
기본적으로 ARQ(Automatic Repeat Request) 방식의 오류제어를 사용한다. 즉, 문제 발생 시 해당 데이터를 재전송하는 방식을 사용한다.

- Go Back N
  - 데이터를 연속적으로 보내다가 오류가 발생한 부분부터 다시 재전송하는 방식
  - 송신측은 문제 있는 부분부터 재전송하고, 수신측은 기존의 수신한 데이터는 모두 폐기한다.
  - 이미 수신한 데이터를 폐기하고 재전송해야 한다는 단점이 존재
- Selective Repeat
  - 문제가 발생한 부분만 다시 전송하는 방법
  - 수신측 버퍼의 순서가 보장되지 않는다는 단점이 있다.
  - 수신측 버퍼의 재정렬이 필요하고, 따라서 또 다른 버퍼 공간을 필요로 한다는 단점이 있다.


## TCP
***데이터를 세그먼트 단위로 보내는 연결형 서비스. 속도는 느리지만 높은 신뢰도를 갖고 있다.***

1. 가상 회선 방식 사용
2. 흐름 제어, 혼잡 제어, 오류 제어 등을 사용
3. 높은 신뢰성 보장
4. UDP 보다 느림
5. 전이중(전송이 양방향으로 일어날 수 있음), 점대점(각 연결이 정확히 2개의 종단점을 가짐)
6. 멀티캐스팅이나 브로드캐스팅을 지원하지 않음

## UDP
***데이터를 데이터그램 단위로 보내는 비연결형 서비스. 속도는 빠르지만 신뢰도가 낮다.***

1. 신뢰성이 낮다.
2. TCP 보다 빠르다.

- UDP는 왜 사용할까?
  - 데이터의 신속성
  - 연결을 위한 오버헤드가 없다.
  - 실시간 스트리밍, DNS, HTTP 3
- DNS에 UDP가 사용되는 이유
  1. TCP가 3-way handshake를 사용하는 반면, UDP는 connection 을 유지할 필요가 없음.
  2. DNS request는 UDP segment에 꼭 들어갈 정도로 작음.

     DNS query는 single UDP request와 server로부터의 single UDP reply로 구성되어 있음.

  3. UDP는 not reliable이나, reliability는 application layer에 추가될 수 있음. (Timeout 추가나, resend 작업을 통해)


# HTTP 특징
- 클라이언트-서버 구조
- 무상태 프로토콜
  - stateful: 서버가 상태를 유지함. 중간에 서버가 바뀌면 문제가 생김
  - stateless: 서버가 상태를 유지하지 않음. 스케일 아웃(수평 확장)에 유리
- 비연결성
  - TCP 와는 달리 HTTP는 기본적으로 연결을 유지하지 않는 모델
  - 서버의 자원을 매우 효율적으로 사용할 수 있음
  - 한계
    - 매번 TCP/IP 연결을 새로 맺어야 함. 한 사이트를 요청하면 HTML 외에도 많은 자원을 함께 다운로드함 → 자원을 받을 때마다 connection을 맺으면 느림
    - 현재는 HTTP 지속 연결(Persistent Connection)으로 문제 해결

## HTTP 헤더에 대해 아는대로 설명
- General 헤더: 메시지 전체에 적용되는 정보
  - Connection
- Request 헤더: 요청 정보
  - Host, Authorization, Origin
- Response 헤더: 응답 정보
  - Access-Control-Allow-Origin
- Entity 헤더: 엔티티 바디 정보
  - Content-Type, Content-Length

## HTTP 메서드에 대해 설명
***HTTP 프로토콜을 통해 서버에 요청 정보를 전달할 때 사용하는 방식***

get, post, put, delete 등등이 있다.

## HTTP 멱등성
***같은 연산을 여러 번 실행한다 해도 그 결과가 달라지지 않는 성질***

서버의 데이터나 상태를 변경시키지 않아야 멱등함

POST 요청을 통해 데이터들이 추가됨 → 같은 내용이더라도 서로 다른 데이터임

GET: 어떤 리소스로부터 정보를 요청하기 위해 사용하는 메소드

POST: 리소스를 생성/업데이트하기 위해 사용하는 메소드

## PUT, PATCH, POST 메서드 차이
post는 요청 할 때마다 새로운 자원을 생성하지만, put은 최초 한 번만 생성되거나 계속 같은 값을 보내준다.

즉, post는 멱등하지 않고, put는  멱등하다.

put은 자원의 완전한 교체만을 허용하지만, patch는 부분적인 교체만 허용하는 메소드이다.

## Status Code
- 정리
  - 1xx: Information responses
  - 2xx: Success
  - 3xx: Redirection
  - 4xx: Client Error
  - 5xx: Server Error

**상태코드 200, 201 차이**

200 OK:  요청을 정상적으로 처리함

201 Created: 생성에 대한 요청을 받았으며 서버가 새로운 리소스를 생성함

**상태코드 403, 404 차이**

400 Bad Request: 잘못된 요청. 예를 들어 text 전달이 필요한데 숫자를 전달했다든지 등등

401 Unauthorized: 회원가입, 로그인 등이 필요하다는 것을 알림(인증)

403 Forbidden: 유저가 해당 요청에 대한 권한이 없다는 것을 나타냄(인가)

404 Not Found: 요청 uri가 존재하지 않음

# https
## 동작원리
https를 통한 인터넷 접속은 SSL(TLS)이라는 보안 프로토콜을 통해 보안이 향상된 통신을 하는 것이다.

SSL과 TLS는 응용계층과 전송계층 사이에 존재하는 또 하나의 독립적인 프로토콜 계층임.

HTTPS는 SSL 또는 TLS 위에 HTTP 프로토콜을 얹어 보안된 HTTP 통신을 하는 프로토콜이다(http + ssl).

즉, SSL과 TLS는 HTTP 뿐만 아니라 FTP, SMTP와 같은 다른 프로토콜에도 적용될 수 있다(FTPS, SMTPS).

**동작 흐름**

1. 애플리케이션 서버(A)를 만드는 기업은 HTTPS를 적용하기 위해 공개키와 개인키를 만든다.
2. 신뢰할 수 있는 CA 기업을 선택하고, 그 기업에게 내 공개키 관리를 부탁하며 계약을 한다. (***CA란?*** : Certificate Authority로, 공개키를 저장해주는 신뢰성이 검증된 민간기업)
3. 계약 완료된 CA 기업은 해당 기업의 이름, A서버 공개키, 공개키 암호화 방법을 담은 인증서를 만들고, 해당 인증서를 CA 기업의 개인키로 암호화해서 A서버에게 제공한다.
4. A서버는 암호화된 인증서를 갖게 되었다. 이제 A서버는 A서버의 공개키로 암호화된 HTTPS 요청이 아닌 요청이 오면, 이 암호화된 인증서를 클라이언트에게 건내준다.
5. 클라이언트가 `main.html` 파일을 달라고 A서버에 요청했다고 가정하자. HTTPS 요청이 아니기 때문에 CA기업이 A서버의 정보를 CA 기업의 개인키로 암호화한 인증서를 받게 된다. CA 기업의 공개키는 브라우저가 이미 알고있다. (세계적으로 신뢰할 수 있는 기업으로 등록되어 있기 때문에, 브라우저가 인증서를 탐색하여 해독이 가능한 것)
6. 브라우저는 해독한 뒤 A서버의 공개키를 얻게 되었다.
7. 클라이언트가 A서버와 HandShaking 과정에서 주고받은 난수를 조합하여 pre-master-secret-key 를 생성한 뒤, A서버의 공개키로 해당 대칭키를 암호화하여 서버로 보냅니다.
8. A서버는 암호화된 대칭키를 자신의 개인키로 복호화 하여 클라이언트와 동일한 대칭키를 획득합니다.
9. 클라이언트, 서버는 각각 pre-master-secret-key를 master-secret-key으로 만듭니다.
10. master-secret-key 를 통해 session-key를 생성하고 이를 이용하여 대칭키 방식으로 통신합니다.
11. 각 통신이 종료될 때마다 session-key를 파기합니다.

## 공개키, 대칭키 방식

- 암호화, 복호화시킬 수 있는 서로 다른 키(공개키, 개인키)를 이용한 암호화 방법
  - 공개키: 모두에게 공개. 공캐키 저장소에 등록
  - 개인키(비공개키): 개인에게만 공개. 클라이언트-서버 구조에서는 서버가 가지고 있는 비공개키
- 클라이언트 -> 서버
  - 사용자의 데이터를 **공개키로 암호화** (공개키를 얻은 인증된 사용자)
  - 서버로 전송 (데이터를 가로채도 개인키가 없으므로 **복호화할 수 없음**)
  - 서버의 **개인키를 통해 복호화**하여 요청 처리

# DNS
## 정의
Domain Name System의 약자. 도메인 네임과 ip 주소를 메핑 시켜서 갖고 있는 시스템.

## 동작 과정
1. 브라우저에서 요청
  1. 브라우저 캐시를 조회해보고 있으면 반환
2. 사용하고 있는 isp에 해당 도메인에 메핑되어있는 ip 주소를 요청한다.
  1. 마찬가지로 캐시를 조회해 있으면 반환
3. root dns와 tld, 도메인 제공 업체를 recursive하게 조회하여 ip 주소를 얻어온다.


# 예상 문제
- TCP와 UDP의 차이에 대해서 간단히 설명하시오.
- TCP의 연결 설정 과정과 연결 종료 과정에 대해서 간단히 설명하시오.
- TCP의 연결 설정 과정(3단계)과 연결 종료 과정(4단계)이 단계가 차이나는 이유?
  - client가 데이터 전송을 마쳤다고 하더라도 Server는 아직 보낼 데이터가 남아있을 수 있기 때문에 일단 FIN에 대한 ACK만 보내고, 데이터를 모두 전송한 후에 자신도 FIN 메시지를 보내기 때문이다.
- 만약 Server에서 FIN 플래그를 전송하기 전에 전송한 패킷이 Routing 지연이나 패킷 유실로 인한 재전송 등으로 인해 FIN 패킷보다 늦게 도착하는 상황이 발생하면 어떻게 될까?
  - 이러한 현상에 대비하여 Client는 Server로부터 FIN 플래그를 수신하더라도 일정시간(Default: 240sec)동안 세션을 남겨 놓고 잉여 패킷을 기다리는 과정을 거친다. (TIME_WAIT 과정)
- 개발하면서 경험한 적 있는 http 헤더들은 무엇이 있나요?
- http의 특징에 대해서 설명해주세요.
- https 통신의 과정에 대해 대략적으로 설명해주세요.
- DNS가 무엇이고, 브라우저에서 도메인을 입력하면 어떤 식으로 ip 주소를 얻어오는지 설명해주세요.